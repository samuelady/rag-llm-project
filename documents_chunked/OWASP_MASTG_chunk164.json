{"text": "several anti-debugging techniques applicable to iOS which can be categorized as preventive or as reactive. When properly distributed throughout the app, these techniques act as a supportive measure to increase the overall resilience. • Preventivetechniquesactasafirstlineofdefensetoimpedethedebuggerfromattachingtotheapplicationatall. • Reactivetechniquesallowtheapplicationtodetectthepresenceofadebuggerandhaveachancetodivergefrom normalbehavior. Using ptrace Asseeninchapter“TamperingandReverseEngineeringoniOS”,theiOSXNUkernelimplementsaptracesystemcall that’s lacking most of the functionality required to properly debug a process (e.g. it allows attaching/stepping but not read/writeofmemoryandregisters). Nevertheless,theiOSimplementationoftheptracesyscallcontainsanonstandardandveryusefulfeature: preventing thedebuggingofprocesses. ThisfeatureisimplementedasthePT_DENY_ATTACHrequest,asdescribedintheofficialBSD SystemCallsManual. Insimplewords,itensuresthatnootherdebuggercanattachtothecallingprocess;ifadebugger attemptstoattach, the processwillterminate. UsingPT_DENY_ATTACH isafairly well-knownanti-debuggingtechnique, soyoumayencounteritoftenduringiOSpentests. 508\\nBeforedivingintothedetails,itisimportanttoknowthatptraceisnotpartofthepubliciOSAPI.Non-publicAPIs areprohibited,andtheAppStoremayrejectappsthatincludethem. Becauseofthis,ptraceisnotdirectlycalled inthecode;it’scalledwhenaptracefunctionpointerisobtainedviadlsym. Thefollowingisanexampleimplementationoftheabovelogic: #import <dlfcn.h> #import <sys/types.h> #import <stdio.h> typedef int(*ptrace_ptr_t)(int_request,pid_t_pid,caddr_t_addr,int_data); void anti_debug(){ ptrace_ptr_tptrace_ptr =(ptrace_ptr_t)dlsym(RTLD_SELF,\"ptrace\"); ptrace_ptr(31,0,0,0);//PTRACE_DENY_ATTACH=31 } Bypass: Todemonstratehowtobypassthistechniquewe’lluseanexampleofadisassembledbinarythatimplements thisapproach: Let’sbreakdownwhat’shappeninginthebinary. dlsymiscalledwithptraceasthesecondargument(registerR1). The return value in register R0 is moved to register R6 at offset 0x1908A. At offset 0x19098, the pointer value in register R6 is called using the BLX R6 instruction. To disable the ptrace call, we need to replace the instruction BLX R6 (0xB0 0x47inLittleEndian)withtheNOP(0x00 0xBFinLittleEndian)instruction. Afterpatching,thecodewillbesimilartothe following: Armconverter.comisahandytoolforconversionbetweenbytecodeandinstructionmnemonics. Bypassesforotherptrace-basedanti-debuggingtechniquescanbefoundin“DefeatingAnti-DebugTechniques: macOS ptracevariants”byAlexanderO’Mara. Using sysctl Anotherapproachtodetectingadebuggerthat’sattachedtothecallingprocessinvolvessysctl. AccordingtotheApple documentation,itallowsprocessestosetsysteminformation(ifhavingtheappropriateprivileges)orsimplytoretrieve systeminformation(suchaswhetherornottheprocessisbeingdebugged). However,notethatjustthefactthatanapp usessysctlmightbeanindicatorofanti-debuggingcontrols,thoughthiswon’tbealwaysbethecase. TheAppleDocumentationArchiveincludesanexamplewhichcheckstheinfo.kp_proc.p_flagflagreturnedbythecall tosysctlwiththeappropriateparameters. AccordingtoApple,youshouldn’tusethiscodeunlessit’sforthedebug buildofyourprogram. 509\\nBypass: Onewaytobypassthischeckisbypatchingthebinary. Whenthecodeaboveiscompiled,thedisassembled versionofthesecondhalfofthecodeissimilartothefollowing: Aftertheinstructionatoffset0xC13C,MOVNE R0, #1ispatchedandchangedtoMOVNE R0, #0(0x000x20ininbytecode), thepatchedcodeissimilartothefollowing: You can also bypass a sysctl check by using the debugger itself and setting a breakpoint at the call to sysctl. This approachisdemonstratediniOSAnti-DebuggingProtections#2. Using getppid Applications on iOS can detect if they have been started by a debugger by checking their parent PID. Normally, an applicationisstartedbythelaunchdprocess,whichisthefirstprocessrunningintheusermodeandhasPID=1. However, ifadebuggerstartsanapplication,wecanobservethatgetppidreturnsaPIDdifferentthan1. Thisdetectiontechnique canbeimplementedinnativecode(viasyscalls),usingObjective-CorSwiftasshownhere: 510\\nfuncAmIBeingDebugged()->Bool{ returngetppid()!=1 } Bypass: Similarly to the other techniques, this has also a trivial bypass (e.g. by patching the binary or by using Frida hooks). File Integrity Checks Therearetwocommonapproachestocheckfileintegrity: usingapplicationsourcecodeintegritychecksandusingfile storageintegritychecks. Application Source Code Integrity Checks Inthe“TamperingandReverseEngineeringoniOS”chapter,wediscussedtheiOSIPAapplicationsignaturecheck. Wealso sawthatdeterminedreverseengineerscanbypassthischeckbyre-packagingandre-signinganappusingadeveloper orenterprisecertificate. Onewaytomakethisharderistoaddacustomcheckthatdetermineswhetherthesignatures stillmatchatruntime. AppletakescareofintegritycheckswithDRM.However,additionalcontrols(suchasintheexamplebelow)arepossible. Themach_headerisparsedtocalculatethestartoftheinstructiondata,whichisusedtogeneratethesignature. Next, thesignatureiscomparedtothegivensignature. Makesurethatthegeneratedsignatureisstoredorcodedsomewhere else. intxyz(char *dst){ const struct mach_header *header; Dl_infodlinfo; if(dladdr(xyz,&dlinfo)==0||dlinfo.dli_fbase ==NULL){ NSLog(@\"Error:Couldnotresolvesymbolxyz\"); [NSThreadexit]; } while(1){ header =dlinfo.dli_fbase; //PointerontheMach-Oheader struct load_command *cmd=(struct load_command *)(header +1);//Firstloadcommand //Nowiteratethroughloadcommand //tofind__textsectionof__TEXTsegment for(uint32_t i=0;cmd!=NULL && i<header->ncmds;i++){ if(cmd->cmd==LC_SEGMENT){ //__TEXTloadcommandisaLC_SEGMENTloadcommand struct segment_command *segment =(struct segment_command *)cmd; if(!strcmp(segment->segname,\"__TEXT\")){ //Stopon__TEXTsegmentloadcommandandgothroughsections //tofind__textsection struct section *section =(struct section *)(segment +1); for(uint32_t j=0;section !=NULL && j<segment->nsects;j++){ if(!strcmp(section->sectname,\"__text\")) break;//Stopon__textsectionloadcommand section =(struct section *)(section +1); } //Getherethe__textsectionaddress,the__textsectionsize //andthevirtualmemoryaddresssowecancalculate //apointeronthe__textsection uint32_t *textSectionAddr =(uint32_t *)section->addr; uint32_t textSectionSize =section->size; uint32_t *vmaddr =segment->vmaddr; char *textSectionPtr =(char *)((int)header +(int)textSectionAddr -(int)vmaddr); //Calculatethesignatureofthedata, //storetheresultinastring //andcomparetotheoriginalone unsigned char digest[CC_MD5_DIGEST_LENGTH]; CC_MD5(textSectionPtr,textSectionSize,digest); //calculatethesignature for(inti=0;i<sizeof(digest);i++) //fillsignature sprintf(dst+(2*i),\"%02x\",digest[i]); //returnstrcmp(originalSignature,signature)==0; //verifysignaturesmatch return 0; } } cmd=(struct load_command *)((uint8_t *)cmd+cmd->cmdsize); } } } 511\\nBypass: 1. Patchtheanti-debuggingfunctionalityanddisabletheunwantedbehaviorbyoverwritingtheassociatedcodewith NOPinstructions. 2. Patchanystoredhashthat’susedtoevaluatetheintegrityofthecode. 3. UseFridatohookfilesystemAPIsandreturnahandletotheoriginalfileinsteadofthemodifiedfile. File Storage Integrity Checks Apps might choose to ensure the integrity of the application storage itself, by creating an HMAC or signature over ei- ther a given key-value pair or a file stored on the device, e.g. in the Keychain, UserDefaults/NSUserDefaults, or any database. Forexample,anappmightcontainthefollowingcodetogenerateanHMACwithCommonCrypto: //Allocateabuffertoholdthedigestandperformthedigest. NSMutableData*actualData =[getData]; //getthekeyfromthekeychain NSData*key=[getKey]; NSMutableData*digestBuffer =[NSMutableDatadataWithLength:CC_SHA256_DIGEST_LENGTH]; CCHmac(kCCHmacAlgSHA256,[actualDatabytes],(CC_LONG)[keylength],[actualDatabytes],(CC_LONG)[actualDatalength],[digestBuffermutableBytes]); [actualDataappendData:digestBuffer]; Thisscriptperformsthefollowingsteps: 1. GetthedataasNSMutableData. 2. Getthedatakey(typicallyfromtheKeychain). 3. Calculatethehashvalue. 4. Appendthehashvaluetotheactualdata. 5. Storetheresultsofstep4. Afterthat,itmightbeverifyingtheHMACsbydoingthefollowing: NSData*hmac =[datasubdataWithRange:NSMakeRange(data.length -CC_SHA256_DIGEST_LENGTH,CC_SHA256_DIGEST_LENGTH)]; NSData*actualData =[datasubdataWithRange:NSMakeRange(0,(data.length -hmac.length))]; NSMutableData*digestBuffer =[NSMutableDatadataWithLength:CC_SHA256_DIGEST_LENGTH]; CCHmac(kCCHmacAlgSHA256,[actualDatabytes],(CC_LONG)[keylength],[actualDatabytes],(CC_LONG)[actualDatalength],[digestBuffermutableBytes]); return [hmacisEqual:digestBuffer]; 1. ExtractsthemessageandthehmacbytesasseparateNSData. 2. Repeatssteps1-3oftheprocedureforgeneratinganHMAContheNSData. 3. ComparestheextractedHMACbytestotheresultofstep1. Note: iftheappalsoencryptsfiles,makesurethatitencryptsandthencalculatestheHMACasdescribedinAuthenticated Encryption. Bypass: 1. Retrievethedatafromthedevice,asdescribedinthe“DeviceBinding”section. 2. Altertheretrieveddataandreturnittostorage. Reverse Engineering Tools Detection Thepresenceoftools, frameworksandappscommonlyusedbyreverseengineersmayindicateanattempttoreverse engineer the app. Some of these tools can only run on a jailbroken device, while others force the app into debugging modeordependonstartingabackgroundserviceonthemobilephone. Therefore,therearedifferentwaysthatanapp mayimplementtodetectareverseengineeringattackandreacttoit,e.g.byterminatingitself.", "metadata": {"doc_id": "OWASP_MASTG", "chunk_id": 164}}