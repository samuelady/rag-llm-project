{"text": "an example of a manifest file, including the package name (the convention is a reversed URL, but any string isacceptable). Italsoliststheappversion, relevantSDKs, requiredpermissions, exposedcontentproviders, broadcast receiversusedwithintentfiltersandadescriptionoftheappanditsactivities: <manifest package=\"com.owasp.myapplication\" android:versionCode=\"0.1\" > <uses-sdk android:minSdkVersion=\"12\" android:targetSdkVersion=\"22\" android:maxSdkVersion=\"25\" /> <uses-permission android:name=\"android.permission.INTERNET\" /> <provider android:name=\"com.owasp.myapplication.MyProvider\" android:exported=\"false\" /> <receiver android:name=\".MyReceiver\" > <intent-filter> <action android:name=\"com.owasp.myapplication.myaction\" /> </intent-filter> 98\\n</receiver> <application android:icon=\"@drawable/ic_launcher\" android:label=\"@string/app_name\" android:theme=\"@style/Theme.Material.Light\" > <activity android:name=\"com.owasp.myapplication.MainActivity\" > <intent-filter> <action android:name=\"android.intent.action.MAIN\" /> </intent-filter> </activity> </application> </manifest> ThefulllistofavailablemanifestoptionsisintheofficialAndroidManifestfiledocumentation. App Components Androidappsaremadeofseveralhigh-levelcomponents. Themaincomponentsare: • Activities • Fragments • Intents • Broadcastreceivers • Contentprovidersandservices All these elements are provided by the Android operating system, in the form of predefined classes available through APIs. Activities Activities make up the visible part of any app. There is one activity per screen, so an app with three different screens implementsthreedifferentactivities. ActivitiesaredeclaredbyextendingtheActivityclass. Theycontainalluserinterface elements: fragments,views,andlayouts. EachactivityneedstobedeclaredintheAndroidManifestwiththefollowingsyntax: <activity android:name=\"ActivityName\"> </activity> Activitiesnotdeclaredinthemanifestcan’tbedisplayed,andattemptingtolaunchthemwillraiseanexception. Likeapps,activitieshavetheirownlifecycleandneedtomonitorsystemchangestohandlethem. Activitiescanbein thefollowingstates: active,paused,stopped,andinactive. ThesestatesaremanagedbytheAndroidoperatingsystem. Accordingly,activitiescanimplementthefollowingeventmanagers: • onCreate • onSaveInstanceState • onStart • onResume • onRestoreInstanceState • onPause • onStop • onRestart • onDestroy Anappmaynotexplicitlyimplementalleventmanagers,inwhichcasedefaultactionsaretaken. Typically,atleastthe onCreatemanagerisoverriddenbytheappdevelopers. Thisishowmostuserinterfacecomponentsaredeclaredand initialized. onDestroymaybeoverriddenwhenresources(likenetworkconnectionsorconnectionstodatabases)must beexplicitlyreleasedorspecificactionsmustoccurwhentheappshutsdown. 99\\nFragments Afragmentrepresentsabehaviororaportionoftheuserinterfacewithintheactivity. FragmentswereintroducedAndroid withtheversionHoneycomb3.0(APIlevel11). Fragments are meant to encapsulate parts of the interface to facilitate re-usability and adaptation to different screen sizes. Fragmentsareautonomousentitiesinthattheyincludealltheirrequiredcomponents(theyhavetheirownlayout, buttons,etc.). However,theymustbeintegratedwithactivitiestobeuseful: fragmentscan’texistontheirown. They havetheirownlifecycle,whichistiedtothelifecycleoftheActivitiesthatimplementthem. Because fragments have their own life cycle, the Fragment class contains event managers that can be redefined and extended. TheseeventmanagersincludedonAttach,onCreate,onStart,onDestroyandonDetach. Severalothersexist; thereadershouldrefertotheAndroidFragmentspecificationformoredetails. FragmentscanbeeasilyimplementedbyextendingtheFragmentclassprovidedbyAndroid: ExampleinJava: public class MyFragment extends Fragment { ... } ExampleinKotlin: class MyFragment :Fragment(){ ... } Fragmentsdon’tneedtobedeclaredinmanifestfilesbecausetheydependonactivities. Tomanageitsfragments,anactivitycanuseaFragmentManager(FragmentManagerclass). Thisclassmakesiteasyto find,add,remove,andreplaceassociatedfragments. FragmentManagerscanbecreatedviathefollowing: ExampleinJava: FragmentManagerfm =getFragmentManager(); ExampleinKotlin: varfm=fragmentManager Fragments don’t necessarily have a user interface; they can be a convenient and efficient way to manage background operationspertainingtotheapp’suserinterface. Afragmentmaybedeclaredpersistentsothatifthesystempreserves itsstateevenifitsActivityisdestroyed. Content Providers Android uses SQLite to store data permanently: as with Linux, data is stored in files. SQLite is a light, efficient, open sourcerelationaldatastoragetechnologythatdoesnotrequiremuchprocessingpower,whichmakesitidealformobile use. An entire API with specific classes (Cursor, ContentValues, SQLiteOpenHelper, ContentProvider, ContentResolver, etc.) is available. SQLite is not run as a separate process; it is part of the app. By default, a database belonging to a givenappisaccessibletothisapponly. However,contentprovidersofferagreatmechanismforabstractingdatasources (includingdatabasesandflatfiles); theyalsoprovideastandardandefficientmechanismtosharedatabetweenapps, includingnativeapps. Tobeaccessibletootherapps,acontentproviderneedstobeexplicitlydeclaredinthemanifest file of the app that will share it. As long as content providers aren’t declared, they won’t be exported and can only be calledbytheappthatcreatesthem. ContentprovidersareimplementedthroughaURIaddressingscheme: theyallusethecontent://model. Regardlessof thetypeofsources(SQLitedatabase,flatfile,etc.),theaddressingschemeisalwaysthesame,therebyabstractingthe sources and offering the developer a unique scheme. Content providers offer all regular database operations: create, read,update,delete. Thatmeansthatanyappwithproperrightsinitsmanifestfilecanmanipulatethedatafromother apps. 100\\nServices ServicesareAndroidOScomponents(basedontheServiceclass)thatperformtasksinthebackground(dataprocessing, startingintents, andnotifications, etc.) withoutpresentingauserinterface. Servicesaremeanttorunprocesseslong- term. Theirsystemprioritiesarelowerthanthoseofactiveappsandhigherthanthoseofinactiveapps. Therefore,they arelesslikelytobekilledwhenthesystemneedsresources,andtheycanbeconfiguredtoautomaticallyrestartwhen enoughresourcesbecomeavailable. Thismakesservicesagreatcandidateforrunningbackgroundtasks. Pleasenote thatServices,likeActivities,areexecutedinthemainappthread. Aservicedoesnotcreateitsownthreadanddoesnot runinaseparateprocessunlessyouspecifyotherwise. Inter-Process Communication As we’ve already learned, every Android process has its own sandboxed address space. Inter-process communication facilitiesallowappstoexchangesignalsanddatasecurely. InsteadofrelyingonthedefaultLinuxIPCfacilities,Android’s IPC is based on Binder, a custom implementation of OpenBinder. Most Android system services and all high-level IPC servicesdependonBinder. ThetermBinderstandsforalotofdifferentthings,including: • BinderDriver: thekernel-leveldriver • BinderProtocol: low-levelioctl-basedprotocolusedtocommunicatewiththebinderdriver • IBinderInterface: awell-definedbehaviorthatBinderobjectsimplement • Binderobject: genericimplementationoftheIBinderinterface • Binderservice: implementationoftheBinderobject;forexample,locationservice,andsensorservice • Binderclient: anobjectusingtheBinderservice TheBinderframeworkincludesaclient-servercommunicationmodel. TouseIPC,appscallIPCmethodsinproxyobjects. TheproxyobjectstransparentlymarshallthecallparametersintoaparcelandsendatransactiontotheBinderserver, whichisimplementedasacharacterdriver(/dev/binder). Theserverholdsathreadpoolforhandlingincomingrequests anddeliversmessagestothedestinationobject. Fromtheperspectiveoftheclientapp,allofthisseemslikearegular methodcall,alltheheavyliftingisdonebytheBinderframework. • BinderOverview-Imagesource: AndroidBinderbyThorstenSchreiber Servicesthatallowotherapplicationstobindtothemarecalledboundservices. TheseservicesmustprovideanIBinder interface to clients. Developers use the Android Interface Descriptor Language (AIDL) to write interfaces for remote services. ServiceManagerisasystemdaemonthatmanagestheregistrationandlookupofsystemservices. Itmaintainsalistof name/Binderpairsforallregisteredservices. ServicesareaddedwithaddServiceandretrievedbynamewiththestatic getServicemethodinandroid.os.ServiceManager: ExampleinJava: 101\\npublic static IBinder getService(Stringname){ try{ IBinderservice =sCache.get(name); if(service !=null){ return service; }else { return getIServiceManager().getService(name);", "metadata": {"doc_id": "OWASP_MASTG", "chunk_id": 58}}