{"text": "1. InBurp,gototheProxytabandselecttheOptionstab. 241\\n2. GototheProxyListenerssection,highlightyourlistener,andclickEdit. 3. GototheCertificatetab,checkGenerateaCA-signedcertificatewithaspecifichostname,andtype inaninvalidhostname,e.g.,example.org. 4. Runyourapplication. Ifyou’reabletoseeHTTPStraffic,yourapplicationisacceptingallhostnames. Ifyou’restillnotabletoseeanydecryptedHTTPStraffic,yourapplicationmightbeimplementingcertificatepinning. Testing the Security Provider Platform: android MASVSV1: MSTG-NETWORK-6 MASVSV2: MASVS-NETWORK-1 Overview Static Analysis ApplicationsbasedontheAndroidSDKshoulddependonGooglePlayServices. Forexample,inthegradlebuildfile,youwill findcompile'com.google.android.gms:play-services-gcm:x.x.x'inthedependenciesblock. Youneedtomakesure thattheProviderInstallerclassiscalledwitheitherinstallIfNeededorinstallIfNeededAsync. ProviderInstaller needstobecalledbyacomponentoftheapplicationasearlyaspossible. Exceptionsthrownbythesemethodsshould becaughtandhandledcorrectly. Iftheapplicationcannotpatchitssecurityprovider,itcaneitherinformtheAPIofits lesssecurestateorrestrictuseractions(becauseallHTTPStrafficshouldbedeemedriskierinthissituation). Ifyouhaveaccesstothesourcecode, checkiftheapphandleanyexceptionsrelatedtothesecurityproviderupdates properly, and if it reports to the backend when the application is working with an unpatched security provider. The AndroidDeveloperdocumentationprovidesdifferentexamplesshowinghowtoupdatetheSecurityProvidertoprevent SSLexploits. Lastly,makesurethatNDK-basedapplicationsbindonlytoarecentandproperlypatchedlibrarythatprovidesSSL/TLS functionality. Dynamic Analysis Whenyouhavethesourcecode: • Runtheapplicationindebugmode,thencreateabreakpointwheretheappwillfirstcontacttheendpoint(s). • RightclickthehighlightedcodeandselectEvaluate Expression. • TypeSecurity.getProviders()andpressenter. • ChecktheprovidersandtrytofindGmsCore_OpenSSL,whichshouldbethenewtop-listedprovider. Whenyoudonothavethesourcecode: • UseXposedtohookintothejava.securitypackage,thenhookintojava.security.Securitywiththemethod getProviders(withnoarguments). ThereturnvaluewillbeanarrayofProvider. • DeterminewhetherthefirstproviderisGmsCore_OpenSSL. Testing Data Encryption on the Network Platform: android MASVSV1: MSTG-NETWORK-1 MASVSV2: MASVS-NETWORK-1 242\\nOverview Static Analysis Testing Network Requests over Secure Protocols First, you should identify all network requests in the source code and ensure that no plain HTTP URLs are used. Make surethatsensitiveinformationissentoversecurechannelsbyusingHttpsURLConnectionorSSLSocket(forsocket-level communicationusingTLS). Testing Network API Usage Next,evenwhenusingalow-levelAPIwhichissupposedtomakesecureconnections(suchasSSLSocket),beawarethat ithastobesecurelyimplemented. Forinstance,SSLSocketdoesn’tverifythehostname. UsegetDefaultHostnameV- erifiertoverifythehostname. TheAndroiddeveloperdocumentationincludesacodeexample. Testing for Cleartext Traffic Next,youshouldensurethattheappisnotallowingcleartextHTTPtraffic. SinceAndroid9(APIlevel28)cleartextHTTP trafficisblockedbydefault(thankstothedefaultNetworkSecurityConfiguration)buttherearemultiplewaysinwhich anapplicationcanstillsendit: • Setting the android:usesCleartextTraffic attribute of the <application> tag in the AndroidManifest.xml file. NotethatthisflagisignoredincasetheNetworkSecurityConfigurationisconfigured. • Configuring the Network Security Configuration to enable cleartext traffic by setting the cleartextTrafficPer- mittedattributetotrueon<domain-config>elements. • Usinglow-levelAPIs(e.g.Socket)tosetupacustomHTTPconnection. • Usingacross-platformframework(e.g.Flutter,Xamarin,...),asthesetypicallyhavetheirownimplementationsfor HTTPlibraries. Alloftheabovecasesmustbecarefullyanalyzedasawhole. Forexample,eveniftheappdoesnotpermitcleartexttraffic initsAndroidManifestorNetworkSecurityConfiguration,itmightactuallystillbesendingHTTPtraffic. Thatcouldbethe caseifit’susingalow-levelAPI(forwhichNetworkSecurityConfigurationisignored)orabadlyconfiguredcross-platform framework. Formoreinformationrefertothearticle“SecuritywithHTTPSandSSL”. Dynamic Analysis Intercept the tested app’s incoming and outgoing network traffic and make sure that this traffic is encrypted. You can interceptnetworktrafficinanyofthefollowingways: • CaptureallHTTP(S)andWebsockettrafficwithaninterceptionproxylikeOWASPZAPorBurpSuiteandmakesure allrequestsaremadeviaHTTPSinsteadofHTTP. • InterceptionproxieslikeBurpandOWASPZAPwillshowHTTP(S)trafficonly. Youcan,however,useaBurpplugin suchasBurp-non-HTTP-Extensionorthetoolmitm-relaytodecodeandvisualizecommunicationviaXMPPandother protocols. SomeapplicationsmaynotworkwithproxieslikeBurpandOWASPZAPbecauseofCertificatePinning. Insucha scenario,pleasecheck“TestingCustomCertificateStoresandCertificatePinning”. Formoredetailsreferto: • “InterceptingTrafficontheNetworkLayer”fromchapter“MobileAppNetworkCommunication” • “SettingupaNetworkTestingEnvironment”fromchapter“AndroidBasicSecurityTesting” Testing the TLS Settings 243\\nPlatform: android MASVSV1: MSTG-NETWORK-2 MASVSV2: MASVS-NETWORK-1 Overview Refertosection“VerifyingtheTLSSettings”inchapter“MobileAppNetworkCommunication”fordetails. 244\\nAndroid Platform APIs Overview App Permissions Androidassignsadistinctsystemidentity(LinuxuserIDandgroupID)toeveryinstalledapp. BecauseeachAndroidapp operatesinaprocesssandbox,appsmustexplicitlyrequestaccesstoresourcesanddatathatareoutsidetheirsandbox. They request this access by declaring the permissions they need to use system data and features. Depending on how sensitiveorcriticalthedataorfeatureis,theAndroidsystemwillgrantthepermissionautomaticallyorasktheuserto approvetherequest. To enhance user privacy and mitigate privacy risks, it is crucial for Android apps to minimize permission requests and only request access to sensitive information when absolutely necessary. The Android developer documentation offers valuableinsightsandbestpracticestohelpappsachievethesameleveloffunctionalitywithoutrequiringdirectaccess tosensitiveresources: • Minimizeyourpermissionrequests • Apppermissionsbestpractices • PermissionsandAPIsthatAccessSensitiveInformation Android permissions can be classified into distinct categories depending on the extent of restricted data access and permittedactionsthattheygranttoanapp. Thisclassificationincludestheso-called“ProtectionLevel”asshownonthe permissionsAPIreferencepageandAndroidManifest.xmlSourceDefinitions. • Install-time permissions: grant limited access to restricted data or let the app perform restricted actions that minimally affect the system or other apps. They are granted automatically at installation time (Android 6.0 (API level23)orhigher). – ProtectionLevel: normal. Grantsappsaccesstoisolatedapplication-levelfeatureswithminimalrisktoother apps,theuser,andthesystem. Example: android.permission.INTERNET – ProtectionLevel: signature. Grantedonlytoappssignedwiththesamecertificateastheoneusedtosign thedeclaringapp. Example: android.permission.ACCESS_MOCK_LOCATION – ProtectionLevel: systemOrSignature. Reservedforsystem-embeddedappsorthosesignedwiththesame certificate as the one used to sign the declaring app. Example: android.permission.ACCESS_DOWNLOAD_- MANAGER.Oldsynonymforsignature|privileged. DeprecatedinAPIlevel23. • Runtimepermissions: requirepromptingtheuseratruntimeforexplicitapproval. – Protection Level: dangerous. Grant additional access to restricted data or let the app perform restricted actionsthatmoresubstantiallyaffectthesystemandotherapps. • Specialpermissions: requiretheusertonavigatetoSettings>Apps>Specialappaccessandgiveexplicit consent. – ProtectionLevel: appop. Grantaccesstosystemresourcesthatareparticularlysensitivesuchasdisplaying anddrawingoverotherappsoraccessingallstoragedata. • Custompermissionsinordertosharetheirownresourcesandcapabilitieswithotherapps. – ProtectionLevel: normal,signatureordangerous. Independently from the assigned Protection Level, it is important to consider the risk that a permission might be pos- ingconsideringtheadditionalguardedcapabilities, thisisespeciallyimportantforpreloadedapps. Thefollowingtable presentsarepresentativesetofAndroidpermissionscategorizedbyassociatedriskasdefinedinthispaperwhichlever- agesthesetof(privileged)permissionsandentrancepointstoanapptoestimateitsattacksurface. RiskCategory Permissions ProtectionLevel ASTRONOMICAL android.permission.INSTALL_PACKAGES signature 245\\nRiskCategory Permissions ProtectionLevel CRITICAL android.permission.COPY_PROTECTED_DATA signature android.permission.WRITE_SECURE_SETTINGS signature android.permission.READ_FRAME_BUFFER signature android.permission.MANAGE_CA_CERTIFICATES signature android.permission.MANAGE_APP_OPS_MODES signature android.permission.GRANT_RUNTIME_PERMISSIONS signature android.permission.DUMP signature android.permission.CAMERA dangerous android.permission.SYSTEM_CAMERA systemOrSignature android.permission.MANAGE_PROFILE_AND_DEVICE_OWNERS signature android.permission.MOUNT_UNMOUNT_FILESYSTEMS signature HIGH android.permission.INSTALL_GRANT_RUNTIME_PERMISSIONS signature android.permission.READ_SMS dangerous android.permission.WRITE_SMS normal android.permission.RECEIVE_MMS dangerous android.permission.SEND_SMS_NO_CONFIRMATION signature android.permission.RECEIVE_SMS dangerous android.permission.READ_LOGS signature android.permission.READ_PRIVILEGED_PHONE_STATE signature android.permission.LOCATION_HARDWARE signature android.permission.ACCESS_FINE_LOCATION", "metadata": {"doc_id": "OWASP_MASTG", "chunk_id": 95}}