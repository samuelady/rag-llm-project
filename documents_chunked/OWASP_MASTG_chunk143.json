{"text": "Overview Static Analysis Therearevariouskeywordstolookfor: checkthelibrariesmentionedintheoverviewandstaticanalysisofthesection “VerifyingtheConfigurationofCryptographicStandardAlgorithms”forwhichkeywordsyoucanbestcheckonhowkeys arestored. Alwaysmakesurethat: • keysarenotsynchronizedoverdevicesifitisusedtoprotecthigh-riskdata. • keysarenotstoredwithoutadditionalprotection. • keysarenothardcoded. • keysarenotderivedfromstablefeaturesofthedevice. • keysarenothiddenbyuseoflowerlevellanguages(e.g.C/C++). • keysarenotimportedfromunsafelocations. Checkalsothelistofcommoncryptographicconfigurationissues. Mostoftherecommendationsforstaticanalysiscanalreadybefoundinchapter“TestingDataStorageforiOS”.Next,you canreaduponitatthefollowingpages: • AppleDeveloperDocumentation: Certificatesandkeys • AppleDeveloperDocumentation: Generatingnewkeys • AppleDeveloperDocumentation: Keygenerationattributes Dynamic Analysis Hookcryptographicmethodsandanalyzethekeysthatarebeingused. Monitorfilesystemaccesswhilecryptographic operationsarebeingperformedtoassesswherekeymaterialiswrittentoorreadfrom. 420\\nTesting Random Number Generation Platform: ios MASVSV1: MSTG-CRYPTO-6 MASVSV2: MASVS-CRYPTO-1 Overview Static Analysis InSwift,theSecRandomCopyBytesAPIisdefinedasfollows: funcSecRandomCopyBytes(_rnd:SecRandomRef?, _count:Int, _bytes:UnsafeMutablePointer<UInt8>)->Int32 TheObjective-Cversionis intSecRandomCopyBytes(SecRandomRefrnd,size_tcount,uint8_t *bytes); ThefollowingisanexampleoftheAPIsusage: intresult =SecRandomCopyBytes(kSecRandomDefault,16,randomBytes); Note: ifothermechanismsareusedforrandomnumbersinthecode, verifythattheseareeitherwrappersaroundthe APIsmentionedaboveorreviewthemfortheirsecure-randomness. Oftenthisistoohard,whichmeansyoucanbeststick withtheimplementationabove. Dynamic Analysis Ifyouwanttotestforrandomness,youcantrytocapturealargesetofnumbersandcheckwithBurp’ssequencerplugin toseehowgoodthequalityoftherandomnessis. 421\\niOS Local Authentication Overview During local authentication, an app authenticates the user against credentials stored locally on the device. In other words, the user “unlocks” the app or some inner layer of functionality by providing a valid PIN, password or biometric characteristics such as face or fingerprint, which is verified by referencing local data. Generally, this is done so that userscanmoreconvenientlyresumeanexistingsessionwitharemoteserviceorasameansofstep-upauthentication toprotectsomecriticalfunction. Asstatedbeforeinchapter“MobileAppAuthenticationArchitectures”: Thetestershouldbeawarethatlocalauthentica- tionshouldalwaysbeenforcedataremoteendpointorbasedonacryptographicprimitive. Attackerscaneasilybypass localauthenticationifnodatareturnsfromtheauthenticationprocess. A variety of methods are available for integrating local authentication into apps. The Local Authentication framework provides a set of APIs for developers to extend an authentication dialog to a user. In the context of connecting to a remoteservice,itispossible(andrecommended)toleveragethekeychainforimplementinglocalauthentication. FingerprintauthenticationoniOSisknownasTouchID.ThefingerprintIDsensorisoperatedbytheSecureEnclavesecurity coprocessoranddoesnotexposefingerprintdatatoanyotherpartsofthesystem. NexttoTouchID,Appleintroduced FaceID:whichallowsauthenticationbasedonfacialrecognition. BothusesimilarAPIsonanapplicationlevel,theactual methodofstoringthedataandretrievingthedata(e.g.facialdataorfingerprintrelateddataisdifferent). DevelopershavetwooptionsforincorporatingTouchID/FaceIDauthentication: • LocalAuthentication.frameworkisahigh-levelAPIthatcanbeusedtoauthenticatetheuserviaTouchID.The appcan’taccessanydataassociatedwiththeenrolledfingerprintandisnotifiedonlywhetherauthenticationwas successful. • Security.frameworkisalowerlevelAPItoaccesskeychainservices. Thisisasecureoptionifyourappneedsto protect some secret data with biometric authentication, since the access control is managed on a system-level and can not easily be bypassed. Security.framework has a C API, but there are several open source wrap- pers available, making access to the keychain as simple as to NSUserDefaults. Security.framework underlies LocalAuthentication.framework;Applerecommendstodefaulttohigher-levelAPIswheneverpossible. Please be aware that using either the LocalAuthentication.framework or the Security.framework, will be a control thatcanbebypassedbyanattackerasitdoesonlyreturnabooleanandnodatatoproceedwith. SeeDon’ttouchme thatway,byDavidLindneretalformoredetails. Local Authentication Framework TheLocalAuthenticationframeworkprovidesfacilitiesforrequestingapassphraseorTouchIDauthenticationfromusers. DeveloperscandisplayandutilizeanauthenticationpromptbyutilizingthefunctionevaluatePolicyoftheLAContext class. Twoavailablepoliciesdefineacceptableformsofauthentication: • deviceOwnerAuthentication(Swift)or LAPolicyDeviceOwnerAuthentication(Objective-C):Whenavailable, the userispromptedtoperformTouchIDauthentication. IfTouchIDisnotactivated,thedevicepasscodeisrequested instead. Ifthedevicepasscodeisnotenabled,policyevaluationfails. • deviceOwnerAuthenticationWithBiometrics (Swift) or LAPolicyDeviceOwnerAuthenticationWithBiomet- rics(Objective-C):AuthenticationisrestrictedtobiometricswheretheuserispromptedforTouchID. TheevaluatePolicyfunctionreturnsabooleanvalueindicatingwhethertheuserhasauthenticatedsuccessfully. TheAppleDeveloperwebsiteofferscodesamplesforbothSwiftandObjective-C.AtypicalimplementationinSwiftlooks asfollows. letcontext =LAContext() varerror:NSError? guard context.canEvaluatePolicy(.deviceOwnerAuthentication,error:&error)else { //Couldnotevaluatepolicy;lookaterrorandpresentanappropriatemessagetouser 422\\n} context.evaluatePolicy(.deviceOwnerAuthentication,localizedReason:\"Please,passauthorizationtoenterthisarea\"){success,evaluationError in guard success else { //Userdidnotauthenticatesuccessfully,lookatevaluationErrorandtakeappropriateaction } //Userauthenticatedsuccessfully,takeappropriateaction } Using Keychain Services for Local Authentication TheiOSkeychainAPIscan(andshould)beusedtoimplementlocalauthentication. Duringthisprocess,theappstores either a secret authentication token or another piece of secret data identifying the user in the keychain. In order to authenticatetoaremoteservice,theusermustunlockthekeychainusingtheirpassphraseorfingerprinttoobtainthe secretdata. ThekeychainallowssavingitemswiththespecialSecAccessControlattribute,whichwillallowaccesstotheitemfrom thekeychainonlyaftertheuserhaspassedTouchIDauthentication(orpasscode,ifsuchafallbackisallowedbyattribute parameters). In the following example we will save the string “test_strong_password” to the keychain. The string can be ac- cessed only on the current device while the passcode is set (kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly parameter) and after Touch ID authentication for the currently enrolled fingers only (SecAccessControlCreateFlags. biometryCurrentSetparameter): Swift //1.CreatetheAccessControlobjectthatwillrepresentauthenticationsettings varerror:Unmanaged<CFError>? guard letaccessControl =SecAccessControlCreateWithFlags(kCFAllocatorDefault, kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly, SecAccessControlCreateFlags.biometryCurrentSet, &error)else { //failedtocreateAccessControlobject return } //2.Createthekeychainservicesquery.PayattentionthatkSecAttrAccessControlismutuallyexclusivewithkSecAttrAccessibleattribute varquery:[String:Any]=[:] query[kSecClass asString]=kSecClassGenericPassword query[kSecAttrLabel asString]=\"com.me.myapp.password\" asCFString query[kSecAttrAccount asString]=\"OWASPAccount\" asCFString query[kSecValueData asString]=\"test_strong_password\".data(using:.utf8)!as CFData query[kSecAttrAccessControl asString]=accessControl //3.Savetheitem letstatus =SecItemAdd(query asCFDictionary,nil) ifstatus ==noErr { //successfullysaved }else { //errorwhilesaving } //4.Nowwecanrequestthesaveditemfromthekeychain.Keychainserviceswillpresenttheauthenticationdialogto theuserandreturndataornildepending ↪ onwhetherasuitablefingerprintwasprovidedornot. //5.Createthequery varquery =[String:Any]() query[kSecClass asString]=kSecClassGenericPassword query[kSecReturnData asString]=kCFBooleanTrue query[kSecAttrAccount asString]=\"MyName\" asCFString query[kSecAttrLabel asString]=\"com.me.myapp.password\" asCFString query[kSecUseOperationPrompt asString]=\"Please,passauthorisationtoenterthisarea\" asCFString //6.Gettheitem varqueryResult:AnyObject? letstatus =withUnsafeMutablePointer(to:&queryResult){ SecItemCopyMatching(query asCFDictionary,UnsafeMutablePointer($0)) } 423\\nifstatus ==noErr { letpassword =String(data:queryResult as!Data,encoding:.utf8)! //successfullyreceivedpassword }else { //authorizationnotpassed } Objective-C //1.CreatetheAccessControlobjectthatwillrepresentauthenticationsettings CFErrorRef *err=nil; SecAccessControlRefsacRef =SecAccessControlCreateWithFlags(kCFAllocatorDefault, kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly, kSecAccessControlUserPresence, err); //2.Createthekeychainservicesquery.PayattentionthatkSecAttrAccessControlismutuallyexclusivewithkSecAttrAccessibleattribute NSDictionary*query =@{ (__bridgeid)kSecClass:(__bridgeid)kSecClassGenericPassword, (__bridgeid)kSecAttrLabel:@\"com.me.myapp.password\", (__bridgeid)kSecAttrAccount:@\"OWASPAccount\", (__bridgeid)kSecValueData:[@\"test_strong_password\" dataUsingEncoding:NSUTF8StringEncoding], (__bridgeid)kSecAttrAccessControl:(__bridge_transferid)sacRef }; //3.Savetheitem OSStatusstatus =SecItemAdd((__bridgeCFDictionaryRef)query,nil); if(status ==noErr){ //successfullysaved }else { //errorwhilesaving } //4.Nowwecanrequestthesaveditemfromthekeychain.Keychainserviceswillpresenttheauthenticationdialogto theuserandreturndataornildepending ↪ onwhetherasuitablefingerprintwasprovidedornot. //5.Createthequery NSDictionary *query =@{(__bridgeid)kSecClass:(__bridgeid)kSecClassGenericPassword, (__bridgeid)kSecReturnData:@YES, (__bridgeid)kSecAttrAccount:@\"MyName1\", (__bridgeid)kSecAttrLabel:@\"com.me.myapp.password\", (__bridgeid)kSecUseOperationPrompt:@\"Please,passauthorisationtoenterthisarea\" }; //6.Gettheitem CFTypeRefqueryResult =NULL; OSStatusstatus", "metadata": {"doc_id": "OWASP_MASTG", "chunk_id": 143}}