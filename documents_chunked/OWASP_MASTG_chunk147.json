{"text": "Pleaseuse thisinformationasareferencewheninspectingthecode. Testing for Cleartext Traffic EnsurethattheappisnotallowingcleartextHTTPtraffic. SinceiOS9.0cleartextHTTPtrafficisblockedbydefault(due toAppTransportSecurity(ATS))buttherearemultiplewaysinwhichanapplicationcanstillsendit: • Configuring ATS to enable cleartext traffic by setting the NSAllowsArbitraryLoads attribute to true (or YES) on NSAppTransportSecurityintheapp’sInfo.plist. • RetrievetheInfo.plist • CheckthatNSAllowsArbitraryLoadsisnotsettotruegloballyofforanydomain. • If the application opens third party web sites in WebViews, then from iOS 10 onwards NSAllowsArbitraryLoad- sInWebContentcanbeusedtodisableATSrestrictionsforthecontentloadedinwebviews. Apple warns: Disabling ATS means that unsecured HTTP connections are allowed. HTTPS connections are also allowed,andarestillsubjecttodefaultservertrustevaluation. However,extendedsecuritychecks—likerequiring aminimumTransportLayerSecurity(TLS)protocolversion—aredisabled. WithoutATS,you’realsofreetoloosen thedefaultservertrustrequirements,asdescribedin“PerformingManualServerTrustAuthentication”. ThefollowingsnippetshowsavulnerableexampleofanappdisablingATSrestrictionsglobally. <key>NSAppTransportSecurity</key> <dict> <key>NSAllowsArbitraryLoads</key> <true/> </dict> 434\\nATS should be examined taking the application’s context into consideration. The application may have to define ATS exceptionstofulfillitsintendedpurpose. Forexample,theFirefoxiOSapplicationhasATSdisabledglobally. Thisexception isacceptablebecauseotherwisetheapplicationwouldnotbeabletoconnecttoanyHTTPwebsitethatdoesnothaveall theATSrequirements. Insomecases,appsmightdisableATSgloballybutenableitforcertaindomainstoe.g.securely loadmetadataorstillallowsecurelogin. ATSshouldincludeajustificationstringforthis(e.g.“Theappmustconnecttoaservermanagedbyanotherentitythat doesn’tsupportsecureconnections.”). Dynamic Analysis Intercept the tested app’s incoming and outgoing network traffic and make sure that this traffic is encrypted. You can interceptnetworktrafficinanyofthefollowingways: • CaptureallHTTP(S)andWebsockettrafficwithaninterceptionproxylikeOWASPZAPorBurpSuiteandmakesure allrequestsaremadeviaHTTPSinsteadofHTTP. • InterceptionproxieslikeBurpandOWASPZAPwillshowHTTP(S)trafficonly. Youcan,however,useaBurpplugin suchasBurp-non-HTTP-Extensionorthetoolmitm-relaytodecodeandvisualizecommunicationviaXMPPandother protocols. SomeapplicationsmaynotworkwithproxieslikeBurpandOWASPZAPbecauseofCertificatePinning. Insucha scenario,pleasecheck“TestingCustomCertificateStoresandCertificatePinning”. Formoredetailsreferto: • “InterceptingTrafficontheNetworkLayer”fromchapter“TestingNetworkCommunication” • “SettingupaNetworkTestingEnvironment”fromchapteriOSBasicSecurityTesting 435\\niOS Platform APIs Overview Enforced Updating Enforcedupdatingcanbehelpfulwhenitcomestopublickeypinning(seetheTestingNetworkcommunicationformore details) when a pin has to be refreshed due to a certificate/public key rotation. Additionally, vulnerabilities are easily patchedbymeansofforcedupdates. ThechallengewithiOShowever,isthatAppledoesnotprovideanyAPIsyettoautomatethisprocess,instead,developers will have to create their own mechanism, such as described at various blogs which boil down to looking up properties of the app using http://itunes.apple.com/lookup\\?id\\<BundleId> or third party libraries, such as Siren and react- native-appstore-version-checker. Most of these implementations will require a certain given version offered by an API or just “latest in the appstore”, which means users can be frustrated with having to update the app, even though no business/securityneedforanupdateistrulythere. Please note that newer versions of an application will not fix security issues that are living in the backends to which the app communicates. Allowing an app not to communicate with it might not be enough. Having proper API-lifecycle managementiskeyhere. Similarly,whenauserisnotforcedtoupdate,donotforgettotestolderversionsofyourapp againstyourAPIand/oruseproperAPIversioning. Object Persistence ThereareseveralwaystopersistanobjectoniOS: Object Encoding iOScomeswithtwoprotocolsforobjectencodinganddecodingforObjective-CorNSObjects: NSCodingandNSSecure- Coding. When a class conforms to either of the protocols, the data is serialized to NSData: a wrapper for byte buffers. NotethatDatainSwiftisthesameasNSDataoritsmutablecounterpart: NSMutableData. TheNSCodingprotocoldeclares the two methods that must be implemented in order to encode/decode its instance-variables. A class using NSCoding needstoimplementNSObjectorbeannotatedasan@objcclass. TheNSCodingprotocolrequirestoimplementencode andinitasshownbelow. class CustomPoint:NSObject,NSCoding { //requiredbyNSCoding: func encode(with aCoder:NSCoder){ aCoder.encode(x,forKey:\"x\") aCoder.encode(name,forKey:\"name\") } varx:Double =0.0 varname:String =\"\" init(x:Double,name:String){ self.x=x self.name =name } //requiredbyNSCoding:initializemembersusingadecoder. required convenience init?(coderaDecoder:NSCoder){ guard letname =aDecoder.decodeObject(forKey:\"name\")as?String else {return nil} self.init(x:aDecoder.decodeDouble(forKey:\"x\"), name:name) } //getters/setters/etc. } TheissuewithNSCodingisthattheobjectisoftenalreadyconstructedandinsertedbeforeyoucanevaluatetheclass- type. Thisallowsanattackertoeasilyinjectallsortsofdata. Therefore,theNSSecureCodingprotocolhasbeenintroduced. WhenconformingtoNSSecureCodingyouneedtoinclude: 436\\nstatic varsupportsSecureCoding:Bool { return true } wheninit(coder:) ispartoftheclass. Next,whendecodingtheobject,acheckshouldbemade,e.g.: letobj=decoder.decodeObject(of:MyClass.self,forKey:\"myKey\") The conformance to NSSecureCoding ensures that objects being instantiated are indeed the ones that were expected. However,therearenoadditionalintegritychecksdoneoverthedataandthedataisnotencrypted. Therefore,anysecret dataneedsadditionalencryptionanddataofwhichtheintegritymustbeprotected,shouldgetanadditionalHMAC. Note,whenNSData(Objective-C)orthekeywordlet(Swift)isused: thenthedataisimmutableinmemoryandcannot beeasilyremoved. Object Archiving with NSKeyedArchiver NSKeyedArchiverisaconcretesubclassofNSCoderandprovidesawaytoencodeobjectsandstoretheminafile. The NSKeyedUnarchiverdecodesthedataandrecreatestheoriginaldata. Let’staketheexampleoftheNSCodingsection andnowarchiveandunarchivethem: //archiving: NSKeyedArchiver.archiveRootObject(customPoint,toFile:\"/path/to/archive\") //unarchiving: guard letcustomPoint =NSKeyedUnarchiver.unarchiveObjectWithFile(\"/path/to/archive\")as? CustomPoint else {return nil} Whendecodingakeyedarchive,becausevaluesarerequestedbyname,valuescanbedecodedoutofsequenceornotat all. Keyedarchives,therefore,providebettersupportforforwardandbackwardcompatibility. Thismeansthatanarchive ondiskcouldactuallycontainadditionaldatawhichisnotdetectedbytheprogram,unlessthekeyforthatgivendatais providedatalaterstage. Note that additional protection needs to be in place to secure the file in case of confidential data, as the data is not encryptedwithinthefile. Seethechapter“DataStorageoniOS”formoredetails. Codable WithSwift 4, the Codable type alias arrived: it is a combination of theDecodable and Encodable protocols. A String, Int,Double,Date,DataandURLareCodablebynature: meaningtheycaneasilybeencodedanddecodedwithoutany additionalwork. Let’stakethefollowingexample: struct CustomPointStruct:Codable { varx:Double varname:String } By adding Codable to the inheritance list for the CustomPointStruct in the example, the methods init(from:) and encode(to:) areautomaticallysupported. ForemoredetailsabouttheworkingsofCodablechecktheAppleDeveloper", "metadata": {"doc_id": "OWASP_MASTG", "chunk_id": 147}}