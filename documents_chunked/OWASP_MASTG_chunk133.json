{"text": "Italsoshowswhichofthemarecurrentlyrunning. Takeanoteofthe“Identifier”(bundleidentifier)andthePIDifanyas you’llneedthemafterwards. YoucanalsodirectlyopenGrapefruitandafterselectingyouriOSdeviceyou’llgetthelistofinstalledapps. Debugging Platform: ios ComingfromaLinuxbackgroundyou’dexpecttheptracesystemcalltobeaspowerfulasyou’reusedtobut,forsome reason, Apple decided to leave it incomplete. iOS debuggers such as LLDB use it for attaching, stepping or continuing theprocessbuttheycannotuseittoreadorwritememory(allPT_READ_*andPT_WRITE*requestsaremissing). Instead, they have to obtain a so-called Mach task port (by calling task_for_pid with the target process ID) and then use the MachIPCinterfaceAPIfunctionstoperformactionssuchassuspendingthetargetprocessandreading/writingregister states(thread_get_state/thread_set_state)andvirtualmemory(mach_vm_read/mach_vm_write). 384\\nFormoreinformationyoucanrefertotheLLVMprojectinGitHubwhichcontainsthesourcecodeforLLDBaswell asChapter5and13from“MacOSXandiOSInternals: TotheApple’sCore”[#levin]andChapter4“Tracingand Debugging”from“TheMacHacker’sHandbook”[#miller]. Debugging with LLDB ThedefaultdebugserverexecutablethatXcodeinstallscan’tbeusedtoattachtoarbitraryprocesses(itisusuallyused onlyfordebuggingself-developedappsdeployedwithXcode). Toenabledebuggingofthird-partyapps,thetask_for_- pid-allowentitlementmustbeaddedtothedebugserverexecutablesothatthedebuggerprocesscancalltask_for_pid toobtainthetargetMachtaskportasseenbefore. Aneasywaytodothisistoaddtheentitlementtothedebugserver binaryshippedwithXcode. Toobtaintheexecutable,mountthefollowingDMGimage: /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/DeviceSupport/<target-iOS-version>/DeveloperDiskImage.dmg You’llfindthedebugserverexecutableinthe/usr/bin/directoryonthemountedvolume. Copyittoatemporarydirec- tory,thencreateafilecalledentitlements.plistwiththefollowingcontent: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <!DOCTYPE plist PUBLIC\"-//Apple//DTDPLIST1.0//EN\"\"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"> <plist version=\"1.0\"> <dict> <key>com.apple.springboard.debugapplications</key> <true/> <key>run-unsigned-code</key> <true/> <key>get-task-allow</key> <true/> <key>task_for_pid-allow</key> <true/> </dict> </plist> Applytheentitlementwithcodesign: codesign -s---entitlements entitlements.plist -fdebugserver Copythemodifiedbinarytoanydirectoryonthetestdevice. Thefollowingexamplesuseusbmuxdtoforwardalocalport throughUSB. iproxy222222 scp-P2222debugserverroot@localhost:/tmp/ Note: OniOS12andhigher,usethefollowingproceduretosignthedebugserverbinaryobtainedfromtheXCodeimage. 1) Copythedebugserverbinarytothedeviceviascp,forexample,inthe/tmpfolder. 2) ConnecttothedeviceviaSSHandcreatethefile,namedentitlements.xml,withthefollowingcontent: <!DOCTYPE plist PUBLIC\"-//Apple//DTD PLIST1.0//ENhttp://www.apple.com/DTDs/PropertyList-1.0.dtd\"> <plist version=\"1.0\"> <dict> <key>platform-application</key> <true/> <key>com.apple.private.security.no-container</key> <true/> <key>com.apple.private.skip-library-validation</key> <true/> <key>com.apple.backboardd.debugapplications</key> <true/> <key>com.apple.backboardd.launchapplications</key> <true/> <key>com.apple.diagnosticd.diagnostic</key> <true/> <key>com.apple.frontboard.debugapplications</key> <true/> <key>com.apple.frontboard.launchapplications</key> <true/> <key>com.apple.security.network.client</key> 385\\n<true/> <key>com.apple.security.network.server</key> <true/> <key>com.apple.springboard.debugapplications</key> <true/> <key>com.apple.system-task-ports</key> <true/> <key>get-task-allow</key> <true/> <key>run-unsigned-code</key> <true/> <key>task_for_pid-allow</key> <true/> </dict> </plist> 3) Typethefollowingcommandtosignthedebugserverbinary: ldid -Sentitlements.xml debugserver 4) Verifythatthedebugserverbinarycanbeexecutedviathefollowingcommand: ./debugserver Youcannowattachdebugservertoanyprocessrunningonthedevice. VP-iPhone-18:/tmproot#./debugserver *:1234 -a2670 debugserver-@(#)PROGRAM:debugserver PROJECT:debugserver-320.2.89 forarmv7. Attachingtoprocess2670... Withthefollowingcommandyoucanlaunchanapplicationviadebugserverrunningonthetargetdevice: debugserver -xbackboard *:1234/Applications/MobileSMS.app/MobileSMS Attachtoanalreadyrunningapplication: debugserver *:1234 -a\"MobileSMS\" YoumayconnectnowtotheiOSdevicefromyourhostcomputer: (lldb)processconnectconnect://<ip-of-ios-device>:1234 Typingimage listgivesalistofmainexecutableandalldependentlibraries. Debugging Release Apps In the previous section we learned about how to setup a debugging environment on an iOS device using LLDB. In this sectionwewillusethisinformationandlearnhowtodebuga3rdpartyreleaseapplication. Wewillcontinueusingthe UnCrackableAppforiOSLevel1andsolveitusingadebugger. Incontrast to a debugbuild, thecode compiled for a releasebuild is optimized toachieve maximum performanceand minimumbinarybuildsize. Asageneralbestpractice,mostofthedebugsymbolsarestrippedforareleasebuild,adding alayerofcomplexitywhenreverseengineeringanddebuggingthebinaries. Duetotheabsenceofthedebugsymbols,symbolnamesaremissingfromthebacktraceoutputsandsettingbreakpoints by simply using function names is not possible. Fortunately, debuggers also support setting breakpoints directly on memoryaddresses. Furtherinthissectionwewilllearnhowtodosoandeventuallysolvethecrackmechallenge. Somegroundworkisneededbeforesettingabreakpointusingmemoryaddresses. Itrequiresdeterminingtwooffsets: 1. Breakpointoffset: Theaddressoffsetofthecodewherewewanttosetabreakpoint. Thisaddressisobtainedby performingstaticanalysisofthecodeinadisassemblerlikeGhidra. 2. ASLRshiftoffset: TheASLRshiftoffsetforthecurrentprocess. SinceASLRoffsetisrandomlygeneratedonevery newinstanceofanapplication,thishastobeobtainedforeverydebuggingsessionindividually. Thisisdetermined usingthedebuggeritself. 386\\niOSisamodernoperatingsystemwithmultipletechniquesimplementedtomitigatecodeexecutionattacks, one such technique being Address Space Randomization Layout (ASLR). On every new execution of an application, a randomASLRshiftoffsetisgenerated,andvariousprocess’datastructuresareshiftedbythisoffset. Thefinalbreakpointaddresstobeusedinthedebuggeristhesumoftheabovetwoaddresses(Breakpointoffset+ASLR shiftoffset). Thisapproachassumesthattheimagebaseaddress(discussedshortly)usedbythedisassemblerandiOS isthesame,whichistruemostofthetime. WhenabinaryisopenedinadisassemblerlikeGhidra,itloadsabinarybyemulatingtherespectiveoperatingsystem’s loader. Theaddressatwhichthebinaryisloadediscalledimagebaseaddress. Allthecodeandsymbolsinsidethisbinary canbeaddressedusingaconstantaddressoffsetfromthisimagebaseaddress. InGhidra,theimagebaseaddresscan beobtainedbydeterminingtheaddressofthestartofaMach-Ofile. Inthiscase,itis0x100000000. FromourpreviousanalysisoftheUnCrackableLevel1applicationin“Manual(Reversed)CodeReview”section,thevalue ofthehiddenstringisstoredinalabelwiththehiddenflagset. Inthedisassembly,thetextvalueofthislabelisstored inregisterX21,storedviamovfromX0,atoffset0x100004520. Thisisourbreakpointoffset. Forthesecondaddress,weneedtodeterminetheASLRshiftoffsetforagivenprocess. TheASLRoffsetcanbedetermined byusingtheLLDBcommandimage list -o -f. Theoutputisshowninthescreenshotbelow. Intheoutput,thefirstcolumncontainsthesequencenumberoftheimage([X]),thesecondcolumncontainstherandomly generatedASLRoffset,while3rdcolumncontainsthefullpathoftheimageandtowardstheend,contentinthebracket shows the image base address after adding ASLR offset to the original image base address (0x100000000 + 0x70000 = 0x100070000). You will notice the image base address of 0x100000000 is same as in Ghidra. Now, to obtain the 387\\neffectivememoryaddressforacodelocationweonlyneedtoaddASLRoffsettotheaddressidentifiedinGhidra. The effectiveaddresstosetthebreakpointwillbe0x100004520+0x70000=0x100074520. Thebreakpointcanbesetusing commandb 0x100074520. Intheaboveoutput,youmayalsonoticethatmanyofthepathslistedasimagesdonotpointtothefilesystemonthe iOSdevice. Instead,theypointtoacertainlocationonthehostcomputeronwhichLLDBisrunning. Theseimages aresystemlibrariesforwhichdebugsymbolsareavailableonthehostcomputertoaidinapplicationdevelopment and debugging (as part of the Xcode iOS SDK). Therefore, you may set breakpoints to these libraries directly by usingfunctionnames. Afterputtingthebreakpointandrunningtheapp, theexecutionwillbehaltedoncethebreakpointishit. Nowyoucan access and explore the current state of the process. In this case, you know from the previous static analysis that the registerX0containsthehiddenstring,thuslet’sexploreit. InLLDByoucanprintObjective-Cobjectsusingthepo(print object)command. Voila, the crackme can be easily solved aided by static analysis and a debugger. There are plethora of features im- plemented in LLDB, including changing the value of the registers, changing values in the process memory and even automatingtasksusingPythonscripts. Officially Apple recommends use of LLDB for debugging purposes, but GDB can be also used on iOS. The techniques discussedaboveareapplicablewhiledebuggingusingGDBaswell,providedtheLLDBspecificcommandsarechanged toGDBcommands. Get Open Files Platform: ios lsofisapowerfulcommand,andprovidesaplethoraofinformationaboutarunningprocess. Itcanprovidealistofall openfiles, including a stream, a networkfile ora regularfile. Wheninvoking thelsof commandwithout anyoption it will list all open files belonging to all active processes on the system, while when invoking with the flags -c <process name>or-p <pid>,itreturnsthelistofopenfilesforthespecifiedprocess. Themanpageshowsvariousotheroptionsin detail. UsinglsofforaniOSapplicationrunningwithPID2828,listvariousopenfilesasshownbelow. iPhone:~root#lsof -p2828 COMMAND", "metadata": {"doc_id": "OWASP_MASTG", "chunk_id": 133}}