{"text": "provides several tools for analyzing the memory dump. For example, the Histogram provides an estimate of the numberofobjectsthathavebeencapturedfromagiventype,andtheThreadOverviewshowsprocesses’threadsand stack frames. The Dominator Tree provides information about keep-alive dependencies between objects. You can use regularexpressionstofiltertheresultsthesetoolsprovide. ObjectQueryLanguagestudioisaMATfeaturethatallowsyoutoqueryobjectsfromthememorydumpwithanSQL-like language. ThetoolallowsyoutotransformsimpleobjectsbyinvokingJavamethodsonthem,anditprovidesanAPIfor buildingsophisticatedtoolsontopoftheMAT. SELECT *FROM java.lang.String Intheexampleabove,allStringobjectspresentinthememorydumpwillbeselected. Theresultswillincludetheobject’s class,memoryaddress,value,andretaincount. Tofilterthisinformationandseeonlythevalueofeachstring,usethe followingcode: SELECT toString(object)FROM java.lang.String object Or SELECT object.toString() FROM java.lang.String object SQLsupportsprimitivedatatypesaswell, soyoucandosomethinglikethefollowingtoaccessthecontentofallchar arrays: SELECT toString(arr) FROM char[]arr Don’tbesurprisedifyougetresultsthataresimilartothepreviousresults; afterall,StringandotherJavadatatypes arejustwrappersaroundprimitivedatatypes. Nowlet’sfiltertheresults. Thefollowingsamplecodewillselectallbyte arraysthatcontaintheASN.1OIDofanRSAkey. Thisdoesn’timplythatagivenbytearrayactuallycontainsanRSA(the samebytesequencemaybepartofsomethingelse),butthisisprobable. SELECT *FROM byte[]b WHERE toString(b).matches(\".*1\\.2\\.840\\.113549\\.1\\.1\\.1.*\") Finally,youdon’thavetoselectwholeobjects. ConsideranSQLanalogy: classesaretables,objectsarerows,andfields arecolumns. Ifyouwanttofindallobjectsthathavea“password”field,youcandosomethinglikethefollowing: SELECT password FROM \".*\" WHERE (null !=password) Duringyouranalysis,searchfor: • Indicativefieldnames: “password”,“pass”,“pin”,“secret”,“private”,etc. • Indicativepatterns(e.g.,RSAfootprints)instrings,chararrays,bytearrays,etc. • Knownsecrets(e.g.,acreditcardnumberthatyou’veenteredoranauthenticationtokenprovidedbythebackend) • etc. Repeatingtestsandmemorydumpswillhelpyouobtainstatisticsaboutthelengthofdataexposure. Furthermore,observ- ingthewayaparticularmemorysegment(e.g.,abytearray)changesmayleadyoutosomeotherwiseunrecognizable sensitivedata(moreonthisinthe“Remediation”sectionbelow). Determining Whether the Keyboard Cache Is Disabled for Text Input Fields 214\\nPlatform: android MASVSV1: MSTG-STORAGE-5 MASVSV2: MASVS-STORAGE-2 Overview Static Analysis In the layout definition of an activity, you can define TextViews that have XML attributes. If the XML attribute an- droid:inputTypeisgiventhevaluetextNoSuggestions,thekeyboardcachewillnotbeshownwhentheinputfieldis selected. Theuserwillhavetotypeeverythingmanually. <EditText android:id=\"@+id/KeyBoardCache\" android:inputType=\"textNoSuggestions\" /> The code for all input fields that take sensitive information should include this XML attribute to disable the keyboard suggestions. Alternatively,thedevelopercanusethefollowingconstants: XMLandroid:inputType CodeInputType APIlevel textPassword TYPE_TEXT_VARIATION_PASSWORD 3 textVisiblePassword TYPE_TEXT_VARIATION_VISIBLE_PASSWORD 3 numberPassword TYPE_NUMBER_VARIATION_PASSWORD 11 textWebPassword TYPE_TEXT_VARIATION_WEB_PASSWORD 11 Check the application code to verify that none of the input types are being overwritten. For example, by doing findViewById(R.id.KeyBoardCache).setInputType(InputType.TYPE_CLASS_TEXT) the input type of the input field KeyBoardCacheissettotextreenablingthekeyboardcache. Finally,checktheminimumrequiredSDKversionintheAndroidManifest(android:minSdkVersion)sinceitmustsupport theusedconstants(forexample,AndroidSDKversion11isrequiredfortextWebPassword). Otherwise,thecompiledapp wouldnothonortheusedinputtypeconstantsallowingkeyboardcaching. Dynamic Analysis Starttheappandclickintheinputfieldsthattakesensitivedata. Ifstringsaresuggested,thekeyboardcachehasnot beendisabledforthesefields. Testing Logs for Sensitive Data Platform: android MASVSV1: MSTG-STORAGE-3 MASVSV2: MASVS-STORAGE-2 Overview Thistestcasefocusesonidentifyinganysensitiveapplicationdatawithinbothsystemandapplicationlogs. Thefollowing checksshouldbeperformed: 215\\n• Analyzesourcecodeforloggingrelatedcode. • Checkapplicationdatadirectoryforlogfiles. • Gathersystemmessagesandlogsandanalyzeforanysensitivedata. Asageneralrecommendationtoavoidpotentialsensitiveapplicationdataleakage,loggingstatementsshouldberemoved fromproductionreleasesunlessdeemednecessarytotheapplicationorexplicitlyidentifiedassafe,e.g.asaresultofa securityaudit. Static Analysis ApplicationswilloftenusetheLogClassandLoggerClasstocreatelogs. Todiscoverthis,youshouldaudittheapplication’s sourcecodeforanysuchloggingclasses. Thesecanoftenbefoundbysearchingforthefollowingkeywords: • Functionsandclasses,suchas: – android.util.Log – Log.d|Log.e|Log.i|Log.v|Log.w|Log.wtf – Logger • Keywordsandsystemoutput: – System.out.print|System.err.print – logfile – logging – logs While preparing the production release, you can use tools like ProGuard (included in Android Studio). To determine whetherallloggingfunctionsfromtheandroid.util.Log classhavebeenremoved, checktheProGuardconfiguration file (proguard-rules.pro) for the following options (according to this example of removing logging code and this article aboutenablingProGuardinanAndroidStudioproject): -assumenosideeffectsclassandroid.util.Log { publicstaticbooleanisLoggable(java.lang.String,int); publicstaticintv(...); publicstaticinti(...); publicstaticintw(...); publicstaticintd(...); publicstaticinte(...); publicstaticintwtf(...); } Note that the example above only ensures that calls to the Log class’ methods will be removed. If the string that will beloggedisdynamicallyconstructed,thecodethatconstructsthestringmayremaininthebytecode. Forexample,the followingcodeissuesanimplicitStringBuildertoconstructthelogstatement: ExampleinJava: Log.v(\"Privatekeytag\",\"Privatekey[byteformat]:\" +key); ExampleinKotlin: Log.v(\"Privatekeytag\",\"Privatekey[byteformat]: $key\") Thecompiledbytecode,however,isequivalenttothebytecodeofthefollowinglogstatement,whichconstructsthestring explicitly: ExampleinJava: Log.v(\"Privatekeytag\",newStringBuilder(\"Privatekey[byteformat]:\").append(key.toString()).toString()); ExampleinKotlin: 216\\nLog.v(\"Privatekeytag\",StringBuilder(\"Privatekey[byteformat]:\").append(key).toString()) ProGuardguaranteesremovaloftheLog.vmethodcall. Whethertherestofthecode(new StringBuilder ...) willbe removeddependsonthecomplexityofthecodeandtheProGuardversion. Thisisasecurityriskbecausethe(unused)stringleaksplaintextdataintomemory,whichcanbeaccessedviaadebugger ormemorydumping. Unfortunately,nosilverbulletexistsforthisissue,butoneoptionwouldbetoimplementacustomloggingfacilitythat takessimpleargumentsandconstructsthelogstatementsinternally. SecureLog.v(\"Privatekey[byteformat]:\",key); ThenconfigureProGuardtostripitscalls. Dynamic Analysis Useallthemobileappfunctionsatleastonce,thenidentifytheapplication’sdatadirectoryandlookforlogfiles(/data/ data/<package-name>). Check the application logs to determine whether log data has been generated; some mobile applicationscreateandstoretheirownlogsinthedatadirectory. ManyapplicationdevelopersstilluseSystem.out.printlnorprintStackTraceinsteadofaproperloggingclass. There- fore, your testing strategy must include all output generated while the application is starting, running and closing. To determinewhatdataisdirectlyprintedbySystem.out.printlnorprintStackTrace,youcanuseLogcatasexplained inthechapter“BasicSecurityTesting”,section“MonitoringSystemLogs”. RememberthatyoucantargetaspecificappbyfilteringtheLogcatoutputasfollows: adblogcat |grep \"$(adbshellps |grep <package-name>|awk'{print$2}')\" IfyoualreadyknowtheappPIDyoumaygiveitdirectlyusing--pidflag. Youmayalsowanttoapplyfurtherfiltersorregularexpressions(usinglogcat’sregexflags-e<expr>,--regex=<expr> forexample)ifyouexpectcertainstringsorpatternstocomeupinthelogs. Testing the Device-Access-Security Policy Platform: android MASVSV1: MSTG-STORAGE-11 MASVSV2: MASVS-STORAGE-1 Overview Appsthatprocessorquerysensitiveinformationshouldruninatrustedandsecureenvironment. Tocreatethisenviron- ment,theappcancheckthedeviceforthefollowing: • PIN-orpassword-protecteddevicelocking • RecentAndroidOSversion • USBDebuggingactivation • Deviceencryption • Devicerooting(seealso“TestingRootDetection”) 217\\nStatic Analysis Totestthedevice-access-securitypolicythattheappenforces,awrittencopyofthepolicymustbeprovided. Thepolicy should define available checks and their enforcement. For example, one check could require that the app run only on Android6.0(APIlevel23)oramorerecentversion,closingtheappordisplayingawarningiftheAndroidversionisless than6.0. Checkthesourcecodeforfunctionsthatimplementthepolicyanddeterminewhetheritcanbebypassed. YoucanimplementchecksontheAndroiddevicebyqueryingSettings.Secureforsystempreferences. DeviceAdminis- trationAPIofferstechniquesforcreatingapplicationsthatcanenforcepasswordpoliciesanddeviceencryption. Dynamic Analysis The dynamic analysis depends on the checks enforced by the app and their expected behavior. If the checks can be bypassed,theymustbevalidated. 218\\nAndroid Cryptographic APIs Overview Inthechapter“MobileAppCryptography”,weintroducedgeneralcryptographybestpracticesanddescribedtypicalissues thatcanoccurwhencryptographyisusedincorrectly. Inthischapter,we’llgointomoredetailonAndroid’scryptography", "metadata": {"doc_id": "OWASP_MASTG", "chunk_id": 88}}