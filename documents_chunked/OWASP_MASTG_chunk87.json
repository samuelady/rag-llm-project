{"text": "out.flush() out.close() } } Formoreinformation,takealookatSecurelyStoringSensitiveDatainRAM. Inthe“StaticAnalysis”section,wementionedtheproperwaytohandlecryptographickeyswhenyouareusingAndroid- KeyStoreorSecretKey. For a better implementation of SecretKey, look at the SecureSecretKey class below. Although the implementation is probably missing some boilerplate code that would make the class compatible with SecretKey, it addresses the main securityconcerns: • Nocross-contexthandlingofsensitivedata. Eachcopyofthekeycanbeclearedfromwithinthescopeinwhichit wascreated. • Thelocalcopyisclearedaccordingtotherecommendationsgivenabove. ExampleinJava: public class SecureSecretKey implements javax.crypto.SecretKey,Destroyable { private byte[]key; private final Stringalgorithm; /**ConstructsSecureSecretKeyinstanceoutofacopyoftheprovidedkeybytes. *Thecallerisresponsibleofclearingthekeyarrayprovidedasinput. *Theinternalcopyofthekeycanbeclearedbycallingthedestroy() method. */ public SecureSecretKey(final byte[]key,final Stringalgorithm){ this.key=key.clone(); this.algorithm =algorithm; } public String getAlgorithm(){ return this.algorithm; } public String getFormat(){ return \"RAW\"; } /**Returnsacopyofthekey. *Makesuretoclearthereturnedbytearraywhennolongerneeded. */ public byte[]getEncoded(){ if(null ==key){ throw newNullPointerException(); } return key.clone(); } /**Overwritesthekeywithdummydatatoensurethiscopyisnolongerpresentinmemory.*/ public void destroy(){ if(isDestroyed()){ 210\\nreturn; } byte[]nonSecret =newString(\"RuntimeException\").getBytes(\"ISO-8859-1\"); for(inti=0;i<key.length;i++){ key[i]=nonSecret[i%nonSecret.length]; } FileOutputStreamout =newFileOutputStream(\"/dev/null\"); out.write(key); out.flush(); out.close(); this.key=null; System.gc(); } public boolean isDestroyed(){ return key==null; } } ExampleinKotlin: class SecureSecretKey(key:ByteArray,algorithm:String):SecretKey,Destroyable { private varkey:ByteArray? private valalgorithm:String override fungetAlgorithm():String { return algorithm } override fungetFormat():String { return \"RAW\" } /**Returnsacopyofthekey. *Makesuretoclearthereturnedbytearraywhennolongerneeded. */ override fungetEncoded():ByteArray { if(null ==key){ throw NullPointerException() } return key!!.clone() } /**Overwritesthekeywithdummydatatoensurethiscopyisnolongerpresentinmemory.*/ override fundestroy(){ if(isDestroyed){ return } valnonSecret:ByteArray =String(\"RuntimeException\").toByteArray(charset(\"ISO-8859-1\")) for(iinkey!!.indices){ key!![i]=nonSecret[i%nonSecret.size] } valout=FileOutputStream(\"/dev/null\") out.write(key) out.flush() out.close() key=null System.gc() } override funisDestroyed():Boolean { return key==null } /**ConstructsSecureSecretKeyinstanceoutofacopyoftheprovidedkeybytes. *Thecallerisresponsibleofclearingthekeyarrayprovidedasinput. *Theinternalcopyofthekeycanbeclearedbycallingthedestroy()method. */ init { this.key=key.clone() this.algorithm =algorithm } } Secureuser-provideddataisthefinalsecureinformationtypeusuallyfoundinmemory. Thisisoftenmanagedbyimple- mentingacustominputmethod,forwhichyoushouldfollowtherecommendationsgivenhere. However,Androidallows informationtobepartiallyerasedfromEditTextbuffersviaacustomEditable.Factory. EditTexteditText =...;// pointyourvariabletoyourEditTextinstance EditText.setEditableFactory(newEditable.Factory(){ public Editable newEditable(CharSequencesource){ ...//returnanewinstanceofasecureimplementationofEditable. } }); 211\\nRefer to the SecureSecretKey example above for an example Editable implementation. Note that you will be able tosecurelyhandleallcopiesmadebyeditText.getTextifyouprovideyourfactory. Youcanalsotrytooverwritethe internalEditTextbufferbycallingeditText.setText,butthereisnoguaranteethatthebufferwillnothavebeencopied already. IfyouchoosetorelyonthedefaultinputmethodandEditText,youwillhavenocontroloverthekeyboardor othercomponentsthatareused. Therefore,youshouldusethisapproachforsemi-confidentialinformationonly. Inallcases,makesurethatsensitivedatainmemoryisclearedwhenausersignsoutoftheapplication. Finally,make surethathighlysensitiveinformationisclearedoutthemomentanActivityorFragment’sonPauseeventistriggered. Notethatthismightmeanthatauserhastore-authenticateeverytimetheapplicationresumes. Dynamic Analysis Static analysis will help you identify potential problems, but it can’t provide statistics about how long data has been exposedinmemory,norcanithelpyouidentifyproblemsinclosed-sourcedependencies. Thisiswheredynamicanalysis comesintoplay. Therearevariouswaystoanalyzethememoryofaprocess,e.g.liveanalysisviaadebugger/dynamicinstrumentation andanalyzingoneormorememorydumps. Retrieving and Analyzing a Memory Dump Whether you are using a rooted or a non-rooted device, you can dump the app’s process memory with objection and Fridump. Youcanfindadetailedexplanationofthisprocessinthesection“MemoryDump”,inthechapter“Tampering andReverseEngineeringonAndroid”. Afterthememoryhasbeendumped(e.g.toafilecalled“memory”),dependingonthenatureofthedatayou’relooking for, you’ll need a set of different tools to process and analyze that memory dump. For instance, if you’re focusing on strings,itmightbesufficientforyoutoexecutethecommandstringsorrabin2 -zztoextractthosestrings. ##usingstrings $stringsmemory >strings.txt ##usingrabin2 $rabin2 -ZZmemory >strings.txt Openstrings.txtinyourfavoriteeditoranddigthroughittoidentifysensitiveinformation. However if you’d like to inspect other kind of data, you’d rather want to use radare2 and its search capabilities. See radare2’shelponthesearchcommand(/?) formoreinformationandalistofoptions. Thefollowingshowsonlyasubset ofthem: $r2 <name_of_your_dump_file> [0x00000000]>/? Usage:/[!bf][arg] Searchstuff (see'e??search' foroptions) |Useio.vaforsearchinginnonvirtualaddressingspaces |/foo\\x00 searchforstring 'foo\\0' |/c[ar] searchforcryptomaterials |/e/E.F/i matchregularexpression |/ifoo searchforstring 'foo' ignoringcase |/m[?][ebm]magicfile searchformagic,filesystemsorbinaryheaders |/v[1248]value lookforan `cfg.bigendian`32bitvalue |/wfoo searchforwidestring 'f\\0o\\0o\\0' |/xff0033 searchforhexstring |/zminmax searchforstringsofgivensize ... Runtime Memory Analysis Insteadofdumpingthememorytoyourhostcomputer,youcanalternativelyuser2frida. Withit,youcananalyzeand inspecttheapp’smemorywhileit’srunning. Forexample,youmayruntheprevioussearchcommandsfromr2fridaand search the memory for a string, hexadecimal values, etc. When doing so, remember to prepend the search command (andanyotherr2fridaspecificcommands)withabackslash: afterstartingthesessionwithr2 frida://usb//<name_- of_your_app>. Formoreinformation,optionsandapproaches,pleaserefertosection“In-MemorySearch”inthechapter“Tamperingand ReverseEngineeringonAndroid”. 212\\nExplicitly Dumping and Analyzing the Java Heap For rudimentary analysis, you can use Android Studio’s built-in tools. They are on the Android Monitor tab. To dump memory, selectthedeviceandappyouwanttoanalyzeandclickDumpJavaHeap. Thiswillcreatea.hprof fileinthe capturesdirectory,whichisontheapp’sprojectpath. Tonavigatethroughclassinstancesthatweresavedinthememorydump,selectthePackageTreeViewinthetabshowing the.hprof file. Formoreadvancedanalysisofthememorydump,usetheEclipseMemoryAnalyzerTool(MAT).ItisavailableasanEclipse pluginandasastandaloneapplication. ToanalyzethedumpinMAT,usethehprof-convplatformtool,whichcomeswiththeAndroidSDK. 213\\n./hprof-convmemory.hprofmemory-mat.hprof MAT provides several tools for analyzing the memory dump. For example, the Histogram provides an estimate of the numberofobjectsthathavebeencapturedfromagiventype,andtheThreadOverviewshowsprocesses’threadsand stack frames. The Dominator Tree provides information about keep-alive dependencies between objects. You can use regularexpressionstofiltertheresultsthesetoolsprovide. ObjectQueryLanguagestudioisaMATfeaturethatallowsyoutoqueryobjectsfromthememorydumpwithanSQL-like language. ThetoolallowsyoutotransformsimpleobjectsbyinvokingJavamethodsonthem,anditprovidesanAPIfor buildingsophisticatedtoolsontopoftheMAT. SELECT *FROM java.lang.String Intheexampleabove,allStringobjectspresentinthememorydumpwillbeselected. Theresultswillincludetheobject’s class,memoryaddress,value,andretaincount. Tofilterthisinformationandseeonlythevalueofeachstring,usethe followingcode: SELECT toString(object)FROM java.lang.String object", "metadata": {"doc_id": "OWASP_MASTG", "chunk_id": 87}}