{"text": "//Returnsanintentobjectthatyouusetocheckforanupdate. Task<AppUpdateInfo>appUpdateInfo =appUpdateManager.getAppUpdateInfo(); //Checksthattheplatformwillallowthespecifiedtypeofupdate. if(appUpdateInfo.updateAvailability()==UpdateAvailability.UPDATE_AVAILABLE 297\\n//Foraflexibleupdate,useAppUpdateType.FLEXIBLE && appUpdateInfo.isUpdateTypeAllowed(AppUpdateType.IMMEDIATE)){ //...Part2:requestupdate appUpdateManager.startUpdateFlowForResult( //Passtheintentthatisreturnedby'getAppUpdateInfo()'. appUpdateInfo, //Or'AppUpdateType.FLEXIBLE'forflexibleupdates. AppUpdateType.IMMEDIATE, //Thecurrentactivitymakingtheupdaterequest. this, //Includearequestcodetolatermonitorthisupdaterequest. MY_REQUEST_CODE); //...Part3:checkifupdatecompletedsuccessfully @Override public void onActivityResult(intrequestCode,intresultCode,Intentdata){ if(myRequestCode ==MY_REQUEST_CODE){ if(resultCode !=RESULT_OK){ log(\"Updateflowfailed!Resultcode:\" +resultCode); //Iftheupdateiscancelledorfails, //youcanrequesttostarttheupdateagainincaseofforcedupdates } } } //..Part4: //Checksthattheupdateisnotstalledduring'onResume()'. //However,youshouldexecutethischeckatallentrypointsintotheapp. @Override protected void onResume(){ super.onResume(); appUpdateManager .getAppUpdateInfo() .addOnSuccessListener( appUpdateInfo ->{ ... if(appUpdateInfo.updateAvailability() ==UpdateAvailability.DEVELOPER_TRIGGERED_UPDATE_IN_PROGRESS) { //Ifanin-appupdateisalreadyrunning,resumetheupdate. manager.startUpdateFlowForResult( appUpdateInfo, IMMEDIATE, this, MY_REQUEST_CODE); } }); } } Source: https://developer.android.com/guide/app-bundle/in-app-updates Dynamic analysis Inordertotestforproperupdating: trydownloadinganolderversionoftheapplicationwithasecurityvulnerability,either byareleasefromthedevelopersorbyusingathirdpartyapp-store. Next,verifywhetherornotyoucancontinuetouse theapplicationwithoutupdatingit. Ifanupdatepromptisgiven,verifyifyoucanstillusetheapplicationbycancelingthe prompt or otherwise circumventing it through normal application usage. This includes validating whether the backend willstopcallstovulnerablebackendsand/orwhetherthevulnerableapp-versionitselfisblockedbythebackend. Lastly, seeifyoucanplaywiththeversionnumberofaman-in-the-middledappandseehowthebackendrespondstothis(and ifitisrecordedatallforinstance). Checking for Weaknesses in Third Party Libraries Platform: android MASVSV1: MSTG-CODE-5 MASVSV2: MASVS-CODE-3 298\\nOverview Static Analysis Detecting vulnerabilities in third party dependencies can be done by means of the OWASP Dependency checker. This is best done by using a gradle plugin, such as dependency-check-gradle. In order to use the plugin, the following steps need to be applied: Install the plugin from the Maven central repository by adding the following script to your build.gradle: buildscript{ repositories{ mavenCentral() } dependencies{ classpath'org.owasp:dependency-check-gradle:3.2.0' } } applyplugin:'org.owasp.dependencycheck' Oncegradlehasinvokedtheplugin,youcancreateareportbyrunning: gradleassemble gradledependencyCheckAnalyze --info Thereportwillbeinbuild/reportsunlessotherwiseconfigured. Usethereportinordertoanalyzethevulnerabilities found. Seeremediationonwhattodogiventhevulnerabilitiesfoundwiththelibraries. Please be advised that the plugin requires to download a vulnerability feed. Consult the documentation in case issues arisewiththeplugin. Lastly,pleasenotethatforhybridapplications,onewillhavetochecktheJavaScriptdependencieswithRetireJS.Similarly forXamarin,onewillhavetochecktheC#dependencies. Whenalibraryisfoundtocontainvulnerabilities,thenthefollowingreasoningapplies: • Isthelibrarypackagedwiththeapplication? Thencheckwhetherthelibraryhasaversioninwhichthevulnerability ispatched. Ifnot,checkwhetherthevulnerabilityactuallyaffectstheapplication. Ifthatisthecaseormightbethe caseinthefuture,thenlookforanalternativewhichprovidessimilarfunctionality,butwithoutthevulnerabilities. • Isthelibrarynotpackagedwiththeapplication? Seeifthereisapatchedversioninwhichthevulnerabilityisfixed. If thisisnotthecase,checkiftheimplicationsofthevulnerabilityforthebuild-process. Couldthevulnerabilityimpede abuildorweakenthesecurityofthebuild-pipeline? Thentrylookingforanalternativeinwhichthevulnerabilityis fixed. When the sources are not available, one can decompile the app and check the JAR files. When Dexguard or ProGuard areappliedproperly,thenversioninformationaboutthelibraryisoftenobfuscatedandthereforegone. Otherwiseyou canstillfindtheinformationveryofteninthecommentsoftheJavafilesofgivenlibraries. ToolssuchasMobSFcanhelp in analyzing the possible libraries packed with the application. If you can retrieve the version of the library, either via comments,orviaspecificmethodsusedincertainversions,youcanlookthemupforCVEsbyhand. Iftheapplicationisahigh-riskapplication, youwillendupvettingthelibrarymanually. Inthatcase, therearespecific requirements for native code, which you can find in the chapter “Testing Code Quality”. Next to that, it is good to vet whetherallbestpracticesforsoftwareengineeringareapplied. Dynamic Analysis Thedynamicanalysisofthissectioncomprisesvalidatingwhetherthecopyrightsofthelicenseshavebeenadheredto. ThisoftenmeansthattheapplicationshouldhaveanaboutorEULAsectioninwhichthecopyrightstatementsarenoted asrequiredbythelicenseofthethirdpartylibrary. Testing for URL Loading in WebViews 299\\nPlatform: android MASVSV1: MSTG-PLATFORM-2 MASVSV2: MASVS-CODE-4 Overview In order to test for URL loading in WebViews you need to carefully analyze handling page navigation, especially when usersmightbeabletonavigateawayfromatrustedenvironment. ThedefaultandsafestbehavioronAndroidistolet thedefaultwebbrowseropenanylinkthattheusermightclickinsidetheWebView. However,thisdefaultlogiccanbe modifiedbyconfiguringaWebViewClientwhichallowsnavigationrequeststobehandledbytheappitself. Static Analysis Check for Page Navigation Handling Override TotestiftheappisoverridingthedefaultpagenavigationlogicbyconfiguringaWebViewClientyoushouldsearchfor andinspectthefollowinginterceptioncallbackfunctions: • shouldOverrideUrlLoadingallowsyourapplicationtoeitherabortloadingWebViewswithsuspiciouscontentby returningtrueorallowtheWebViewtoloadtheURLbyreturningfalse. Considerations: – ThismethodisnotcalledforPOSTrequests. – ThismethodisnotcalledforXmlHttpRequests,iFrames,“src”attributesincludedinHTMLor<script>tags. Instead,shouldInterceptRequestshouldtakecareofthis. • shouldInterceptRequestallowstheapplicationtoreturnthedatafromresourcerequests. Ifthereturnvalueis null,theWebViewwillcontinuetoloadtheresourceasusual. Otherwise,thedatareturnedbytheshouldInter- ceptRequestmethodisused. Considerations: – This callback is invoked for a variety of URL schemes (e.g., http(s):, data:, file:, etc.), not only those schemeswhichsendrequestsoverthenetwork. – This is not called for javascript: or blob: URLs, or for assets accessed via file:///android_asset/ or file:///android_res/URLs. Inthecaseofredirects,thisisonlycalledfortheinitialresourceURL,notany subsequentredirectURLs. – WhenSafeBrowsingisenabled,theseURLsstillundergoSafeBrowsingchecksbutthedevelopercanallow theURLwithsetSafeBrowsingWhitelistorevenignorethewarningviatheonSafeBrowsingHitcallback. As you can see there are a lot of points to consider when testing the security of WebViews that have a WebViewClient configured,sobesuretocarefullyreadandunderstandallofthembycheckingtheWebViewClientDocumentation. Check for EnableSafeBrowsing Disabled WhilethedefaultvalueofEnableSafeBrowsingistrue,someapplicationsmightopttodisableit. ToverifythatSafeBrows- ingisenabled,inspecttheAndroidManifest.xmlfileandmakesurethattheconfigurationbelowisnotpresent: <manifest> <application> <meta-data android:name=\"android.webkit.WebView.EnableSafeBrowsing\" android:value=\"false\" /> ... </application> </manifest> Dynamic Analysis AconvenientwaytodynamicallytestdeeplinkingistouseFridaorfrida-traceandhooktheshouldOverrideUrlLoading, shouldInterceptRequestmethodswhileusingtheappandclickingonlinkswithintheWebView. Besuretoalsohook otherrelatedUrimethodssuchasgetHost,getSchemeorgetPathwhicharetypicallyusedtoinspecttherequestsand matchknownpatternsordenylists. 300\\nAndroid Anti-Reversing Defenses Overview General Disclaimer Thelackofanyofthesemeasuresdoesnotcauseavulnerability-instead,theyaremeanttoincreasetheapp’s resilienceagainstreverseengineeringandspecificclient-sideattacks. None of these measures can assure a 100% effectiveness, as the reverse engineer will always have full access to the deviceandwillthereforealwayswin(givenenoughtimeandresources)! Forexample,preventingdebuggingisvirtuallyimpossible. Iftheappispubliclyavailable,itcanberunonanuntrusted devicethatisunderfullcontroloftheattacker. Averydeterminedattackerwilleventuallymanagetobypassalltheapp’s anti-debuggingcontrolsbypatchingtheappbinaryorbydynamicallymodifyingtheapp’sbehavioratruntimewithtools suchasFrida. You can learn more about principles and technical risks of reverse engineering and code modification in these OWASP", "metadata": {"doc_id": "OWASP_MASTG", "chunk_id": 111}}