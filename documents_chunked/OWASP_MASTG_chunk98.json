{"text": "other apps. On Android, WebViews use the WebKit rendering engine to display web pages,butthepagesarestrippeddowntominimalfunctions,forexample,pagesdon’thaveaddressbars. IftheWebView implementationistoolaxandallowsusageofJavaScript,JavaScriptcanbeusedtoattacktheappandgainaccesstoits data. WebView Protocol Handlers SeveraldefaultschemasareavailableforAndroidURLs. TheycanbetriggeredwithinaWebViewwiththefollowing: • http(s):// • file:// • tel:// WebViewscanloadremotecontentfromanendpoint,buttheycanalsoloadlocalcontentfromtheappdatadirectoryor externalstorage. Ifthelocalcontentisloaded,theusershouldn’tbeabletoinfluencethefilenameorthepathusedto loadthefile,andusersshouldn’tbeabletoedittheloadedfile. Java Objects Exposed Through WebViews AndroidoffersawayforJavaScriptexecutioninaWebViewtocallandusenativefunctionsofanAndroidapp(annotated with @JavascriptInterface) by using the addJavascriptInterface method. This is known as a WebView JavaScript bridgeornativebridge. Please note that when you use addJavascriptInterface, you’re explicitly granting access to the registered JavaScript Interface object to all pages loaded within that WebView. This implies that, if the user navigates outside your app or domain, all other external pages will also have access to those JavaScript Interface objects which mightpresentapotentialsecurityriskifanysensitivedataisbeingexposedthoughthoseinterfaces. Warning: Take extreme care with apps targeting Android versions below Android 4.2 (API level 17) as they are vulnerabletoaflawintheimplementationofaddJavascriptInterface: anattackthatisabusingreflection,which leadstoremotecodeexecutionwhenmaliciousJavaScriptisinjectedintoaWebView. ThiswasduetoallJavaObject methodsbeingaccessiblebydefault(insteadofonlythoseannotated). 251\\nWebViews Cleanup ClearingtheWebViewresourcesisacrucialstepwhenanappaccessesanysensitivedatawithinaWebView. Thisincludes anyfilesstoredlocally,theRAMcacheandanyloadedJavaScript. Asanadditionalmeasure,youcoulduseserver-sideheaderssuchasno-cache,whichpreventanapplicationfromcaching particularcontent. StartingonAndroid10(APIlevel29)appsareabletodetectifaWebViewhasbecomeunresponsive. Ifthishappens, theOSwillautomaticallycalltheonRenderProcessUnresponsivemethod. YoucanfindmoresecuritybestpracticeswhenusingWebViewsonAndroidDevelopers. Deep Links DeeplinksareURIsofanyschemethattakeusersdirectlytospecificcontentinanapp. Anappcansetupdeeplinksby addingintentfiltersontheAndroidManifestandextractingdatafromincomingintentstonavigateuserstothecorrect activity. Androidsupportstwotypesofdeeplinks: • CustomURLSchemes,whicharedeeplinksthatuseanycustomURLscheme,e.g.myapp://(notverifiedbythe OS). • AndroidAppLinks(Android6.0(APIlevel23)andhigher),whicharedeeplinksthatusethehttp://andhttps:// schemesandcontaintheautoVerifyattribute(whichtriggersOSverification). DeepLinkCollision: Usingunverifieddeeplinkscancauseasignificantissue-anyotherappsinstalledonauser’sdevicecandeclareandtry tohandlethesameintent,whichisknownasdeeplinkcollision. Anyarbitraryapplicationcandeclarecontroloverthe exactsamedeeplinkbelongingtoanotherapplication. InrecentversionsofAndroidthisresultsinaso-calleddisambiguationdialogshowntotheuserthatasksthemtoselect theapplicationthatshouldhandlethedeeplink. Theusercouldmakethemistakeofchoosingamaliciousapplication insteadofthelegitimateone. 252\\nAndroidAppLinks: Inordertosolvethedeeplinkcollisionissue,Android6.0(APILevel23)introducedAndroidAppLinks,whichareverified deeplinksbasedonawebsiteURLexplicitlyregisteredbythedeveloper. ClickingonanAppLinkwillimmediatelyopen theappifit’sinstalled. Therearesomekeydifferencesfromunverifieddeeplinks: • AppLinksonlyusehttp://andhttps://schemes,anyothercustomURLschemesarenotallowed. • AppLinksrequirealivedomaintoserveaDigitalAssetLinksfileviaHTTPS. • AppLinksdonotsufferfromdeeplinkcollisionsincetheydon’tshowadisambiguationdialogwhenauseropens them. 253\\nSensitive Functionality Exposure Through IPC Duringimplementationofamobileapplication,developersmayapplytraditionaltechniquesforIPC(suchasusingshared filesornetworksockets). TheIPCsystemfunctionalityofferedbymobileapplicationplatformsshouldbeusedbecauseitis muchmorematurethantraditionaltechniques. UsingIPCmechanismswithnosecurityinmindmaycausetheapplication toleakorexposesensitivedata. ThefollowingisalistofAndroidIPCMechanismsthatmayexposesensitivedata: • Binders • Services • BoundServices • AIDL • Intents • ContentProviders Pending Intents Oftenwhiledealingwithcomplexflowsduringappdevelopment,therearesituationswhereanappAwantsanotherapp B to perform a certain action in the future, on app A’s behalf. Trying to implement this by only usingIntents leads to varioussecurityproblems,likehavingmultipleexportedcomponents. Tohandlethisusecaseinasecuremanner,Android providesthePendingIntentAPI. PendingIntentaremostcommonlyusedfornotifications,appwidgets,mediabrowserservices,etc. Whenusedfornoti- fications,PendingIntentisusedtodeclareanintenttobeexecutedwhenauserperformsanactionwithanapplication’s notification. Thenotificationrequiresacallbacktotheapplicationtotriggeranactionwhentheuserclicksonit. Internally, aPendingIntentobjectwrapsanormalIntentobject(referredasbaseintent)thatwilleventuallybeused to invoke an action. For example, the base intent specifies that an activity A should be started in an application. The receivingapplicationofthePendingIntent,willunwrapandretrievethisbaseintentandinvoketheactivityAbycalling thePendingIntent.sendfunction. AtypicalimplementationforusingPendingIntentisbelow: Intentintent =newIntent(applicationContext,SomeActivity.class); //baseintent //createapendingintent PendingIntentpendingIntent =PendingIntent.getActivity(applicationContext,0,intent,PendingIntent.FLAG_IMMUTABLE); //sendthependingintenttoanotherapp IntentanotherIntent =newIntent(); anotherIntent.setClassName(\"other.app\",\"other.app.MainActivity\"); anotherIntent.putExtra(\"pendingIntent\",pendingIntent); startActivity(anotherIntent); WhatmakesaPendingIntentsecureisthat,unlikeanormalIntent,itgrantspermissiontoaforeignapplicationtouse theIntent(thebaseintent)itcontains,asifitwerebeingexecutedbyyourapplication’sownprocess. Thisallowsan applicationtofreelyusethemtocreatecallbackswithouttheneedtocreateexportedactivities. Ifnotimplementedcorrectly,amaliciousapplicationcanhijackaPendingIntent. Forexample,inthenotificationexam- ple above, a malicious application with android.permission.BIND_NOTIFICATION_LISTENER_SERVICE can bind to the notificationlistenerserviceandretrievethependingintent. TherearecertainsecuritypitfallswhenimplementingPendingIntents,whicharelistedbelow: • Mutable fields: A PendingIntent can have mutable and empty fields that can be filled by a malicious applica- tion. Thiscanleadtoamaliciousapplicationgainingaccesstonon-exportedapplicationcomponents. Usingthe PendingIntent.FLAG_IMMUTABLEflagmakesthePendingIntentimmutableandpreventsanychangestothefields. PriortoAndroid12(APIlevel31),thePendingIntentwasmutablebydefault,whilesinceAndroid12(APIlevel31) itischangedtoimmutablebydefaulttopreventaccidentalvulnerabilities. • Use of implicit intent: A malicious application can receive a PendingIntent and then update the base intent totargetthecomponentandpackagewithinthemaliciousapplication. Asamitigation,ensurethatyouexplicitly specifytheexactpackage,actionandcomponentthatwillreceivethebaseintent. ThemostcommoncaseofPendingIntentattackiswhenamaliciousapplicationisabletointerceptit. Forfurtherdetails,checktheAndroiddocumentationonusingapendingintent. 254\\nImplicit Intents An Intent is a messaging object that you can use to request an action from another application component. Although intentsfacilitatecommunicationbetweencomponentsinavarietyofways,therearethreebasicusecases: startingan activity,startingaservice,anddeliveringabroadcast. AccordingtotheAndroidDevelopersDocumentation,Androidprovidestwotypesofintents: • Explicitintentsspecifywhichapplicationwillsatisfytheintentbyprovidingeitherthetargetapp’spackagename orafullyqualifiedcomponentclassname. Typically,you’lluseanexplicitintenttostartacomponentinyourown app,becauseyouknowtheclassnameoftheactivityorserviceyouwanttostart. Forexample,youmightwantto startanewactivityinyourappinresponsetoauseraction,orstartaservicetodownloadafileinthebackground. //Note thespecificationofaconcretecomponent(DownloadActivity)thatisstartedbytheintent. IntentdownloadIntent =newIntent(this,DownloadActivity.class); downloadIntent.setAction(\"android.intent.action.GET_CONTENT\") startActivityForResult(downloadIntent); • Implicit intents do not name a specific component, but instead declare a general action to be performed that anotherapp’scomponentcanhandle. Forexample,ifyouwanttoshowtheuseralocationonamap,youcanuse animplicitintenttoaskanothercapableapptoshowaspecificlocationonamap. Anotherexampleiswhenthe userclicksonanemailaddresswithinanapp,wherethecallingappdoesnotwanttospecifyaspecificemailapp andleavesthatchoiceuptotheuser. //Developers canalsostartanactivitybyjustsettinganactionthatismatchedbytheintendedapp. IntentdownloadIntent =newIntent(); downloadIntent.setAction(\"android.intent.action.GET_CONTENT\") startActivityForResult(downloadIntent); Theuseofimplicitintentscanleadtomultiplesecurityrisks,e.g.ifthecallingappprocessesthereturnvalueoftheimplicit intent without proper verification or if the intent contains sensitive data, it can be accidentally leaked to unauthorized third-parties. You can refer to this blog post, this article and CWE-927 for more information about the mentioned problem, concrete attackscenariosandrecommendations. Object Persistence ThereareseveralwaystopersistanobjectonAndroid: Object Serialization Anobjectanditsdatacanberepresentedasasequenceofbytes. ThisisdoneinJavaviaobjectserialization. Serialization isnotinherentlysecure. Itisjustabinaryformat(orrepresentation)forlocallystoringdataina.serfile. Encryptingand signing HMAC-serialized data is possible as long as the keys are stored safely. Deserializing an object requires a class ofthesameversionastheclassusedtoserializetheobject. Afterclasseshavebeenchanged,theObjectInputStream can’tcreateobjectsfromolder.serfiles. TheexamplebelowshowshowtocreateaSerializableclassbyimplementing theSerializableinterface. import java.io.Serializable; public class Person implements Serializable { private StringfirstName; private StringlastName; public Person(StringfirstName,StringlastName){ this.firstName =firstName; this.lastName =lastName; } //.. //getters,setters,etc", "metadata": {"doc_id": "OWASP_MASTG", "chunk_id": 98}}