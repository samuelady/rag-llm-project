{"text": "However,appscan’t simplybeaddedtoastoreandshared,theymustbefirstsigned. Thecryptographicsignatureservesasaverifiablemark placedbythedeveloperoftheapp. Itidentifiestheapp’sauthorandensuresthattheapphasnotbeenmodifiedsince itsinitialdistribution. 104\\nSigning Process Duringdevelopment,appsaresignedwithanautomaticallygeneratedcertificate. Thiscertificateisinherentlyinsecure andisfordebuggingonly. Moststoresdon’tacceptthiskindofcertificateforpublishing;therefore,acertificatewithmore securefeaturesmustbecreated. WhenanapplicationisinstalledontheAndroiddevice,thePackageManagerensures thatithasbeensignedwiththecertificateincludedinthecorrespondingAPK.Ifthecertificate’spublickeymatchesthe key used to sign any other APK on the device, the new APK may share a UID with the pre-existing APK. This facilitates interactionsbetweenapplicationsfromasinglevendor. Alternatively, specifyingsecuritypermissionsfortheSignature protectionlevelispossible;thiswillrestrictaccesstoapplicationsthathavebeensignedwiththesamekey. APK Signing Schemes Androidsupportsthreeapplicationsigningschemes. StartingwithAndroid9(APIlevel28),APKscanbeverifiedwithAPK SignatureSchemev3(v3scheme),APKSignatureSchemev2(v2scheme)orJARsigning(v1scheme). ForAndroid7.0 (APIlevel24)andabove,APKscanbeverifiedwiththeAPKSignatureSchemev2(v2scheme)orJARsigning(v1scheme). Forbackwardscompatibility,anAPKcanbesignedwithmultiplesignatureschemesinordertomaketheapprunonboth newerandolderSDKversions. Olderplatformsignorev2signaturesandverifyv1signaturesonly. JAR Signing (v1 Scheme) TheoriginalversionofappsigningimplementsthesignedAPKasastandardsignedJAR,whichmustcontainalltheentries inMETA-INF/MANIFEST.MF.Allfilesmustbesignedwithacommoncertificate. Thisschemedoesnotprotectsomeparts oftheAPK,suchasZIPmetadata. ThedrawbackofthisschemeisthattheAPKverifierneedstoprocessuntrusteddata structures before applying the signature, and the verifier discards data the data structures don’t cover. Also, the APK verifiermustdecompressallcompressedfiles,whichtakesconsiderabletimeandmemory. APK Signature Scheme (v2 Scheme) WiththeAPKsignaturescheme,thecompleteAPKishashedandsigned,andanAPKSigningBlockiscreatedandinserted intotheAPK.Duringvalidation,thev2schemechecksthesignaturesoftheentireAPKfile. ThisformofAPKverificationis fasterandoffersmorecomprehensiveprotectionagainstmodification. YoucanseetheAPKsignatureverificationprocess forv2Schemebelow. APK Signature Scheme (v3 Scheme) Thev3APKSigningBlockformatisthesameasv2. V3addsinformationaboutthesupportedSDKversionsandaproof- of-rotationstructtotheAPKsigningblock. InAndroid9(APIlevel28)andhigher,APKscanbeverifiedaccordingtoAPK SignatureSchemev3,v2orv1scheme. Olderplatformsignorev3signaturesandtrytoverifyv2thenv1signature. 105\\nThe proof-of-rotation attribute in the signed-data of the signing block consists of a singly-linked list, with each node containingasigningcertificateusedtosignpreviousversionsoftheapp. Tomakebackwardcompatibilitywork,theold signingcertificatessignthenewsetofcertificates,thusprovidingeachnewkeywithevidencethatitshouldbeastrusted astheolderkey(s). ItisnolongerpossibletosignAPKsindependently,becausetheproof-of-rotationstructuremusthave theoldsigningcertificatessigningthenewsetofcertificates,ratherthansigningthemone-by-one. YoucanseetheAPK signaturev3schemeverificationprocessbelow. APK Signature Scheme (v4 Scheme) TheAPKSignatureSchemev4wasintroducedalongwithAndroid11(APIlevel30)andrequiresalldeviceslaunchedwith Android11anduptohavefs-verityenabledbydefault. fs-verityisaLinuxkernelfeaturethatisprimarilyusedforfile authentication (detection of malicious modifications) due to its extremely efficient file hash calculation. Read requests onlywillsucceedifthecontentverifiesagainsttrusteddigitalcertificatesthatwereloadedtothekernelkeyringduring boottime. The v4 signature requires a complementary v2 or v3 signature and in contrast to previous signature schemes, the v4 signature is stored in a separate file <apk name>.apk.idsig. Remember to specify it using the --v4-signature-file flagwhenverifyingav4-signedAPKwithapksigner verify. YoucanfindmoredetailedinformationintheAndroiddeveloperdocumentation. Creating Your Certificate Androidusespublic/privatecertificatestosignAndroidapps(.apkfiles). Certificatesarebundlesofinformation;interms of security, keys are the most important part of that bundle. Public certificates contain users’ public keys, and private certificates contain users’ private keys. Public and private certificates are linked. Certificates are unique and can’t be re-generated. Notethatifacertificateislost,itcannotberecovered,soupdatinganyappssignedwiththatcertificate becomesimpossible. Appcreatorscaneitherreuseanexistingprivate/publickeypairthatisinanavailableKeyStoreor generateanewpair. IntheAndroidSDK,anewkeypairisgeneratedwiththekeytoolcommand. Thefollowingcommand createsaRSAkeypairwithakeylengthof2048bitsandanexpirytimeof7300days=20years. Thegeneratedkeypair isstoredinthefile‘myKeyStore.jks’,whichisinthecurrentdirectory: keytool -genkey -alias myDomain -keyalg RSA-keysize 2048 -validity 7300 -keystore myKeyStore.jks -storepass myStrongPassword Safelystoringyoursecretkeyandmakingsureitremainssecretduringitsentirelifecycleisofparamountimportance. Anyone who gains access to the key will be able to publish updates to your apps with content that you don’t control (therebyaddinginsecurefeaturesoraccessingsharedcontentwithsignature-basedpermissions). Thetrustthatauser placesinanappanditsdevelopersisbasedtotallyonsuchcertificates;certificateprotectionandsecuremanagement are therefore vital for reputation and customer retention, and secret keys must never be shared with other individuals. Keysarestoredinabinaryfilethatcanbeprotectedwithapassword;suchfilesarereferredtoasKeyStores. KeyStore passwordsshouldbestrongandknownonlytothekeycreator. Forthisreason,keysareusuallystoredonadedicated 106\\nbuild machine that developers have limited access to. An Android certificate must have a validity period that’s longer thanthatoftheassociatedapp(includingupdatedversionsoftheapp). Forexample,GooglePlaywillrequirecertificates toremainvaliduntilOct22nd,2033atleast. Signing an Application The goal of the signing process is to associate the app file (.apk) with the developer’s public key. To achieve this, the developercalculatesahashoftheAPKfileandencryptsitwiththeirownprivatekey. Thirdpartiescanthenverifythe app’sauthenticity(e.g.,thefactthattheappreallycomesfromtheuserwhoclaimstobetheoriginator)bydecrypting theencryptedhashwiththeauthor’spublickeyandverifyingthatitmatchestheactualhashoftheAPKfile. Many Integrated Development Environments(IDE) integrate the app signing process to makeit easier for the user. Be awarethatsomeIDEsstoreprivatekeysincleartextinconfigurationfiles;double-checkthisincaseothersareableto accesssuchfilesandremovetheinformationifnecessary. Appscanbesignedfromthecommandlinewiththe‘apksigner’ toolprovidedbytheAndroidSDK(APIlevel24andhigher). Itislocatedat[SDK-Path]/build-tools/[version]. ForAPI 24.0.2andbelow,youcanuse‘jarsigner’,whichispartoftheJavaJDK.Detailsaboutthewholeprocesscanbefoundin officialAndroiddocumentation;however,anexampleisgivenbelowtoillustratethepoint. apksignersign --out mySignedApp.apk --ks myKeyStore.jksmyUnsignedApp.apk Inthisexample,anunsignedapp(‘myUnsignedApp.apk’)willbesignedwithaprivatekeyfromthedeveloperKeyStore ‘myKeyStore.jks’(locatedinthecurrentdirectory). Theappwillbecomeasignedappcalled‘mySignedApp.apk’andwill bereadytoreleasetostores. Zipalign ThezipaligntoolshouldalwaysbeusedtoaligntheAPKfilebeforedistribution. Thistoolalignsalluncompresseddata (suchasimages,rawfiles,and4-byteboundaries)withintheAPK,whichhelpsimprovememorymanagementduringapp runtime. ZipalignmustbeusedbeforetheAPKfileissignedwithapksigner. Publishing Process Distributing apps from anywhere (your own site, any store, etc.) is possible because the Android ecosystem is open. However,GooglePlayisthemostwell-known,trusted,andpopularstore,andGoogleitselfprovidesit. AmazonAppstore is the trusted default store for Kindle devices. If users want to install third-party apps from a non-trusted source, they mustexplicitlyallowthiswiththeirdevicesecuritysettings. Apps can be installed on an Android device from a variety of sources: locally via USB, via Google’s official app store (GooglePlayStore)orfromalternativestores. Whereas other vendors may review and approve apps before they are actually published, Google will simply scan for known malware signatures; this minimizes the time between the beginning of the publishing process and public app availability. Publishing an app is quite straightforward;", "metadata": {"doc_id": "OWASP_MASTG", "chunk_id": 60}}