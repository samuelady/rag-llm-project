{"text": "thandeviceB.ThesedifferentialprivilegesshouldnotchangewhenanappiscopiedfromdeviceAtodeviceB. Beforewedescribetheusableidentifiers,let’squicklydiscusshowtheycanbeusedforbinding. Therearethreemethods thatallowdevicebinding: • Augmentingthecredentialsusedforauthenticationwithdeviceidentifiers. Thismakesenseiftheapplicationneeds tore-authenticateitselfand/ortheuserfrequently. • Encryptingthedatastoredinthedevicewiththekeymaterialwhichisstronglyboundtothedevicecanstrengthen the device binding. The Android Keystore offers non-exportable private keys which we can use for this. When a maliciousactorwouldextractsuchdatafromadevice,itwouldn’tbepossibletodecryptthedata,asthekeyisnot accessible. Implementingthis,takesthefollowingsteps: – GeneratethekeypairintheAndroidKeystoreusingKeyGenParameterSpecAPI. //Source:<https://developer.android.com/reference/android/security/keystore/KeyGenParameterSpec.html> KeyPairGeneratorkeyPairGenerator =KeyPairGenerator.getInstance( KeyProperties.KEY_ALGORITHM_RSA,\"AndroidKeyStore\"); keyPairGenerator.initialize( newKeyGenParameterSpec.Builder( \"key1\", KeyProperties.PURPOSE_DECRYPT) .setDigests(KeyProperties.DIGEST_SHA256,KeyProperties.DIGEST_SHA512) .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_RSA_OAEP) .build()); KeyPairkeyPair =keyPairGenerator.generateKeyPair(); Ciphercipher =Cipher.getInstance(\"RSA/ECB/OAEPWithSHA-256AndMGF1Padding\"); cipher.init(Cipher.DECRYPT_MODE,keyPair.getPrivate()); ... //ThekeypaircanalsobeobtainedfromtheAndroidKeystoreanytimeasfollows: KeyStorekeyStore =KeyStore.getInstance(\"AndroidKeyStore\"); keyStore.load(null); PrivateKeyprivateKey =(PrivateKey)keyStore.getKey(\"key1\",null); PublicKeypublicKey =keyStore.getCertificate(\"key1\").getPublicKey(); – GeneratingasecretkeyforAES-GCM: //Source:<https://developer.android.com/reference/android/security/keystore/KeyGenParameterSpec.html> KeyGeneratorkeyGenerator = KeyGenerator.getInstance( KeyProperties.KEY_ALGORITHM_AES,\"AndroidKeyStore\"); keyGenerator.init( newKeyGenParameterSpec.Builder(\"key2\", KeyProperties.PURPOSE_ENCRYPT |KeyProperties.PURPOSE_DECRYPT) .setBlockModes(KeyProperties.BLOCK_MODE_GCM) .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE) 316\\n.build()); SecretKeykey =keyGenerator.generateKey(); //ThekeycanalsobeobtainedfromtheAndroidKeystoreanytimeasfollows: KeyStorekeyStore =KeyStore.getInstance(\"AndroidKeyStore\"); keyStore.load(null); key=(SecretKey)keyStore.getKey(\"key2\",null); – Encrypttheauthenticationdataandothersensitivedatastoredbytheapplicationusingasecretkeythrough AES-GCMcipherandusedevicespecificparameterssuchasInstanceID,etc. asassociateddata: Ciphercipher =Cipher.getInstance(\"AES/GCM/NoPadding\"); final byte[]nonce =newbyte[GCM_NONCE_LENGTH]; random.nextBytes(nonce); GCMParameterSpecspec =new GCMParameterSpec(GCM_TAG_LENGTH *8,nonce); cipher.init(Cipher.ENCRYPT_MODE,key,spec); byte[]aad=\"<deviceidentifierhere>\".getBytes();; cipher.updateAAD(aad); cipher.init(Cipher.ENCRYPT_MODE,key); //usetheciphertoencrypttheauthenticationdatasee0x50eformoredetails. – EncryptthesecretkeyusingthepublickeystoredinAndroidKeystoreandstoretheencryptedsecretkeyin theprivatestorageoftheapplication. – Wheneverauthenticationdatasuchasaccesstokensorothersensitivedataisrequired,decryptthesecretkey usingprivatekeystoredinAndroidKeystoreandthenusethedecryptedsecretkeytodecrypttheciphertext. • Usetoken-baseddeviceauthentication(InstanceID)tomakesurethatthesameinstanceoftheappisused. Testing whether the App is Debuggable Platform: android MASVSV1: MSTG-CODE-2 MASVSV2: MASVS-RESILIENCE-4 Overview Static Analysis Check AndroidManifest.xml to determine whether the android:debuggable attribute has been set and to find the attribute’svalue: ... <application android:allowBackup=\"true\" android:debuggable=\"true\" android:icon=\"@drawable/ic_launcher\" android:label=\"@string/app_name\" ↪ android:theme=\"@style/AppTheme\"> ... You can use aapt tool from the Android SDK with the following command line to quickly check if the an- droid:debuggable=\"true\"directiveispresent: ##Ifthecommandprint1thenthedirectiveispresent ##Theregexsearchforthisline:android:debuggable(0x0101000f)=(type0x12)0xffffffff $aaptdxmltreesieve.apkAndroidManifest.xml |grep -Ec\"android:debuggable\\(0x[0-9a-f]+\\)=\\(type\\s0x[0-9a-f]+\\)0xffffffff\" 1 Forareleasebuild,thisattributeshouldalwaysbesetto\"false\"(thedefaultvalue). Dynamic Analysis adbcanbeusedtodeterminewhetheranapplicationisdebuggable. Usethefollowingcommand: 317\\n##Ifthecommandprintanumbersuperiortozerothentheapplicationhavethedebugflag ##Theregexsearchfortheselines: ##flags=[DEBUGGABLEHAS_CODEALLOW_CLEAR_USER_DATAALLOW_BACKUP] ##pkgFlags=[DEBUGGABLEHAS_CODEALLOW_CLEAR_USER_DATAALLOW_BACKUP] $adbshelldumpsyspackagecom.mwr.example.sieve |grep -c\"DEBUGGABLE\" 2 $adbshelldumpsyspackagecom.nondebuggableapp |grep -c\"DEBUGGABLE\" 0 Ifanapplicationisdebuggable,executingapplicationcommandsistrivial. Intheadbshell,executerun-asbyappending thepackagenameandapplicationcommandtothebinaryname: $run-ascom.vulnerable.appid uid=10084(u0_a84)gid=10084(u0_a84) ↪ groups=10083(u0_a83),1004(input),1007(log),1011(adb),1015(sdcard_rw),1028(sdcard_r),3001(net_bt_admin),3002(net_bt),3003(inet),3006(net_bw_stats) ↪ context=u:r:untrusted_app:s0:c512,c768 AndroidStudiocanalsobeusedtodebuganapplicationandverifydebuggingactivationforanapp. Anothermethodfordeterminingwhetheranapplicationisdebuggableisattachingjdbtotherunningprocess. Ifthisis successful,debuggingwillbeactivated. Thefollowingprocedurecanbeusedtostartadebugsessionwithjdb: 1. Usingadbandjdwp,identifythePIDoftheactiveapplicationthatyouwanttodebug: $adb jdwp 2355 16346 <==last launched,correspondstoourapplication 2. Createacommunicationchannelbyusingadbbetweentheapplicationprocess(withthePID)andyourhostcom- puterbyusingaspecificlocalport: #adb forwardtcp:[LOCAL_PORT]jdwp:[APPLICATION_PID] $adb forwardtcp:55555jdwp:16346 3. Usingjdb,attachthedebuggertothelocalcommunicationchannelportandstartadebugsession: $jdb -connect com.sun.jdi.SocketAttach:hostname=localhost,port=55555 Setuncaught java.lang.Throwable Setdeferred uncaughtjava.lang.Throwable Initializingjdb ... >help Afewnotesaboutdebugging: • ThetoolJADXcanbeusedtoidentifyinterestinglocationsforbreakpointinsertion. • UsageofbasiccommandsforjdbcanbefoundatTutorialspoint. • Ifyougetanerrortellingthat“theconnectiontothedebuggerhasbeenclosed”whilejdbisbeingboundtothe localcommunicationchannelport,killalladbsessionsandstartasinglenewsession. Testing Reverse Engineering Tools Detection Platform: android MASVSV1: MSTG-RESILIENCE-4 MASVSV2: MASVS-RESILIENCE-4 Effectiveness Assessment Launchtheappwithvariousreverseengineeringtoolsandframeworksinstalledinyourtestdevice. Includeatleastthe following: Frida,Xposed,SubstrateforAndroid,RootCloak,AndroidSSLTrustKiller. Theappshouldrespondinsomewaytothepresenceofthosetools. Forexampleby: • Alertingtheuserandaskingforacceptingliability. 318\\n• Preventingexecutionbygracefullyterminating. • Securelywipinganysensitivedatastoredonthedevice. • Reportingtoabackendserver,e.g,forfrauddetection. Next,workonbypassingthedetectionofthereverseengineeringtoolsandanswerthefollowingquestions: • Canthemechanismsbebypassedtrivially(e.g.,byhookingasingleAPIfunction)? • Howdifficultisidentifyingtheantireverseengineeringcodeviastaticanddynamicanalysis? • Didyouneedtowritecustomcodetodisablethedefenses? Howmuchtimedidyouneed? • Whatisyourassessmentofthedifficultyofbypassingthemechanisms? Thefollowingstepsshouldguideyouwhenbypassingdetectionofreverseengineeringtools: 1. Patchtheantireverseengineeringfunctionality. Disabletheunwantedbehaviorbysimplyoverwritingtheassoci- atedbytecodeornativecodewithNOPinstructions. 2. UseFridaorXposedtohookfilesystemAPIsontheJavaandnativelayers. Returnahandletotheoriginalfile,not themodifiedfile. 3. Use a kernel module to intercept file-related system calls. When the process attempts to open the modified file, returnafiledescriptorfortheunmodifiedversionofthefile. Refertothe“TamperingandReverseEngineeringonAndroid”chapterforexamplesofpatching,codeinjection,andkernel modules. Testing Root Detection Platform: android MASVSV1: MSTG-RESILIENCE-1 MASVSV2: MASVS-RESILIENCE-1 Bypassing Root Detection Run execution traces with jdb, DDMS, strace, and/or kernel modules to find out what the app is doing. You’ll usually see all kinds of suspect interactions with the operating system, such as opening su for reading and obtaining a list of processes. Theseinteractionsaresurefiresignsofrootdetection. Identifyanddeactivatetherootdetectionmechanisms, oneatatime. Ifyou’reperformingablackboxresilienceassessment,disablingtherootdetectionmechanismsisyour firststep. Tobypassthesechecks,youcanuseseveraltechniques,mostofwhichwereintroducedinthe“ReverseEngineeringand Tampering”chapter: • Renamingbinaries. Forexample,insomecasessimplyrenamingthesubinaryisenoughtodefeatrootdetection (trynottobreakyourenvironmentthough!). • Unmounting/proctopreventreadingofprocesslists. Sometimes,theunavailabilityof/procisenoughtobypass suchchecks. • UsingFridaorXposedtohookAPIsontheJavaandnativelayers. Thishidesfilesandprocesses,hidesthecontents offiles,andreturnsallkindsofbogusvaluesthattheapprequests. • Hookinglow-levelAPIsbyusingkernelmodules. • Patchingtheapptoremovethechecks. Effectiveness Assessment Checkforrootdetectionmechanisms,includingthefollowingcriteria: • Multiple detection methods are scattered throughout the app (as opposed to putting everything into a single method). • TherootdetectionmechanismsoperateonmultipleAPIlayers(JavaAPIs,nativelibraryfunctions,assembler/system calls). 319\\n• Themechanismsaresomehoworiginal(they’renotcopiedandpastedfromStackOverfloworothersources). Developbypassmethodsfortherootdetectionmechanismsandanswerthefollowingquestions: • Canthemechanismsbeeasilybypassedwithstandardtools,suchasRootCloak? • Isstatic/dynamicanalysisnecessarytohandletherootdetection? • Doyouneedtowritecustomcode? • Howlongdidsuccessfullybypassingthemechanismstake? • Whatisyourassessmentofthedifficultyofbypassingthemechanisms? Ifrootdetectionismissingortooeasilybypassed,makesuggestionsinlinewiththeeffectivenesscriterialistedabove. These suggestions may include more detection mechanisms and better integration of existing mechanisms with other defenses. Testing File Integrity Checks Platform: android MASVSV1: MSTG-RESILIENCE-3 MASVSV2: MASVS-RESILIENCE-2 Bypassing File Integrity Checks Bypassing the application-source integrity checks 1. Patchtheanti-debuggingfunctionality. Disabletheunwantedbehaviorbysimplyoverwritingtheassociatedbyte- codeornativecodewithNOPinstructions. 2. Use Frida or Xposed to hook file system APIs on the Java and native layers. Return a handle to the original file insteadofthemodifiedfile. 3. Usethekernelmoduletointerceptfile-relatedsystemcalls. Whentheprocessattemptstoopenthemodifiedfile, returnafiledescriptorfortheunmodifiedversionofthefile. Refertothe“TamperingandReverseEngineeringonAndroid”chapterforexamplesofpatching,codeinjection,andkernel modules. Bypassing the storage integrity checks 1. Retrievethedatafromthedevice. 2. Altertheretrieveddataandthenputitbackintostorage.", "metadata": {"doc_id": "OWASP_MASTG", "chunk_id": 117}}