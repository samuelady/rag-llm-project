{"text": "Alternatively, if the attestation chain has any other root certificate, then Google does not make any claims about the security of the hardware. Althoughthekeyattestationprocesscanbeimplementedwithintheapplicationdirectly,itisrecommendedthatitshould beimplementedattheserver-sideforsecurityreasons. Thefollowingarethehigh-levelguidelinesforthesecureimple- mentationofKeyAttestation: • TheservershouldinitiatethekeyattestationprocessbycreatingarandomnumbersecurelyusingCSPRNG(Cryp- tographicallySecureRandomNumberGenerator)andthesameshouldbesenttotheuserasachallenge. • TheclientshouldcallthesetAttestationChallengeAPIwiththechallengereceivedfromtheserverandshould thenretrievetheattestationcertificatechainusingtheKeyStore.getCertificateChainmethod. • Theattestationresponseshouldbesenttotheserverfortheverificationandfollowingchecksshouldbeperformed fortheverificationofthekeyattestationresponse: – Verifythecertificatechain,uptotherootandperformcertificatesanitycheckssuchasvalidity,integrityand trustworthiness. ChecktheCertificateRevocationStatusListmaintainedbyGoogle,ifnoneofthecertificates inthechainwasrevoked. – CheckiftherootcertificateissignedwiththeGoogleattestationrootkeywhichmakestheattestationprocess trustworthy. – Extract the attestation certificate extension data, which appears within the first element of the certificate chain,andperformthefollowingchecks: ∗ Verifythattheattestationchallengeishavingthesamevaluewhichwasgeneratedattheserverwhile initiatingtheattestationprocess. ∗ Verifythesignatureinthekeyattestationresponse. ∗ VerifythesecurityleveloftheKeymaster,todetermineifthedevicehassecurekeystoragemechanism. Keymaster is a piece of software that runs in the security context and provides all the secure keystore operations. ThesecuritylevelwillbeoneofSoftware, TrustedEnvironmentorStrongBox. Theclient supports hardware-level key attestation if the security level is TrustedEnvironment or StrongBox and theattestationcertificatechaincontainsarootcertificatesignedwiththeGoogleattestationrootkey. ∗ Verifytheclient’sstatustoensureafullchainoftrust-verifiedbootkey,lockedbootloaderandverified bootstate. ∗ Additionally,youcanverifythekeypair’sattributessuchaspurpose,accesstime,authenticationrequire- ment,etc. Note,ifforanyreasonthatprocessfails,itmeansthatthekeyisnotinsecurityhardware. Thatdoesnotmeanthat thekeyiscompromised. ThetypicalexampleofAndroidKeystoreattestationresponselookslikethis: { \"fmt\":\"android-key\", \"authData\":\"9569088f1ecee3232954035dbd10d7cae391305a2751b559bb8fd7cbb229bd...\", \"attStmt\":{ \"alg\":-7, \"sig\":\"304402202ca7a8cfb6299c4a073e7e022c57082a46c657e9e53...\", \"x5c\":[ \"308202ca30820270a003020102020101300a06082a8648ce3d040302308188310b30090603550406130...\", \"308202783082021ea00302010202021001300a06082a8648ce3d040302308198310b300906035504061...\", \"3082028b30820232a003020102020900a2059ed10e435b57300a06082a8648ce3d040302308198310b3...\" ] } } IntheaboveJSONsnippet,thekeyshavethefollowingmeaning: • fmt: Attestationstatementformatidentifier 195\\n• authData: Itdenotestheauthenticatordatafortheattestation • alg: ThealgorithmthatisusedfortheSignature • sig: Signature • x5c: Attestationcertificatechain Note: The sig is generated by concatenating authData and clientDataHash (challenge sent by the server) and signingthroughthecredentialprivatekeyusingthealgsigningalgorithm. Thesameisverifiedattheserver-side byusingthepublickeyinthefirstcertificate. Formoreunderstandingontheimplementationguidelines,youcanrefertoGoogleSampleCode. For the security analysis perspective, the analysts may perform the following checks for the secure implementation of KeyAttestation: • Checkifthekeyattestationistotallyimplementedontheclient-side. Inwhichcase,itcanbemoreeasilybypassed bytamperingtheapplication,methodhooking,etc. • Checkiftheserverusesrandomchallengewhileinitiatingthekeyattestation. Asfailingtodothatwouldleadto insecureimplementationthusmakingitvulnerabletoreplayattacks. Also,checkspertainingtotherandomnessof thechallengeshouldbeperformed. • Checkiftheserververifiestheintegrityofthekeyattestationresponse. • Check if the server performs basic checks such as integrity verification, trust verification, validity, etc. on the certificatesinthechain. Secure Key Import into Keystore Android 9 (API level 28) adds the ability to import keys securely into the AndroidKeystore. First, AndroidKeystore generatesakeypairusingPURPOSE_WRAP_KEY,whichshouldalsobeprotectedwithanattestationcertificate. Thispair aims to protect the Keys being imported to AndroidKeystore. The encrypted keys are generated as ASN.1-encoded message in the SecureKeyWrapper format, which also contains a description of the ways the imported key is allowed to be used. The keys are then decrypted inside the AndroidKeystore hardware belonging to the specific device that generatedthewrappingkey,sothattheyneverappearasplaintextinthedevice’shostmemory. 196\\nFigure 2: Secure key import into Keystore ExampleinJava: KeyDescription ::=SEQUENCE { keyFormatINTEGER, authorizationListAuthorizationList } SecureKeyWrapper ::=SEQUENCE { wrapperFormatVersionINTEGER, encryptedTransportKeyOCTET_STRING, initializationVectorOCTET_STRING, keyDescriptionKeyDescription, secureKeyOCTET_STRING, tagOCTET_STRING } ThecodeabovepresentsthedifferentparameterstobesetwhengeneratingtheencryptedkeysintheSecureKeyWrapper format. ChecktheAndroiddocumentationonWrappedKeyEntryformoredetails. WhendefiningtheKeyDescriptionAuthorizationList,thefollowingparameterswillaffecttheencryptedkeyssecurity: • Thealgorithmparameterspecifiesthecryptographicalgorithmwithwhichthekeyisused • ThekeySizeparameterspecifiesthesize,inbits,ofthekey,measuringinthenormalwayforthekey’salgorithm • Thedigestparameterspecifiesthedigestalgorithmsthatmaybeusedwiththekeytoperformsigningandverifi- cationoperations 197\\nOlder KeyStore Implementations OlderAndroidversions don’t includeKeyStore, but theydoincludethe KeyStoreinterface fromJCA(Java Cryptography Architecture). YoucanuseKeyStoresthatimplementthisinterfacetoensurethesecrecyandintegrityofkeysstoredwith KeyStore;BouncyCastleKeyStore(BKS)isrecommended. Allimplementationsarebasedonthefactthatfilesarestored onthefilesystem;allfilesarepassword-protected. Tocreateone,usetheKeyStore.getInstance(\"BKS\",\"BC\")method, where “BKS” is the KeyStore name (BouncyCastle Keystore) and “BC” is the provider (BouncyCastle). You can also use SpongyCastleasawrapperandinitializetheKeyStoreasfollows: KeyStore.getInstance(\"BKS\", \"SC\"). BeawarethatnotallKeyStoresproperlyprotectthekeysstoredintheKeyStorefiles. Storing a Cryptographic Key: Techniques TomitigateunauthorizeduseofkeysontheAndroiddevice,AndroidKeyStoreletsappsspecifyauthorizedusesoftheir keyswhengeneratingorimportingthekeys. Oncemade,authorizationscannotbechanged. StoringaKey-frommostsecuretoleastsecure: • thekeyisstoredinhardware-backedAndroidKeyStore • allkeysarestoredonserverandareavailableafterstrongauthentication • themasterkeyisstoredontheserverandusedtoencryptotherkeys,whicharestoredinAndroidSharedPreferences • thekeyisderivedeachtimefromastronguserprovidedpassphrasewithsufficientlengthandsalt • thekeyisstoredinthesoftwareimplementationofAndroidKeyStore • themasterkeyisstoredinthesoftwareimplementationofAndroidKeystoreandusedtoencryptotherkeys,which arestoredinSharedPreferences • [notrecommended]allkeysarestoredinSharedPreferences • [notrecommended]hardcodedencryptionkeysinthesourcecode • [notrecommended]predictableobfuscationfunctionorkeyderivationfunctionbasedonstableattributes • [notrecommended]storedgeneratedkeysinpublicplaces(like/sdcard/) Storing Keys Using Hardware-backed Android KeyStore You can use the hardware-backed Android KeyStore if the device is running Android 7.0 (API level 24) and above with availablehardwarecomponent(TrustedExecutionEnvironment(TEE)oraSecureElement(SE)).Youcanevenverifythat the keys are hardware-backed by using the guidelines provided for the secure implementation of Key Attestation. If a hardwarecomponentisnotavailableand/orsupportforAndroid6.0(APIlevel23)andbelowisrequired,thenyoumight wanttostoreyourkeysonaremoteserverandmakethemavailableafterauthentication. Storing Keys on the Server Itispossibletosecurelystorekeysonakeymanagementserver,howevertheappneedstobeonlinetodecryptthedata. Thismightbealimitationforcertainmobileappusecasesandshouldbecarefullythoughtthrough,asthisbecomespart ofthearchitectureoftheappandmighthighlyimpactusability. Deriving Keys from User Input Derivingakeyfromauserprovidedpassphraseisacommonsolution(dependingonwhichAndroidAPIlevelyouuse), butitalsoimpactsusability,mightaffecttheattacksurfaceandcouldintroduceadditionalweaknesses. Eachtimetheapplicationneedstoperformacryptographicoperation,theuser’spassphraseisneeded. Eithertheuser ispromptedforiteverytime, whichisn’tanidealuserexperience,orthepassphraseiskeptinmemoryaslongasthe userisauthenticated. Keepingthepassphraseinmemoryisnotabest-practice,asanycryptographicmaterialmustonly bekeptinmemorywhileitisbeingused. Zeroingoutakeyisoftenaverychallengingtaskasexplainedin“Cleaningout KeyMaterial”. Additionally,considerthatkeysderivedfromapassphrasehavetheirownweaknesses. Forinstance,thepasswordsor passphrases might be reused by the user or easy to guess. Please refer to the Testing Cryptography chapter for more information. 198\\nCleaning out Key Material The key material should be cleared out from memory", "metadata": {"doc_id": "OWASP_MASTG", "chunk_id": 82}}