{"text": "){ gDvm.methDalvikDdmcServer_dispatch =NULL; } YoucandisabledebuggingbyusingsimilartechniquesinARTeventhoughthegDvmvariableisnotavailable. TheART runtime exports some of the vtables of JDWP-related classes as global symbols (in C++, vtables are tables that hold pointerstoclassmethods). ThisincludesthevtablesoftheclassesJdwpSocketStateandJdwpAdbState,whichhandle JDWPconnectionsvianetworksocketsandADB,respectively. Youcanmanipulatethebehaviorofthedebuggingruntime byoverwritingthemethodpointersintheassociatedvtables(archived). OnewaytooverwritethemethodpointersistooverwritetheaddressofthefunctionjdwpAdbState::ProcessIncoming withtheaddressofJdwpAdbState::Shutdown. Thiswillcausethedebuggertodisconnectimmediately. #include <jni.h> #include <string> #include <android/log.h> #include <dlfcn.h> #include <sys/mman.h> #include <jdwp/jdwp.h> #definelog(FMT,...) __android_log_print(ANDROID_LOG_VERBOSE,\"JDWPFun\",FMT,##__VA_ARGS__) //Vtablestructure.Justtomakemessingaroundwithitmoreintuitive struct VT_JdwpAdbState { unsigned long x; unsigned long y; void *JdwpSocketState_destructor; void *_JdwpSocketState_destructor; void *Accept; void *showmanyc; void *ShutDown; void *ProcessIncoming; }; extern \"C\" JNIEXPORT void JNICALLJava_sg_vantagepoint_jdwptest_MainActivity_JDWPfun( JNIEnv *env, jobject /*this*/){ void*lib=dlopen(\"libart.so\",RTLD_NOW); if(lib==NULL){ log(\"Errorloadinglibart.so\"); dlerror(); }else{ struct VT_JdwpAdbState *vtable =(struct VT_JdwpAdbState *)dlsym(lib,\"_ZTVN3art4JDWP12JdwpAdbStateE\"); if(vtable ==0){ log(\"Couldn'tresolvesymbol'_ZTVN3art4JDWP12JdwpAdbStateE'.\\n\"); }else { log(\"VtableforJdwpAdbStateat: %08x\\n\",vtable); //Letthefunbegin! unsigned long pagesize =sysconf(_SC_PAGE_SIZE); 306\\nunsigned long page =(unsigned long)vtable & ~(pagesize-1); mprotect((void *)page,pagesize,PROT_READ |PROT_WRITE); vtable->ProcessIncoming =vtable->ShutDown; //Resetpermissions&flushcache mprotect((void *)page,pagesize,PROT_READ); } } } Traditional Anti-Debugging OnLinux,theptracesystemcallisusedtoobserveandcontroltheexecutionofaprocess(thetracee)andtoexamineand changethatprocess’memoryandregisters. ptraceistheprimarywaytoimplementsystemcalltracingandbreakpoint debugging in native code. Most JDWP anti-debugging tricks (which may be safe for timer-based checks) won’t catch classicaldebuggersbasedonptraceandtherefore,manyAndroidanti-debuggingtricksincludeptrace,oftenexploiting thefactthatonlyonedebuggeratatimecanattachtoaprocess. Checking TracerPid When you debug an app and set a breakpoint on native code, Android Studio will copy the needed files to the target deviceandstartthelldb-serverwhichwilluseptracetoattachtotheprocess. Fromthismomenton,ifyouinspectthe statusfileofthedebuggedprocess(/proc/<pid>/statusor/proc/self/status),youwillseethatthe“TracerPid”field hasavaluedifferentfrom0,whichisasignofdebugging. Remember that this only applies to native code. If you’re debugging a Java/Kotlin-only app the value of the “TracerPid”fieldshouldbe0. ThistechniqueisusuallyappliedwithintheJNInativelibrariesinC,asshowninGoogle’sgperftools(GooglePerformance Tools))HeapCheckerimplementationoftheIsDebuggerAttachedmethod. However,ifyouprefertoincludethischeckas partofyourJava/KotlincodeyoucanrefertothisJavaimplementationofthehasTracerPidmethodfromTimStrazzere’s Anti-Emulatorproject. Whentryingtoimplementsuchamethodyourself,youcanmanuallycheckthevalueofTracerPidwithADB.Thefollow- inglistingusesGoogle’sNDKsampleapphello-jni(com.example.hellojni)toperformthecheckafterattachingAndroid Studio’sdebugger: $adbshellps -A|grep com.example.hellojni u0_a271 11657 5734302108 50600ptrace_stop 0tcom.example.hellojni $adbshellcat/proc/11657/status |grep -e\"^TracerPid:\" |sed\"s/^TracerPid:\\t//\" TracerPid: 11839 $adbshellps -A|grep 11839 u0_a271 1183911837 14024 4548poll_schedule_timeout0Slldb-server Youcanseehowthestatusfileofcom.example.hellojni(PID=11657)containsaTracerPIDof11839,whichwecanidentify asthelldb-serverprocess. Using Fork and ptrace Youcanpreventdebuggingofaprocessbyforkingachildprocessandattachingittotheparentasadebuggerviacode similartothefollowingsimpleexamplecode: void fork_and_attach() { intpid=fork(); if(pid==0) { intppid =getppid(); if(ptrace(PTRACE_ATTACH,ppid,NULL,NULL)==0) { waitpid(ppid,NULL,0); 307\\n/*Continuetheparentprocess*/ ptrace(PTRACE_CONT,NULL,NULL); } } } Withthechildattached,furtherattemptstoattachtotheparentwillfail. Wecanverifythisbycompilingthecodeintoa JNIfunctionandpackingitintoanappwerunonthedevice. root@android:/ #ps|grep-ianti u0_a151 18190201 153584454908ffffffffb6e0f124Ssg.vantagepoint.antidebug u0_a151 1822418190149518035824c019a3acb6e0ee5cSsg.vantagepoint.antidebug Attemptingtoattachtotheparentprocesswithgdbserverfailswithanerror: root@android:/ #./gdbserver--attachlocalhost:1234518190 warning:process18190isalreadytracedbyprocess18224 Cannotattachtolwp18190:Operationnotpermitted (1) Exiting Youcaneasilybypassthisfailure,however,bykillingthechildand“freeing”theparentfrombeingtraced. You’lltherefore usually find more elaborate schemes, involving multiple processes and threads as well as some form of monitoring to impedetampering. Commonmethodsinclude • forkingmultipleprocessesthattraceoneanother, • keepingtrackofrunningprocessestomakesurethechildrenstayalive, • monitoringvaluesinthe/procfilesystem,suchasTracerPIDin/proc/pid/status. Let’slookatasimpleimprovementforthemethodabove. Aftertheinitialfork,welaunchintheparentanextrathread that continually monitors the child’s status. Depending on whether the app has been built in debug or release mode (which is indicated by the android:debuggable flag in the manifest), the child process should do one of the following things: • In release mode: The call to ptrace fails and the child crashes immediately with a segmentation fault (exit code 11). • In debug mode: The call to ptrace works and the child should run indefinitely. Consequently, a call to wait- pid(child_pid)shouldneverreturn. Ifitdoes,somethingisfishyandwewouldkillthewholeprocessgroup. ThefollowingisthecompletecodeforimplementingthisimprovementwithaJNIfunction: #include <jni.h> #include <unistd.h> #include <sys/ptrace.h> #include <sys/wait.h> #include <pthread.h> static intchild_pid; void *monitor_pid(){ intstatus; waitpid(child_pid,&status,0); /*Childstatusshouldneverchange.*/ _exit(0);//Commitseppuku } void anti_debug(){ child_pid =fork(); if(child_pid ==0) { intppid =getppid(); intstatus; if(ptrace(PTRACE_ATTACH,ppid,NULL,NULL)==0) { waitpid(ppid,&status,0); ptrace(PTRACE_CONT,ppid,NULL,NULL); 308\\nwhile (waitpid(ppid,&status,0)){ if(WIFSTOPPED(status)){ ptrace(PTRACE_CONT,ppid,NULL,NULL); }else { //Processhasexited _exit(0); } } } }else { pthread_tt; /*Startthemonitoringthread*/ pthread_create(&t,NULL,monitor_pid,(void *)NULL); } } JNIEXPORT void JNICALL Java_sg_vantagepoint_antidebug_MainActivity_antidebug(JNIEnv *env,jobjectinstance){ anti_debug(); } Again,wepackthisintoanAndroidapptoseeifitworks. Justasbefore,twoprocessesshowupwhenweruntheapp’s debugbuild. root@android:/ #ps|grep-Ianti-debug u0_a152 20267201 155250856796ffffffffb6e0f124Ssg.vantagepoint.anti-debug u0_a152 2030120267149519233980c019a3acb6e0ee5cSsg.vantagepoint.anti-debug However,ifweterminatethechildprocessatthispoint,theparentexitsaswell: root@android:/ #kill-920301 130|root@hammerhead:/ #cd/data/local/tmp root@android:/ #./gdbserver--attachlocalhost:1234520267 gdbserver:unabletoopen/procfile '/proc/20267/status' Cannotattachtolwp20267:Nosuchfileordirectory (2) Exiting Tobypassthis,wemustmodifytheapp’sbehaviorslightly(theeasiestwaystodosoarepatchingthecallto_exitwith NOPsandhookingthefunction_exitinlibc.so). Atthispoint,wehaveenteredtheproverbial“armsrace”: implement- ingmoreintricateformsofthisdefenseaswellasbypassingitarealwayspossible. File Integrity Checks Therearetwotopicsrelatedtofileintegrity: 1. Codeintegritychecks: Inthe“TamperingandReverseEngineeringonAndroid”chapter,wediscussedAndroid’sAPK codesignaturecheck. Wealsosawthatdeterminedreverseengineerscaneasilybypassthischeckbyre-packaging andre-signinganapp. Tomakethisbypassingprocessmoreinvolved,aprotectionschemecanbeaugmentedwith CRCchecksontheappbytecode,nativelibraries,andimportantdatafiles. Thesecheckscanbeimplementedon boththeJavaandthenativelayer. Theideaistohaveadditionalcontrolsinplacesothattheapponlyrunscorrectly initsunmodifiedstate,evenifthecodesignatureisvalid. 2. Thefilestorageintegritychecks: TheintegrityoffilesthattheapplicationstoresontheSDcardorpublicstorage andtheintegrityofkey-valuepairsthatarestoredinSharedPreferencesshouldbeprotected. Sample Implementation - Application Source Code Integritychecksoftencalculateachecksumorhashoverselectedfiles. Commonlyprotectedfilesinclude • AndroidManifest.xml, • classfiles*.dex, • nativelibraries(*.so). 309\\nThefollowingsampleimplementationfromtheAndroidCrackingblogcalculatesaCRCoverclasses.dexandcompares ittotheexpectedvalue. private void crcTest()throws IOException", "metadata": {"doc_id": "OWASP_MASTG", "chunk_id": 114}}