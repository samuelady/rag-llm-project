{"text": "their enforcement. For example, one check could require that the app run only on Android6.0(APIlevel23)oramorerecentversion,closingtheappordisplayingawarningiftheAndroidversionisless than6.0. Checkthesourcecodeforfunctionsthatimplementthepolicyanddeterminewhetheritcanbebypassed. YoucanimplementchecksontheAndroiddevicebyqueryingSettings.Secureforsystempreferences. DeviceAdminis- trationAPIofferstechniquesforcreatingapplicationsthatcanenforcepasswordpoliciesanddeviceencryption. Dynamic Analysis The dynamic analysis depends on the checks enforced by the app and their expected behavior. If the checks can be bypassed,theymustbevalidated. 218\\nAndroid Cryptographic APIs Overview Inthechapter“MobileAppCryptography”,weintroducedgeneralcryptographybestpracticesanddescribedtypicalissues thatcanoccurwhencryptographyisusedincorrectly. Inthischapter,we’llgointomoredetailonAndroid’scryptography APIs. We’llshowhowtoidentifyusageofthoseAPIsinthesourcecodeandhowtointerpretcryptographicconfigurations. Whenreviewingcode,makesuretocomparethecryptographicparametersusedwiththecurrentbestpractices,aslinked inthisguide. WecanidentifykeycomponentsofcryptographysystemonAndroid: • SecurityProvider • KeyStore-seethesectionKeyStoreinthe“TestingDataStorage”chapter • KeyChain-seethesectionKeyChaininthe“TestingDataStorage”chapter AndroidcryptographyAPIsarebasedontheJavaCryptographyArchitecture(JCA).JCAseparatestheinterfacesandimple- mentation,makingitpossibletoincludeseveralsecurityprovidersthatcanimplementsetsofcryptographicalgorithms. MostoftheJCAinterfacesandclassesaredefinedinthejava.security.*andjavax.crypto.*packages. Inaddition, thereareAndroidspecificpackagesandroid.security.*andandroid.security.keystore.*. KeyStoreandKeyChainprovideAPIsforstoringandusingkeys(behindthescene,KeyChainAPIusesKeyStoresystem). These systems allow to administer the full lifecycle of the cryptographic keys. Requirements and guidance for imple- mentationofcryptographickeymanagementcanbefoundinKeyManagementCheatSheet. Wecanidentifyfollowing phases: • generatingakey • usingakey • storingakey • archivingakey • deletingakey Pleasenotethatstoringofakeyisanalyzedinthechapter“TestingDataStorage”. These phases are managed by the Keystore/KeyChain system. However how the system works depends on how the application developer implemented it. For the analysis process you should focus on functions which are used by the applicationdeveloper. Youshouldidentifyandverifythefollowingfunctions: • Keygeneration • Randomnumbergeneration • Keyrotation AppsthattargetmodernAPIlevels,wentthroughthefollowingchanges: • ForAndroid7.0(APIlevel24)andabovetheAndroidDeveloperblogshowsthat: – Itisrecommendedtostopspecifyingasecurityprovider. Instead,alwaysuseapatchedsecurityprovider. – The support for the Crypto provider has dropped and the provider is deprecated. The same applies to its SHA1PRNGforsecurerandom. • ForAndroid8.1(APIlevel27)andabovetheDeveloperDocumentationshowsthat: – Conscrypt,knownasAndroidOpenSSL,ispreferredaboveusingBouncyCastleandithasnewimplementations: AlgorithmParameters:GCM , KeyGenerator:AES, KeyGenerator:DESEDE, KeyGenerator:HMACMD5, KeyGen- erator:HMACSHA1, KeyGenerator:HMACSHA224, KeyGenerator:HMACSHA256, KeyGenerator:HMACSHA384, KeyGenerator:HMACSHA512,SecretKeyFactory:DESEDE,andSignature:NONEWITHECDSA. – You should not use the IvParameterSpec.class anymore for GCM, but use the GCMParameterSpec.class instead. – SocketshavechangedfromOpenSSLSocketImpltoConscryptFileDescriptorSocket,andConscryptEngi- neSocket. – SSLSessionwithnullparametersgiveaNullPointerException. 219\\n– Youneedtohavelargeenougharraysasinputbytesforgeneratingakeyotherwise,anInvalidKeySpecEx- ceptionisthrown. – IfaSocketreadisinterrupted,yougetaSocketException. • ForAndroid9(APIlevel28)andabovetheAndroidDeveloperBlogshowsevenmorechanges: – YougetawarningifyoustillspecifyasecurityproviderusingthegetInstancemethodandyoutargetany APIbelow28. IfyoutargetAndroid9(APIlevel28)orabove,yougetanerror. – TheCryptosecurityproviderisnowremoved. CallingitwillresultinaNoSuchProviderException. • ForAndroid10(APIlevel29)theDeveloperDocumentationlistsallnetworksecuritychanges. General Recommendations Thefollowinglistofrecommendationsshouldbeconsideredduringappexamination: • Youshouldensurethatthebestpracticesoutlinedinthe“CryptographyforMobileApps”chapterarefollowed. • Youshouldensurethatsecurityproviderhasthelatestupdates-Updatingsecurityprovider. • Youshouldstopspecifyingasecurityproviderandusethedefaultimplementation(AndroidOpenSSL,Conscrypt). • YoushouldstopusingCryptosecurityprovideranditsSHA1PRNGastheyaredeprecated. • YoushouldspecifyasecurityprovideronlyfortheAndroidKeystoresystem. • YoushouldstopusingPassword-basedencryptioncipherswithoutIV. • YoushoulduseKeyGenParameterSpecinsteadofKeyPairGeneratorSpec. Security Provider Androidreliesonthejava.security.ProviderclasstoimplementJavaSecurityservices. Theseprovidersarecrucialto ensuresecurenetworkcommunicationsandsecureotherfunctionalitieswhichdependoncryptography. ThelistofsecurityprovidersincludedinAndroidvariesbetweenversionsofAndroidandtheOEM-specificbuilds. Some securityproviderimplementationsinolderversionsarenowknowntobelesssecureorvulnerable. Thus,Androidappli- cationsshouldnotonlychoosethecorrectalgorithmsandprovideagoodconfiguration,insomecasestheyshouldalso payattentiontothestrengthoftheimplementationsinthelegacysecurityproviders. Youcanlistthesetofexistingsecurityprovidersusingfollowingcode: StringBuilderbuilder =newStringBuilder(); for(Providerprovider :Security.getProviders()){ builder.append(\"provider:\") .append(provider.getName()) .append(\"\") .append(provider.getVersion()) .append(\"(\") .append(provider.getInfo()) .append(\")\\n\"); } Stringproviders =builder.toString(); //nowdisplaythestringonthescreenorinthelogsfordebugging. ThisistheoutputforAndroid9(APIlevel28)runninginanemulatorwithGooglePlayAPIs: provider:AndroidNSSP1.0(AndroidNetworkSecurityPolicyProvider) provider:AndroidOpenSSL1.0(Android'sOpenSSL-backedsecurityprovider) provider:CertPathProvider1.0(ProviderofCertPathBuilderandCertPathVerifier) provider:AndroidKeyStoreBCWorkaround1.0(AndroidKeyStoresecurityprovidertoworkaroundBouncyCastle) provider:BC1.57(BouncyCastleSecurityProviderv1.57) provider:HarmonyJSSE1.0(HarmonyJSSEProvider) provider:AndroidKeyStore1.0(AndroidKeyStoresecurityprovider) Updating security provider Keeping up-to-date and patched component is one of security principles. The same applies to provider. Application shouldcheckifusedsecurityproviderisup-to-dateandifnot,updateit. 220\\nOlder Android versions ForsomeapplicationsthatsupportolderversionsofAndroid(e.g.: onlyusedversionslowerthanAndroid7.0(APIlevel 24)),bundlinganup-to-datelibrarymaybetheonlyoption. Conscryptlibraryisagoodchoiceinthissituationtokeep thecryptographyconsistentacrossthedifferentAPIlevelsandavoidhavingtoimportBouncyCastlewhichisaheavier library. ConscryptforAndroidcanbeimportedthisway: dependencies { implementation 'org.conscrypt:conscrypt-android:last_version' } Next,theprovidermustberegisteredbycalling: Security.addProvider(Conscrypt.newProvider()) Key Generation The Android SDK allows you to specify how a key should be generated, and under which circumstances it can be used. Android6.0(APIlevel23)introducedtheKeyGenParameterSpecclassthatcanbeusedtoensurethecorrectkeyusage intheapplication. Forexample: StringkeyAlias =\"MySecretKey\"; KeyGenParameterSpeckeyGenParameterSpec =newKeyGenParameterSpec.Builder(keyAlias, KeyProperties.PURPOSE_ENCRYPT |KeyProperties.PURPOSE_DECRYPT) .setBlockModes(KeyProperties.BLOCK_MODE_CBC) .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_PKCS7) .setRandomizedEncryptionRequired(true) .build(); KeyGeneratorkeyGenerator =KeyGenerator.getInstance(KeyProperties.KEY_ALGORITHM_AES, \"AndroidKeyStore\"); keyGenerator.init(keyGenParameterSpec); SecretKeysecretKey =keyGenerator.generateKey(); TheKeyGenParameterSpecindicatesthatthekeycanbeusedforencryptionanddecryption,butnotforotherpurposes, suchassigningorverifying. Itfurtherspecifiestheblockmode(CBC),padding(PKCS#7), andexplicitlyspecifiesthat randomizedencryptionisrequired(thisisthedefault). Next,weenterAndroidKeyStoreasthenameoftheproviderin theKeyGenerator.getInstancecalltoensurethatthekeysarestoredintheAndroidKeyStore. GCMisanotherAESblockmodethatprovidesadditionalsecuritybenefitsoverother,oldermodes. Inadditiontobeing cryptographicallymoresecure,italsoprovidesauthentication. WhenusingCBC(andothermodes),authenticationwould needtobeperformedseparately,usingHMACs(seethe“TamperingandReverseEngineeringonAndroid”chapter). Note thatGCMistheonlymodeofAESthatdoesnotsupportpadding. Attemptingtousethegeneratedkeyinviolationoftheabovespecwouldresultinasecurityexception. Here’sanexampleofusingthatkeytoencrypt: StringAES_MODE =KeyProperties.KEY_ALGORITHM_AES +\"/\"+KeyProperties.BLOCK_MODE_CBC +\"/\"+KeyProperties.ENCRYPTION_PADDING_PKCS7; KeyStoreAndroidKeyStore =AndroidKeyStore.getInstance(\"AndroidKeyStore\"); //byte[]input Keykey =AndroidKeyStore.getKey(keyAlias,null); Ciphercipher =Cipher.getInstance(AES_MODE); cipher.init(Cipher.ENCRYPT_MODE,key); byte[]encryptedBytes =cipher.doFinal(input); byte[]iv=cipher.getIV(); //saveboththeIVandtheencryptedBytes BoththeIV(initializationvector)andtheencryptedbytesneedtobestored;otherwisedecryptionisnotpossible. Here’showthatciphertextwouldbedecrypted. Theinputistheencryptedbytearrayandivistheinitializationvector fromtheencryptionstep: 221\\n//byte[]input //byte[]iv Keykey =AndroidKeyStore.getKey(AES_KEY_ALIAS,null); Ciphercipher =Cipher.getInstance(AES_MODE); IvParameterSpecparams =newIvParameterSpec(iv); cipher.init(Cipher.DECRYPT_MODE,key,params); byte[]result =cipher.doFinal(input); SincetheIVisrandomlygeneratedeachtime,itshouldbesavedalongwiththeciphertext(encryptedBytes)inorderto decryptitlater. Prior to Android 6.0 (API level 23), AES key generation was not supported. As a result, many implementations chose to use RSA and generated a public-private key pair for asymmetric encryption using KeyPairGeneratorSpec or used SecureRandomtogenerateAESkeys. Here’sanexampleofKeyPairGeneratorandKeyPairGeneratorSpecusedtocreatetheRSAkeypair: DatestartDate =Calendar.getInstance().getTime(); CalendarendCalendar =Calendar.getInstance(); endCalendar.add(Calendar.YEAR,1); DateendDate =endCalendar.getTime(); KeyPairGeneratorSpeckeyPairGeneratorSpec =newKeyPairGeneratorSpec.Builder(context) .setAlias(RSA_KEY_ALIAS) .setKeySize(4096) .setSubject(newX500Principal(\"CN=\" +RSA_KEY_ALIAS)) .setSerialNumber(BigInteger.ONE) .setStartDate(startDate) .setEndDate(endDate) .build(); KeyPairGeneratorkeyPairGenerator =KeyPairGenerator.getInstance(\"RSA\", \"AndroidKeyStore\"); keyPairGenerator.initialize(keyPairGeneratorSpec); KeyPairkeyPair =keyPairGenerator.generateKeyPair(); This sample creates the RSA key pair with a key size of 4096-bit (i.e. modulus size). Elliptic Curve (EC) keys can also begeneratedinasimilarway. HoweverasofAndroid11(APIlevel30),AndroidKeyStoredoesnotsupportencryptionor decryptionwithECkeys. Theycanonlybeusedforsignatures. AsymmetricencryptionkeycanbegeneratedfromthepassphrasebyusingthePasswordBasedKeyDerivationFunction version 2 (PBKDF2). This cryptographic protocol is designed to generate cryptographic keys, which can be", "metadata": {"doc_id": "OWASP_MASTG", "chunk_id": 89}}