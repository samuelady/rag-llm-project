{"text": "successCallback(message){ alert(message); //Messageisalways:CONNECTION_SECURE. //Nowdosomethingwiththetrustedserver. } function errorCallback(message){ alert(message); if(message ===\"CONNECTION_NOT_SECURE\"){ //Thereislikelyamaninthemiddleattackgoingon,becareful! }else if(message.indexOf(\"CONNECTION_FAILED\")>-1){ //Therewasnoconnection(yet).Internetmaybedown.Tryagain(afewtimes)afteralittletimeout. } } AfterdecompressingtheAPKfile,Cordova/Phonegapfileswillbelocatedinthe/assets/wwwfolder. The‘plugins’folderwill giveyouthevisibilityofthepluginsused. WewillneedtosearchforthismethodsintheJavaScriptcodeoftheapplication toconfirmitsusage. Dynamic Analysis Followtheinstructionsfrom“TestingEndpointIdentifyVerification>DynamicAnalysis”. Ifdoingsodoesn’tleadtotraffic beingproxied,itmaymeanthatcertificatepinningisactuallyimplementedandallsecuritymeasuresareinplace. Does thesamehappenforalldomains? As a quick smoke test, you can try to bypass certificate pinning using objection as described in “Bypassing Certificate Pinning”. PinningrelatedAPIsbeinghookedbyobjectionshouldappearinobjection’soutput. However,keepinmindthat: • theAPIsmightnotbecomplete. • ifnothingishooked,thatdoesn’tnecessarilymeanthattheappdoesn’timplementpinning. Inbothcases,theapporsomeofitscomponentsmightimplementcustompinninginawaythatissupportedbyobjection. Pleasecheckthestaticanalysissectionforspecificpinningindicatorsandmorein-depthtesting. 238\\nTesting Endpoint Identify Verification Platform: android MASVSV1: MSTG-NETWORK-3 MASVSV2: MASVS-NETWORK-1 Overview Static Analysis UsingTLStotransportsensitiveinformationoverthenetworkisessentialforsecurity. However,encryptingcommunication betweenamobileapplicationanditsbackendAPIisnottrivial. Developersoftendecideonsimplerbutlesssecuresolutions (e.g.,thosethatacceptanycertificate)tofacilitatethedevelopmentprocess,andsometimestheseweaksolutionsmake itintotheproductionversion,potentiallyexposinguserstoman-in-the-middleattacks. Twokeyissuesshouldbeaddressed: • Verifythatacertificatecomesfromatrustedsource,i.e.atrustedCA(CertificateAuthority). • Determinewhethertheendpointserverpresentstherightcertificate. Makesurethatthehostnameandthecertificateitselfareverifiedcorrectly. Examplesandcommonpitfallsareavailable intheofficialAndroiddocumentation. SearchthecodeforexamplesofTrustManagerandHostnameVerifierusage. In thesectionsbelow,youcanfindexamplesofthekindofinsecureusagethatyoushouldlookfor. Notethat fromAndroid8.0(API level 26) onward, thereis no supportfor SSLv3 andHttpsURLConnection willno longerperformafallbacktoaninsecureTLS/SSLprotocol. Verifying the Target SDK Version Applications targeting Android 7.0 (API level 24) or higher will use a default Network Security Configuration that doesn’t trust any user supplied CAs, reducing the possibility of MITM attacks by luring users to install malicious CAs. DecodetheappusingapktoolandverifythatthetargetSdkVersioninapktool.ymlisequaltoorhigherthan24. greptargetSdkVersionUnCrackable-Level3/apktool.yml targetSdkVersion:'28' However, even if targetSdkVersion >=24, the developer can disable default protections by using a custom Network Security Configuration defining a custom trust anchor forcing the app to trust user supplied CAs. See “Analyzing CustomTrustAnchors”. Analyzing Custom Trust Anchors Search for the Network Security Configuration file and inspect any custom <trust-anchors> defining <certificates src=\"user\">(whichshouldbeavoided). Youshouldcarefullyanalyzetheprecedenceofentries: • Ifavalueisnotsetina<domain-config>entryorinaparent<domain-config>,theconfigurationsinplacewillbe basedonthe<base-config> • Ifnotdefinedinthisentry,thedefaultconfigurationswillbeused. TakealookatthisexampleofaNetworkSecurityConfigurationforanapptargetingAndroid9(APIlevel28): 239\\n<?xml version=\"1.0\" encoding=\"utf-8\"?> <network-security-config> <domain-config> <domain includeSubdomains=\"false\">owasp.org</domain> <trust-anchors> <certificates src=\"system\" /> <certificates src=\"user\" /> </trust-anchors> </domain-config> </network-security-config> Someobservations: • There’sno<base-config>,meaningthatthedefaultconfigurationforAndroid9(APIlevel28)orhigherwillbeused forallotherconnections(onlysystemCAwillbetrustedinprinciple). • However,the<domain-config>overridesthedefaultconfigurationallowingtheapptotrustbothsystemanduser CAsfortheindicated<domain>(owasp.org). • Thisdoesn’taffectsubdomainsbecauseofincludeSubdomains=\"false\". PuttingalltogetherwecantranslatetheaboveNetworkSecurityConfigurationto: “theapptrustssystemanduserCAs fortheowasp.orgdomain,excludingitssubdomains. ForanyotherdomainstheappwilltrustthesystemCAsonly”. Verifying the Server Certificate TrustManagerisameansofverifyingconditionsnecessaryforestablishingatrustedconnectioninAndroid. Thefollowing conditionsshouldbecheckedatthispoint: • HasthecertificatebeensignedbyatrustedCA? • Hasthecertificateexpired? • Isthecertificateself-signed? Thefollowingcodesnippetissometimesusedduringdevelopmentandwillacceptanycertificate,overwritingthefunctions checkClientTrusted,checkServerTrusted,andgetAcceptedIssuers. Suchimplementationsshouldbeavoided,and, iftheyarenecessary,theyshouldbeclearlyseparatedfromproductionbuildstoavoidbuilt-insecurityflaws. TrustManager[]trustAllCerts =newTrustManager[]{ newX509TrustManager(){ @Override public X509Certificate[]getAcceptedIssuers(){ return newjava.security.cert.X509Certificate[]{}; } @Override public void checkClientTrusted(X509Certificate[]chain,StringauthType) throws CertificateException { } @Override public void checkServerTrusted(X509Certificate[]chain,StringauthType) throws CertificateException { } } }; //SSLContextcontext context.init(null,trustAllCerts,newSecureRandom()); WebView Server Certificate Verification Sometimes applications use a WebView to render the website associated with the application. This is true of HTML/JavaScript-basedframeworkssuchasApacheCordova,whichusesaninternalWebViewforapplicationinteraction. When a WebView is used, the mobile browser performs the server certificate validation. Ignoring any TLS error that occurswhentheWebViewtriestoconnecttotheremotewebsiteisabadpractice. The following code will ignore TLS issues, exactly like the WebViewClient custom implementation provided to the Web- View: 240\\nWebViewmyWebView =(WebView)findViewById(R.id.webview); myWebView.setWebViewClient(newWebViewClient(){ @Override public void onReceivedSslError(WebViewview,SslErrorHandlerhandler,SslErrorerror){ //IgnoreTLScertificateerrorsandinstructtheWebViewClienttoloadthewebsite handler.proceed(); } }); Apache Cordova Certificate Verification ImplementationoftheApacheCordovaframework’sinternalWebViewusagewillignoreTLSerrorsinthemethodonRe- ceivedSslErroriftheflagandroid:debuggableisenabledintheapplicationmanifest. Therefore, makesurethatthe appisnotdebuggable. Seethetestcase“TestingIftheAppisDebuggable”. Hostname Verification Anothersecurityflawinclient-sideTLSimplementationsisthelackofhostnameverification. Developmentenvironments usuallyuseinternaladdressesinsteadofvaliddomainnames,sodevelopersoftendisablehostnameverification(orforce an application to allow any hostname) and simply forget to change it when their application goes to production. The followingcodedisableshostnameverification: final static HostnameVerifierNO_VERIFY =newHostnameVerifier(){ public boolean verify(Stringhostname,SSLSessionsession){ return true; } }; Withabuilt-inHostnameVerifier,acceptinganyhostnameispossible: HostnameVerifierNO_VERIFY =org.apache.http.conn.ssl.SSLSocketFactory .ALLOW_ALL_HOSTNAME_VERIFIER; Makesurethatyourapplicationverifiesahostnamebeforesettingatrustedconnection. Dynamic Analysis WhentestinganapptargetingAndroid7.0(APIlevel24)orhigheritshouldbeeffectivelyapplyingtheNetworkSecurity Configurationandyoushouldn’tabletoseethedecryptedHTTPStrafficatfirst. However, iftheapptargetsAPIlevels below24,theappwillautomaticallyaccepttheinstalledusercertificates. TotestimpropercertificateverificationlaunchaMITMattackusinganinterceptionproxysuchasBurp. Trythefollowing options: • Self-signedcertificate: 1. InBurp,gototheProxytabandselecttheOptionstab. 2. GototheProxyListenerssection,highlightyourlistener,andclickEdit. 3. GototheCertificatetab,checkUseaself-signedcertificate,andclickOk. 4. Runyourapplication. Ifyou’reabletoseeHTTPStraffic,yourapplicationisacceptingself-signedcertificates. • AcceptingcertificateswithanuntrustedCA: 1. InBurp,gototheProxytabandselecttheOptionstab. 2. GototheProxyListenerssection,highlightyourlistener,andclickEdit. 3. GototheCertificatetab,checkGenerateaCA-signedcertificatewithaspecifichostname,andtype inthebackendserver’shostname. 4. Run your application. If you’re able to see HTTPS traffic, your application is accepting certificates with an untrustedCA. • Acceptingincorrecthostnames: 1. InBurp,gototheProxytabandselecttheOptionstab. 241\\n2. GototheProxyListenerssection,highlightyourlistener,andclickEdit. 3. GototheCertificatetab,checkGenerateaCA-signedcertificatewithaspecifichostname,andtype inaninvalidhostname,e.g.,example.org. 4. Runyourapplication. Ifyou’reabletoseeHTTPStraffic,yourapplicationisacceptingallhostnames. Ifyou’restillnotabletoseeanydecryptedHTTPStraffic,yourapplicationmightbeimplementingcertificatepinning. Testing the Security Provider Platform: android MASVSV1: MSTG-NETWORK-6 MASVSV2: MASVS-NETWORK-1 Overview Static Analysis ApplicationsbasedontheAndroidSDKshoulddependonGooglePlayServices. Forexample,inthegradlebuildfile,youwill findcompile'com.google.android.gms:play-services-gcm:x.x.x'inthedependenciesblock. Youneedtomakesure thattheProviderInstallerclassiscalledwitheitherinstallIfNeededorinstallIfNeededAsync. ProviderInstaller needstobecalledbyacomponentoftheapplicationasearlyaspossible. Exceptionsthrownbythesemethodsshould becaughtandhandledcorrectly. Iftheapplicationcannotpatchitssecurityprovider,itcaneitherinformtheAPIofits lesssecurestateorrestrictuseractions(becauseallHTTPStrafficshouldbedeemedriskierinthissituation). Ifyouhaveaccesstothesourcecode, checkiftheapphandleanyexceptionsrelatedtothesecurityproviderupdates properly, and if it reports to the backend when the application is working", "metadata": {"doc_id": "OWASP_MASTG", "chunk_id": 94}}