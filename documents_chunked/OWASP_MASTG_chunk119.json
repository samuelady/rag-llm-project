{"text": "android MASVSV1: MSTG-RESILIENCE-9 MASVSV2: MASVS-RESILIENCE-3 Overview Static Analysis DecompiletheAPKandreviewittodeterminewhetherthecodebasehasbeenobfuscated. Belowyoucanfindasampleforanobfuscatedcodeblock: package com.a.a.a; import com.a.a.b.a; import java.util.List; class a$b extends a { public a$b(ListparamList) { super(paramList); } public boolean areAllItemsEnabled() { return true; } public boolean isEnabled(intparamInt) { return true; } } Herearesomeconsiderations: • Meaningfulidentifiers,suchasclassnames,methodnames,andvariablenames,mighthavebeendiscarded. • Stringresourcesandstringsinbinariesmighthavebeenencrypted. • Codeanddatarelatedtotheprotectedfunctionalitymightbeencrypted,packed,orotherwiseconcealed. Fornativecode: • libcAPIs(e.gopen,read)mighthavebeenreplacedwithOSsyscalls. • Obfuscator-LLVMmighthavebeenappliedtoperform“ControlFlowFlattening”or“BogusControlFlow”. Some of these techniques are discussed and analyzed in the blog post“Security hardening of Android native code” by GautamArvindandinthe“APKiD:FastIdentificationofAppShieldingProducts”presentationbyEduardoNovella. Foramoredetailedassessment,youneedadetailedunderstandingoftherelevantthreatsandtheobfuscationmethods used. ToolssuchasAPKiDmaygiveyouadditionalindicationsaboutwhichtechniqueswereusedforthetargetappsuch asobfuscators,packersandanti-debugmeasures. 324\\nDynamic Analysis YoucanuseAPKiDtodetectiftheapphasbeenobfuscated. ExampleusingtheUnCrackableAppforAndroidLevel4: apkidowasp-mastg/Crackmes/Android/Level_04/r2pay-v1.0.apk [+]APKiD2.1.2::fromRedNaga::rednaga.io [*]owasp-mastg/Crackmes/Android/Level_04/r2pay-v1.0.apk!classes.dex |->anti_vm:Build.TAGScheck,possiblero.securecheck |->compiler:r8 |->obfuscator:unreadablefieldnames,unreadablemethodnames Inthiscaseitdetectsthattheapphasunreadablefieldnamesandmethodnames,amongotherthings. Testing Emulator Detection Platform: android MASVSV1: MSTG-RESILIENCE-5 MASVSV2: MASVS-RESILIENCE-1 Bypassing Emulator Detection 1. Patch the emulator detection functionality. Disable the unwanted behavior by simply overwriting the associated bytecodeornativecodewithNOPinstructions. 2. Use Frida or Xposed APIs to hook file system APIs on the Java and native layers. Return innocent-looking values (preferably taken from a real device) instead of the telltale emulator values. For example, you can override the TelephonyManager.getDeviceIDmethodtoreturnanIMEIvalue. Refertothe“TamperingandReverseEngineeringonAndroid”chapterforexamplesofpatching,codeinjection,andkernel modules. Effectiveness Assessment Installandruntheappintheemulator. Theappshoulddetectthatitisbeingexecutedinanemulatorandterminateor refusetoexecutethefunctionalitythat’smeanttobeprotected. Workonbypassingthedefensesandanswerthefollowingquestions: • Howdifficultisidentifyingtheemulatordetectioncodeviastaticanddynamicanalysis? • Canthedetectionmechanismsbebypassedtrivially(e.g.,byhookingasingleAPIfunction)? • Didyouneedtowritecustomcodetodisabletheanti-emulationfeature(s)? Howmuchtimedidyouneed? • Whatisyourassessmentofthedifficultyofbypassingthemechanisms? Making Sure that the App is Properly Signed Platform: android MASVSV1: MSTG-CODE-1 MASVSV2: MASVS-RESILIENCE-2 325\\nOverview Static Analysis Makesurethatthereleasebuildhasbeensignedviaboththev1andv2schemesforAndroid7.0(APIlevel24)andabove and via all the three schemes for Android 9 (API level 28) and above, and that the code-signing certificate in the APK belongstothedeveloper. APKsignaturescanbeverifiedwiththeapksignertool. Itislocatedat[SDK-Path]/build-tools/[version]. $apksignerverify --verbose Desktop/example.apk Verifies Verifiedusingv1scheme (JARsigning):true Verifiedusingv2scheme (APKSignatureSchemev2):true Verifiedusingv3scheme (APKSignatureSchemev3):true Numberofsigners:1 Thecontentsofthesigningcertificatecanbeexaminedwithjarsigner. NotethattheCommonName(CN)attributeis setto“AndroidDebug”inthedebugcertificate. TheoutputforanAPKsignedwithadebugcertificateisshownbelow: $jarsigner -verify -verbose -certs example.apk sm 11116FriNov1112:07:48ICT2016AndroidManifest.xml X.509,CN=AndroidDebug,O=Android,C=US [certificateisvalidfrom3/24/169:18AMto8/10/439:18AM] [CertPathnotvalidated:Pathdoesn\\'tchainwithanyofthetrustanchors] (...) Ignorethe“CertPathnotvalidated”error. ThiserroroccurswithJavaSDK7andabove. Insteadofjarsigner, youcan relyontheapksignertoverifythecertificatechain. The signing configuration can be managed through Android Studio or the signingConfig block in build.gradle. To activateboththev1andv2schemes,thefollowingvaluesmustbeset: v1SigningEnabledtrue v2SigningEnabledtrue SeveralbestpracticesforconfiguringtheappforreleaseareavailableintheofficialAndroiddeveloperdocumentation. Lastbutnotleast: makesurethattheapplicationisneverdeployedwithyourinternaltestingcertificates. Dynamic Analysis StaticanalysisshouldbeusedtoverifytheAPKsignature. 326\\niOS Platform Overview iOSisamobileoperatingsystemthatpowersApplemobiledevices,includingtheiPhone,iPad,andiPodTouch. Itisalso thebasisforAppletvOS,whichinheritsmanyfunctionalitiesfromiOS.ThissectionintroducestheiOSplatformfroman architecturepointofview. Thefollowingfivekeyareasarediscussed: 1. iOSsecurityarchitecture 2. iOSapplicationstructure 3. Inter-processCommunication(IPC) 4. iOSapplicationpublishing 5. iOSApplicationAttackSurface LiketheAppledesktopoperatingsystemmacOS(formerlyOSX),iOSisbasedonDarwin,anopensourceUnixoperating systemdevelopedbyApple. Darwin’skernelisXNU(“XisNotUnix”),ahybridkernelthatcombinescomponentsofthe MachandFreeBSDkernels. However,iOSappsruninamorerestrictedenvironmentthantheirdesktopcounterpartsdo. iOSappsareisolatedfrom eachotheratthefilesystemlevelandaresignificantlylimitedintermsofsystemAPIaccess. Toprotectusersfrommaliciousapplications, Applerestrictsandcontrolsaccesstotheappsthatareallowedtorunon iOSdevices. Apple’sAppStoreistheonlyofficialapplicationdistributionplatform. Theredeveloperscanoffertheirapps andconsumerscanbuy,download,andinstallapps. ThisdistributionstylediffersfromAndroid,whichsupportsseveral appstoresandsideloading(installinganapponyouriOSdevicewithoutusingtheofficialAppStore). IniOS,sideloading typicallyreferstotheappinstallationmethodviaUSB,althoughthereareotherenterpriseiOSappdistributionmethods thatdonotusetheAppStoreundertheAppleDeveloperEnterpriseProgram. Inthepast,sideloadingwaspossibleonlywithajailbreakorcomplicatedworkarounds. WithiOS9orhigher,itispossible tosideloadviaXcode. iOSappsareisolatedfromeachotherviaApple’siOSsandbox(historicallycalledSeatbelt),amandatoryaccesscontrol (MAC) mechanism describing the resources an app can and can’t access. Compared to Android’s extensive Binder IPC facilities,iOSoffersveryfewIPC(InterProcessCommunication)options,minimizingthepotentialattacksurface. Uniform hardware and tight hardware/software integration create another security advantage. Every iOS device offers securityfeatures,suchassecureboot,hardware-backedKeychain,andfilesystemencryption(referredasdataprotection iniOS).iOSupdatesareusuallyquicklyrolledouttoalargepercentageofusers,decreasingtheneedtosupportolder, unprotectediOSversions. InspiteofthenumerousstrengthsofiOS,iOSappdevelopersstillneedtoworryaboutsecurity. Dataprotection,Keychain, TouchID/FaceIDauthentication,andnetworksecuritystillleavealargemarginforerrors. Inthefollowingchapters,we describe iOS security architecture, explain a basic security testing methodology, and providereverse engineering how- tos. iOS Security Architecture TheiOSsecurityarchitecture,officiallydocumentedbyAppleintheiOSSecurityGuide,consistsofsixcorefeatures. This securityguideisupdatedbyAppleforeachmajoriOSversion: • HardwareSecurity • SecureBoot • CodeSigning • Sandbox • EncryptionandDataProtection • GeneralExploitMitigations 327\\nHardware Security The iOS security architecture makes good use of hardware-based security features that enhance overall performance. Each iOS device comes with two built-in Advanced Encryption Standard (AES) 256-bit keys. The device’s unique IDs (UIDs)andadevicegroupIDs(GIDs)areAES256-bitkeysfused(UID)orcompiled(GID)intotheApplicationProcessor (AP)andSecureEnclaveProcessor(SEP)duringmanufacturing. There’snodirectwaytoreadthesekeyswithsoftwareor debugginginterfacessuchasJTAG.EncryptionanddecryptionoperationsareperformedbyhardwareAEScrypto-engines thathaveexclusiveaccesstothesekeys. TheGIDisavaluesharedbyallprocessorsinaclassofdevicesusedtopreventtamperingwithfirmwarefilesandother cryptographic tasks not directly related to the user’s private data. UIDs, which are unique to each device, are used to protect the key hierarchy that’s used for device-level file system encryption. Because UIDs aren’t recorded during manufacturing,notevenApplecanrestorethefileencryptionkeysforaparticulardevice. Toallowsecuredeletionofsensitivedataonflashmemory,iOSdevicesincludeafeaturecalledEffaceableStorage. This featureprovidesdirectlow-levelaccesstothestoragetechnology,makingitpossibletosecurelyeraseselectedblocks. Secure Boot WhenaniOSdeviceispoweredon,itreadstheinitialinstructionsfromtheread-onlymemoryknownasBootROM,which bootstrapsthesystem. TheBootROMcontainsimmutablecodeandtheAppleRootCA,whichisetchedintothesilicon chipduringthefabricationprocess,therebycreatingtherootoftrust. Next,theBootROMmakessurethattheLLB’s(Low LevelBootloader)signatureiscorrect,andtheLLBchecksthattheiBootbootloader’ssignatureiscorrecttoo. Afterthe signatureisvalidated,theiBootchecksthesignatureofthenextbootstage,whichistheiOSkernel. Ifanyofthesesteps fail,thebootprocesswillterminateimmediatelyandthedevicewillenterrecoverymodeanddisplaytherestorescreen. However, if the Boot ROM fails to load, the device will enter a special low-level recovery mode called Device Firmware Upgrade(DFU).Thisisthelastresortforrestoringthedevicetoitsoriginalstate. Inthismode,thedevicewillshowno signofactivity;i.e.,itsscreenwon’tdisplayanything. 328\\nThis entire process", "metadata": {"doc_id": "OWASP_MASTG", "chunk_id": 119}}