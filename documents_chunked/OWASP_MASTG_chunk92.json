{"text": "a new AES key using the KeyGenerator class by adding setUserAuthenticationRequired(true)inKeyGenParameterSpec.Builder. generator =KeyGenerator.getInstance(KeyProperties.KEY_ALGORITHM_AES,KEYSTORE); generator.init(newKeyGenParameterSpec.Builder (KEY_ALIAS, KeyProperties.PURPOSE_ENCRYPT |KeyProperties.PURPOSE_DECRYPT) .setBlockModes(KeyProperties.BLOCK_MODE_CBC) .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_PKCS7) .setUserAuthenticationRequired(true) .build() ); generator.generateKey(); Toperformencryptionordecryptionwiththeprotectedkey,createaCipherobjectandinitializeitwiththekeyalias. SecretKeykeyspec =(SecretKey)keyStore.getKey(KEY_ALIAS,null); if(mode ==Cipher.ENCRYPT_MODE){ cipher.init(mode,keyspec); Keep in mind, a new key cannot be used immediately - it has to be authenticated through the FingerprintMan- ager first. This involves wrapping the Cipher object into FingerprintManager.CryptoObject which is passed to FingerprintManager.authenticatebeforeitwillberecognized. cryptoObject =newFingerprintManager.CryptoObject(cipher); fingerprintManager.authenticate(cryptoObject,newCancellationSignal(),0,this,null); The callback method onAuthenticationSucceeded(FingerprintManager.AuthenticationResult result) is called whentheauthenticationsucceeds. TheauthenticatedCryptoObjectcanthenberetrievedfromtheresult. public void authenticationSucceeded(FingerprintManager.AuthenticationResult result){ cipher =result.getCryptoObject().getCipher(); //(...dosomethingwiththeauthenticatedcipherobject...) } Thefollowingdescribeshowtodofingerprintauthenticationusinganasymmetrickeypair. To implement fingerprint authentication using asymmetric cryptography, first create a signing key using the KeyPair- Generatorclass,andenrollthepublickeywiththeserver. Youcanthenauthenticatepiecesofdatabysigningthemon 230\\ntheclientandverifyingthesignatureontheserver. Adetailedexampleforauthenticatingtoremoteserversusingthe fingerprintAPIcanbefoundintheAndroidDevelopersBlog. Akeypairisgeneratedasfollows: KeyPairGenerator.getInstance(KeyProperties.KEY_ALGORITHM_EC,\"AndroidKeyStore\"); keyPairGenerator.initialize( newKeyGenParameterSpec.Builder(MY_KEY, KeyProperties.PURPOSE_SIGN) .setDigests(KeyProperties.DIGEST_SHA256) .setAlgorithmParameterSpec(newECGenParameterSpec(\"secp256r1\")) .setUserAuthenticationRequired(true) .build()); keyPairGenerator.generateKeyPair(); Tousethekeyforsigning,youneedtoinstantiateaCryptoObjectandauthenticateitthroughFingerprintManager. Signature.getInstance(\"SHA256withECDSA\"); KeyStorekeyStore =KeyStore.getInstance(\"AndroidKeyStore\"); keyStore.load(null); PrivateKeykey =(PrivateKey)keyStore.getKey(MY_KEY,null); signature.initSign(key); CryptoObjectcryptoObject =newFingerprintManager.CryptoObject(signature); CancellationSignalcancellationSignal =newCancellationSignal(); FingerprintManagerfingerprintManager = context.getSystemService(FingerprintManager.class); fingerprintManager.authenticate(cryptoObject,cancellationSignal,0,this,null); YoucannowsignthecontentsofabytearrayinputBytesasfollows. Signaturesignature =cryptoObject.getSignature(); signature.update(inputBytes); byte[]signed =signature.sign(); • Notethatincaseswheretransactionsaresigned,arandomnonceshouldbegeneratedandaddedtothesigned data. Otherwise,anattackercouldreplaythetransaction. • Toimplementauthenticationusingsymmetricfingerprintauthentication,useachallenge-responseprotocol. Additional Security Features Android 7.0 (API level 24) adds the setInvalidatedByBiometricEnrollment(boolean invalidateKey) method to KeyGenParameterSpec.Builder. When invalidateKey value is set to true (the default), keys that are valid for fingerprintauthenticationareirreversiblyinvalidatedwhenanewfingerprintisenrolled. Thispreventsanattackerfrom retrievingtheykeyeveniftheyareabletoenrollanadditionalfingerprint. Android8.0(APIlevel26)addstwoadditionalerrorcodes: • FINGERPRINT_ERROR_LOCKOUT_PERMANENT:Theuserhastriedtoomanytimestounlocktheirdeviceusingthefin- gerprintreader. • FINGERPRINT_ERROR_VENDOR:Avendor-specificfingerprintreadererroroccurred. Implementing biometric authentication Reassurethatthelockscreenisset: KeyguardManagermKeyguardManager =(KeyguardManager)getSystemService(Context.KEYGUARD_SERVICE); if(!mKeyguardManager.isKeyguardSecure()){ //Showamessagethattheuserhasn'tsetupalockscreen. } • Createthekeyprotectedbythelockscreen. Inordertousethiskey,theuserneedstohaveunlockedthedevice inthelastXseconds,orthedeviceneedstobeunlockedagain. Makesurethatthistimeoutisnottoolong,asit becomeshardertoensurethatitwasthesameuserusingtheappastheuserunlockingthedevice: 231\\ntry{ KeyStorekeyStore =KeyStore.getInstance(\"AndroidKeyStore\"); keyStore.load(null); KeyGeneratorkeyGenerator =KeyGenerator.getInstance( KeyProperties.KEY_ALGORITHM_AES,\"AndroidKeyStore\"); //Set thealiasoftheentryinAndroidKeyStorewherethekeywillappear //and theconstrains(purposes)intheconstructoroftheBuilder keyGenerator.init(newKeyGenParameterSpec.Builder(KEY_NAME, KeyProperties.PURPOSE_ENCRYPT |KeyProperties.PURPOSE_DECRYPT) .setBlockModes(KeyProperties.BLOCK_MODE_CBC) .setUserAuthenticationRequired(true) //Require thattheuserhasunlockedinthelast30seconds .setUserAuthenticationValidityDurationSeconds(30) .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_PKCS7) .build()); keyGenerator.generateKey(); }catch (NoSuchAlgorithmException |NoSuchProviderException |InvalidAlgorithmParameterException |KeyStoreException |CertificateException |IOExceptione){ throw newRuntimeException(\"Failedtocreateasymmetrickey\",e); } • Setupthelockscreentoconfirm: private static final intREQUEST_CODE_CONFIRM_DEVICE_CREDENTIALS =1;//usedasanumbertoverifywhetherthisiswheretheactivityresultsfrom Intentintent =mKeyguardManager.createConfirmDeviceCredentialIntent(null,null); if(intent !=null){ startActivityForResult(intent,REQUEST_CODE_CONFIRM_DEVICE_CREDENTIALS); } • Usethekeyafterlockscreen: @Override protected void onActivityResult(intrequestCode,intresultCode,Intentdata){ if(requestCode ==REQUEST_CODE_CONFIRM_DEVICE_CREDENTIALS){ //Challenge completed,proceedwithusingcipher if(resultCode ==RESULT_OK){ //usethe keyfortheactualauthenticationflow }else { //The usercanceledordidn’tcompletethelockscreen //operation. Gotoerror/cancellationflow. } } } Third party SDKs Make sure that fingerprint authentication and/or other types of biometric authentication are exclusively based on the AndroidSDKanditsAPIs. Ifthisisnotthecase,ensurethatthealternativeSDKhasbeenproperlyvettedforanyweak- nesses. MakesurethattheSDKisbackedbytheTEE/SEwhichunlocksa(cryptographic)secretbasedonthebiometric authentication. Thissecretshouldnotbeunlockedbyanythingelse,butavalidbiometricentry. Thatway,itshouldnever bethecasethatthefingerprintlogiccanbebypassed. Testing Biometric Authentication Platform: android MASVSV1: MSTG-AUTH-8 MASVSV2: MASVS-AUTH-2 Overview Static Analysis Note that there are quite some vendor/third party SDKs, which provide biometric support, but which have their own insecurities. BeverycautiouswhenusingthirdpartySDKstohandlesensitiveauthenticationlogic. 232\\nDynamic Analysis Please take a look at this detailed blog article about the Android KeyStore and Biometric authentication. This research includes two Frida scripts which can be used to test insecure implementations of biometric authentication and try to bypassthem: • Fingerprintbypass: ThisFridascriptwillbypassauthenticationwhentheCryptoObjectisnotusedintheauthen- ticate method of the BiometricPrompt class. The authentication implementation relies on the callback onAu- thenticationSuccededbeingcalled. • Fingerprintbypassviaexceptionhandling: ThisFridascriptwillattempttobypassauthenticationwhentheCryp- toObjectisused,butusedinanincorrectway. Thedetailedexplanationcanbefoundinthesection“CryptoObject ExceptionHandling”intheblogpost. Testing Confirm Credentials Platform: android MASVSV1: MSTG-AUTH-1,MSTG-STORAGE-11 MASVSV2: MASVS-AUTH-2 Overview Static Analysis Makesurethattheunlockedkeyisusedduringtheapplicationflow. Forexample,thekeymaybeusedtodecryptlocal storageoramessagereceivedfromaremoteendpoint. Iftheapplicationsimplycheckswhethertheuserhasunlocked thekeyornot,theapplicationmaybevulnerabletoalocalauthenticationbypass. Dynamic Analysis Validatethedurationoftime(seconds)forwhichthekeyisauthorizedtobeusedaftertheuserissuccessfullyauthenti- cated. ThisisonlyneededifsetUserAuthenticationRequiredisused. 233\\nAndroid Network Communication Overview AlmosteveryAndroidappactsasaclienttooneormoreremoteservices. Asthisnetworkcommunicationusuallytakes placeoveruntrustednetworkssuchaspublicWi-Fi,classicalnetworkbased-attacksbecomeapotentialissue. Most modern mobile apps use variants of HTTP-based web services, as these protocols are well-documented and sup- ported. Android Network Security Configuration Starting on Android 7.0 (API level 24), Android apps can customize their network security settings using the so-called NetworkSecurityConfigurationfeaturewhichoffersthefollowingkeycapabilities: • Cleartexttraffic: Protectappsfromaccidentalusageofcleartexttraffic(orenablesit). • Customtrustanchors: CustomizewhichCertificateAuthorities(CAs)aretrustedforanapp’ssecureconnections. Forexample,trustingparticularself-signedcertificatesorrestrictingthesetofpublicCAsthattheapptrusts. • Certificatepinning: Restrictanapp’ssecureconnectiontoparticularcertificates. • Debug-onlyoverrides: Safelydebugsecureconnectionsinanappwithoutaddedrisktotheinstalledbase. If an app defines a custom Network Security Configuration, you can obtain its location by searching for an- droid:networkSecurityConfigintheAndroidManifest.xmlfile. <application android:networkSecurityConfig=\"@xml/network_security_config\" Inthiscasethefileislocatedat@xml(equivalentto/res/xml)andhasthename“network_security_config”(whichmight vary). Youshouldbeabletofinditas“res/xml/network_security_config.xml”. Ifaconfigurationexists,thefollowingevent shouldbevisibleinthesystemlogs: D/NetworkSecurityConfig:UsingNetworkSecurityConfigfromresourcenetwork_security_config TheNetworkSecurityConfigurationisXML-basedandcanbeusedtoconfigureapp-wideanddomain-specificsettings: • base-configappliestoallconnectionsthattheappattemptstomake. • domain-configoverridesbase-configforspecificdomains(itcancontainmultipledomainentries).", "metadata": {"doc_id": "OWASP_MASTG", "chunk_id": 92}}