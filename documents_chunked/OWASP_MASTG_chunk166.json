{"text": "single case and introducearandomfactor. Thistechniqueisvulnerabletodeobfuscation,butdependingonthecomplexityanddepthof thesubstitutions,applyingitcanstillbetimeconsuming. Control Flow Flattening Controlflowflatteningreplacesoriginalcodewithamorecomplexrepresentation. Thetransformationbreaksthebodyof afunctionintobasicblocksandputsthemallinsideasingleinfiniteloopwithaswitchstatementthatcontrolstheprogram flow. This makes the program flow significantly harder to follow because it removes the natural conditional constructs thatusuallymakethecodeeasiertoread. Theimageshowshowcontrolflowflatteningalterscode. See“ObfuscatingC++programsviacontrolflowflattening”for moreinformation. 515\\nDead Code Injection Thistechniquemakestheprogram’scontrolflowmorecomplexbyinjectingdeadcodeintotheprogram. Deadcodeisa stubofcodethatdoesn’taffecttheoriginalprogram’sbehaviourbutincreasestheoverheadforthereverseengineering process. String Encryption Applications are often compiled with hardcoded keys, licences, tokens and endpoint URLs. By default, all of them are storedinplaintextinthedatasectionofanapplication’sbinary. Thistechniqueencryptsthesevaluesandinjectsstubs ofcodeintotheprogramthatwilldecryptthatdatabeforeitisusedbytheprogram. Recommended Tools • SwiftShieldcanbeusedtoperformnameobfuscation. ItreadsthesourcecodeoftheXcodeprojectandreplaces allnamesofclasses,methodsandfieldswithrandomvaluesbeforethecompilerisused. • obfuscator-llvm operates on the Intermediate Representation (IR) instead of the source code. It can be used for symbolobfuscation,stringencryptionandcontrolflowflattening. Sinceit’sbasedonIR,itcanhideoutsignificantly moreinformationabouttheapplicationascomparedtoSwiftShield. LearnmoreaboutiOSobfuscationtechniquesinthepaper“ProtectingMillion-UseriOSAppswithObfuscation: Motivations, Pitfalls,andExperience”. Device Binding The purpose of device binding is to impede an attackerwho tries to copy an app and its state fromdevice A to device B and continue the execution of the app on device B. After device A has been determined trusted, it may have more privilegesthandeviceB.Thissituationshouldn’tchangewhenanappiscopiedfromdeviceAtodeviceB. SinceiOS7.0,hardwareidentifiers(suchasMACaddresses)areoff-limitsbutthereareothermethodsforimplementing devicebindinginiOS: • identifierForVendor: You can use [[UIDevice currentDevice] identifierForVendor] (in Objective- C), UIDevice.current.identifierForVendor?.uuidString (in Swift3), or UIDevice.currentDevice(). identifierForVendor?.UUIDString(inSwift2). ThevalueofidentifierForVendormaynotbethesameifyou reinstall the app after other apps from the same vendor are installed and it may change when you update your appbundle’sname. ThereforeitisbesttocombineitwithsomethingintheKeychain. • UsingtheKeychain: YoucanstoresomethingintheKeychaintoidentifytheapplication’sinstance. Tomakesure thatthisdataisnotbackedup,usekSecAttrAccessibleWhenPasscodeSetThisDeviceOnly(ifyouwanttosecure thedataandproperlyenforceapasscodeorTouchIDrequirement),kSecAttrAccessibleAfterFirstUnlockThis- DeviceOnly,orkSecAttrAccessibleWhenUnlockedThisDeviceOnly. • UsingGoogleInstanceID:seetheimplementationforiOShere. Anyschemebasedonthesemethodswillbemoresecurethemomentapasscodeand/orTouchIDisenabled,themate- rials stored in the Keychain or filesystem are protected with protection classes (such as kSecAttrAccessibleAfter- FirstUnlockThisDeviceOnly and kSecAttrAccessibleWhenUnlockedThisDeviceOnly), and the SecAccessControl- CreateFlagsisseteitherwithkSecAccessControlDevicePasscode(forpasscodes),kSecAccessControlUserPresence (passcode, Face ID or Touch ID), kSecAccessControlBiometryAny (Face ID or Touch ID) or kSecAccessControlBiome- tryCurrentSet(FaceID/TouchID:butcurrentenrolledbiometricsonly). Testing for Debugging Code and Verbose Error Logging Platform: ios MASVSV1: MSTG-CODE-4 MASVSV2: MASVS-RESILIENCE-3 516\\nOverview Static Analysis Youcantakethefollowingstaticanalysisapproachfortheloggingstatements: 1. Importtheapplication’scodeintoXcode. 2. Searchthecodeforthefollowingprintingfunctions: NSLog,println,print,dump,debugPrint. 3. Whenyoufindoneofthem,determinewhetherthedevelopersusedawrappingfunctionaroundtheloggingfunction forbettermarkupofthestatementstobelogged;ifso,addthatfunctiontoyoursearch. 4. Foreveryresultofsteps2and3,determinewhethermacrosordebug-staterelatedguardshavebeensettoturn theloggingoffinthereleasebuild. PleasenotethechangeinhowObjective-Ccanusepreprocessormacros: ##ifdefDEBUG //Debug-onlycode ##endif The procedure for enabling this behavior in Swift has changed: you need to either set environment variables in your schemeorsetthemascustomflagsinthetarget’sbuildsettings. Pleasenotethatthefollowingfunctions(whichallow youtodeterminewhethertheappwasbuiltintheSwift2.1. release-configuration)aren’trecommended,asXcode8and Swift3don’tsupportthesefunctions: • _isDebugAssertConfiguration • _isReleaseAssertConfiguration • _isFastAssertConfiguration. Dependingontheapplication’ssetup,theremaybemoreloggingfunctions. Forexample,whenCocoaLumberjackisused, staticanalysisisabitdifferent. Forthe“debug-management”code(whichisbuilt-in): inspectthestoryboardstoseewhetherthereareanyflowsand/or view-controllersthatprovidefunctionalitydifferentfromthefunctionalitytheapplicationshouldsupport. Thisfunctionality canbeanythingfromdebugviewstoprintederrormessages,fromcustomstub-responseconfigurationstologswritten tofilesontheapplication’sfilesystemoraremoteserver. Asadeveloper,incorporatingdebugstatementsintoyourapplication’sdebugversionshouldnotbeaproblemaslongas youmakesurethatthedebugstatementsareneverpresentintheapplication’sreleaseversion. InObjective-C,developerscanusepreprocessormacrostofilteroutdebugcode: ##ifdefDEBUG //Debug-onlycode ##endif InSwift2(withXcode7), youhavetosetcustomcompilerflagsforeverytarget, andcompilerflagshavetostartwith “-D”.SoyoucanusethefollowingannotationswhenthedebugflagDMSTG-DEBUGisset: ##ifMSTG-DEBUG //Debug-onlycode ##endif InSwift3(withXcode8),youcansetActiveCompilationConditionsinBuildsettings/Swiftcompiler-Customflags. Instead ofapreprocessor,Swift3usesconditionalcompilationblocksbasedonthedefinedconditions: ##ifDEBUG_LOGGING //Debug-onlycode ##endif Dynamic Analysis Dynamicanalysisshouldbeexecutedonbothasimulatorandadevicebecausedeveloperssometimesusetarget-based functions(insteadoffunctionsbasedonarelease/debug-mode)toexecutethedebuggingcode. 517\\n1. Runtheapplicationonasimulatorandcheckforoutputintheconsoleduringtheapp’sexecution. 2. AttachadevicetoyourMac,runtheapplicationonthedeviceviaXcode,andcheckforoutputintheconsoleduring theapp’sexecution. Fortheother“manager-based”debugcode: clickthroughtheapplicationonbothasimulatorandadevicetoseeifyou can find any functionality that allows an app’s profiles to be pre-set, allows the actual server to be selected or allows responsesfromtheAPItobeselected. Testing Anti-Debugging Detection Platform: ios MASVSV1: MSTG-RESILIENCE-2 MASVSV2: MASVS-RESILIENCE-4 Overview Inordertotestforanti-debuggingdetectionyoucantrytoattachadebuggertotheappandseewhathappens. Theappshouldrespondinsomeway. Forexampleby: • Alertingtheuserandaskingforacceptingliability. • Preventingexecutionbygracefullyterminating. • Securelywipinganysensitivedatastoredonthedevice. • Reportingtoabackendserver,e.g,forfrauddetection. Trytohookorreverseengineertheappusingthemethodsfromsection“Anti-DebuggingDetection”. Next,workonbypassingthedetectionandanswerthefollowingquestions: • Canthemechanismsbebypassedtrivially(e.g.,byhookingasingleAPIfunction)? • Howdifficultisidentifyingthedetectioncodeviastaticanddynamicanalysis? • Didyouneedtowritecustomcodetodisablethedefenses? Howmuchtimedidyouneed? • Whatisyourassessmentofthedifficultyofbypassingthemechanisms? Testing Jailbreak Detection Platform: ios MASVSV1: MSTG-RESILIENCE-1 MASVSV2: MASVS-RESILIENCE-1 Overview Totestforjailbreakdetectioninstalltheapponajailbrokendevice. Launchtheappandseewhathappens: Ifitimplementsjailbreakdetection,youmightnoticeoneofthefollowingthings: • Theappcrashesandclosesimmediately,withoutanynotification. • Apop-upwindowindicatesthattheappwon’trunonajailbrokendevice. Notethatcrashesmightbeanindicatorofjailbreakdetectionbuttheappmaybecrashingforanyotherreasons,e.g.itmay haveabug. Werecommendtotesttheapponnon-jailbrokendevicefirst,especiallywhenyou’retestingpreproduction versions. LaunchtheappandtrytobypassJailbreakDetectionusinganautomatedtool: 518\\nIf it implements jailbreak detection, you might be able to see indicators of that in the output of the tool. See section “AutomatedJailbreakDetectionBypass”. ReverseEngineertheapp: Theappmightbeusingtechniquesthatarenotimplementedintheautomatedtoolsthatyou’veused. Ifthat’sthecase youmustreverseengineertheapptofindproofs. Seesection“ManualJailbreakDetectionBypass”. Testing whether the App is Debuggable Platform: ios MASVSV1: MSTG-CODE-2 MASVSV2: MASVS-RESILIENCE-4 Overview Static Analysis Inspecttheappentitlementsandcheckthevalueofget-task-allowkey. Ifitissettotrue,theappisdebuggable. Usingcodesign: $codesign -d--entitlements -iGoat-Swift.app Executable=/Users/owasp/iGoat-Swift/Payload/iGoat-Swift.app/iGoat-Swift [Dict] [Key]application-identifier [Value] [String]TNAJ496RHB.OWASP.iGoat-Swift [Key]com.apple.developer.team-identifier [Value] [String]TNAJ496RHB [Key]get-task-allow [Value] [Bool]true [Key]keychain-access-groups [Value] [Array] [String]TNAJ496RHB.OWASP.iGoat-Swift Usingldid: $ldid-eiGoat-Swift.app/iGoat-Swift <?xml version=\"1.0\" encoding=\"UTF-8\"?> <!DOCTYPE plist PUBLIC\"-//Apple//DTDPLIST1.0//EN\"\"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"> <plist version=\"1.0\"> <dict> <key>application-identifier</key> <string>TNAJ496RHB.OWASP.iGoat-Swift</string> <key>com.apple.developer.team-identifier</key> <string>TNAJ496RHB</string> <key>get-task-allow</key> <true/> <key>keychain-access-groups</key> <array> <string>TNAJ496RHB.OWASP.iGoat-Swift</string> </array> </dict> </plist> Dynamic Analysis Checkwhetheryoucanattachadebuggerdirectly, usingXcode. Next, checkifyoucandebugtheapponajailbroken", "metadata": {"doc_id": "OWASP_MASTG", "chunk_id": 166}}