{"text": "+ bcanberepresentedasx = -(-a) - (-b). However,usingthesamereplacementrepre- sentation could be easily reversed, so it is recommended to add multiple substitution techniques for a single case and introducearandomfactor. Thistechniquecanbereversedduringdecompilation,butdependingonthecomplexityand depthofthesubstitutions,reversingitcanstillbetimeconsuming. Control Flow Flattening Controlflowflatteningreplacesoriginalcodewithamorecomplexrepresentation. Thetransformationbreaksthebodyof afunctionintobasicblocksandputsthemallinsideasingleinfiniteloopwithaswitchstatementthatcontrolstheprogram flow. This makes the program flow significantly harder to follow because it removes the natural conditional constructs thatusuallymakethecodeeasiertoread. 45\\nTheimageshowshowcontrolflowflatteningalterscode. See“ObfuscatingC++programsviacontrolflowflattening”for moreinformation. Dead Code Injection Thistechniquemakestheprogram’scontrolflowmorecomplexbyinjectingdeadcodeintotheprogram. Deadcodeis astubofcodethatdoesn’taffecttheoriginalprogram’sbehaviorbutincreasestheoverheadofthereverseengineering process. String Encryption Applications are often compiled with hardcoded keys, licences, tokens and endpoint URLs. By default, all of them are storedinplaintextinthedatasectionofanapplication’sbinary. Thistechniqueencryptsthesevaluesandinjectsstubs ofcodeintotheprogramthatwilldecryptthatdatabeforeitisusedbytheprogram. Packing Packing is a dynamic rewriting obfuscation technique which compresses or encrypts the original executable into data anddynamicallyrecoversitduringexecution. Packinganexecutablechangesthefilesignatureinanattempttoavoid signature-baseddetection. Debugging and Tracing Inthetraditionalsense,debuggingistheprocessofidentifyingandisolatingproblemsinaprogramaspartofthesoftware developmentlifecycle. Thesametoolsusedfordebuggingarevaluabletoreverseengineersevenwhenidentifyingbugs 46\\nisnottheprimarygoal. Debuggersenableprogramsuspensionatanypointduringruntime, inspectionoftheprocess’ internalstate,andevenregisterandmemorymodification. Theseabilitiessimplifyprograminspection. Debugging usually means interactive debugging sessions in which a debugger is attached to the running process. In contrast, tracing refers to passive logging of information about the app’s execution (such as API calls). Tracing can be doneinseveralways,includingdebuggingAPIs,functionhooks,andKerneltracingfacilities. Again,we’llcovermanyof thesetechniquesintheOS-specific“ReverseEngineeringandTampering”chapters. Advanced Techniques Formorecomplicatedtasks, suchasde-obfuscatingheavilyobfuscatedbinaries, youwon’tgetfarwithoutautomating certainpartsoftheanalysis. Forexample,understandingandsimplifyingacomplexcontrolflowgraphbasedonmanual analysisinthedisassemblerwouldtakeyouyears(andmostlikelydriveyoumadlongbeforeyou’redone). Instead,you canaugmentyourworkflowwithcustommadetools. Fortunately,moderndisassemblerscomewithscriptingandexten- sionAPIs,andmanyusefulextensionsareavailableforpopulardisassemblers. Therearealsoopensourcedisassembling enginesandbinaryanalysisframeworks. Asalwaysinhacking,theanything-goesruleapplies: simplyusewhateverismostefficient. Everybinaryisdifferent,and allreverseengineershavetheirownstyle. Often,thebestwaytoachieveyourgoalistocombineapproaches(suchas emulator-based tracing and symbolic execution). To get started, pick a good disassembler and/or reverse engineering framework,thengetcomfortablewiththeirparticularfeaturesandextensionAPIs. Ultimately,thebestwaytogetbetter istogethands-onexperience. Dynamic Binary Instrumentation Anotherusefulapproachfornativebinariesisdynamicbinaryinstrumentations(DBI).Instrumentationframeworkssuch as Valgrind and PIN support fine-grained instruction-level tracing of single processes. This is accomplished by insert- ing dynamically generated code at runtime. Valgrind compiles fine on Android, and pre-built binaries are available for download. TheValgrindREADMEincludesspecificcompilationinstructionsforAndroid. Emulation-based Dynamic Analysis Emulationisanimitationofacertaincomputerplatformorprogrambeingexecutedindifferentplatformorwithinanother program. Thesoftwareorhardwareperformingthisimitationiscalledanemulator. Emulatorsprovideamuchcheaper alternativetoanactualdevice,whereausercanmanipulateitwithoutworryingaboutdamagingthedevice. Thereare multipleemulatorsavailableforAndroid,butforiOStherearepracticallynoviableemulatorsavailable. iOSonlyhasa simulator,shippedwithinXcode. The difference between a simulator and an emulator often causes confusion and leads to use of the two terms inter- changeably, butinrealitytheyaredifferent, speciallyfortheiOSusecase. Anemulatormimicsboththesoftwareand hardwareenvironmentofatargetedplatform. Ontheotherhand,asimulatoronlymimicsthesoftwareenvironment. QEMUbasedemulatorsforAndroidtakeintoconsiderationtheRAM,CPU,batteryperformanceetc(hardwarecomponents) whilerunninganapplication,butinaniOSsimulatorthishardwarecomponentbehaviourisnottakenintoconsideration atall. TheiOSsimulatorevenlackstheimplementationoftheiOSkernel,asaresultifanapplicationisusingsyscallsit cannotbeexecutedinthissimulator. Insimplewords,anemulatorisamuchcloserimitationofthetargetedplatform,whileasimulatormimicsonlyapartof it. Runninganappintheemulatorgivesyoupowerfulwaystomonitorandmanipulateitsenvironment. Forsomereverse engineeringtasks,especiallythosethatrequirelow-levelinstructiontracing,emulationisthebest(oronly)choice. Un- fortunately,thistypeofanalysisisonlyviableforAndroid,becausenofreeoropensourceemulatorexistsforiOS(the iOSsimulatorisnotanemulator,andappscompiledforaniOSdevicedon’trunonit). TheonlyiOSemulatoravailable isacommercialSaaSsolution-Corellium. We’llprovideanoverviewofpopularemulation-basedanalysisframeworksfor Androidinthe“TamperingandReverseEngineeringonAndroid”chapter. 47\\nCustom Tooling with Reverse Engineering Frameworks EventhoughmostprofessionalGUI-baseddisassemblersfeaturescriptingfacilitiesandextensibility,theyaresimplynot well-suitedtosolvingparticularproblems. Reverseengineeringframeworksallowyoutoperformandautomateanykind ofreversingtaskwithoutdependingonaheavy-weightGUI.Notably,mostreversingframeworksareopensourceand/or availableforfree. Popularframeworkswithsupportformobilearchitecturesincluderadare2andAngr. Example: Program Analysis with Symbolic/Concolic Execution In the late 2000s, testing based on symbolic execution has become a popular way to identify security vulnerabilities. Symbolic “execution” actually refers to the process of representing possible paths through a program as formulas in first-order logic. Satisfiability Modulo Theories (SMT) solvers are used to check the satisfiability of these formulas and provide solutions, including concrete values of the variables needed to reach a certain point of execution on the path correspondingtothesolvedformula. Insimplewords,symbolicexecutionismathematicallyanalyzingaprogramwithoutexecutingit. Duringanalysis,each unknowninputisrepresentedasamathematicalvariable(asymbolicvalue),andhencealltheoperationsperformedon thesevariablesarerecordedasatreeofoperations(aka. AST(abstractsyntaxtree),fromcompilertheory). TheseASTs can be translated into so-called constraints that will be interpreted by a SMT solver. In the end of this analysis, a final mathematicalequationisobtained,inwhichthevariablesaretheinputswhosevaluesarenotknown. SMTsolversare specialprogramswhichsolvetheseequationstogivepossiblevaluesfortheinputvariablesgivenafinalstate. Toillustratethis,imagineafunctionwhichtakesoneinput(x)andmultipliesitbythevalueofasecondinput(y). Finally, thereisanifconditionwhichchecksifthevaluecalculatedisgreaterthanthevalueofanexternalvariable(z),andreturns “success”iftrue,elsereturns“fail”. Theequationforthisoperationwillbe(x * y) > z. Ifwewantthefunctiontoalwaysreturn“success”(finalstate),wecantelltheSMTsolvertocalculatethevaluesforx andy(inputvariables)whichsatisfythecorrespondingequation. Asisthecaseforglobalvariables,theirvaluecanbe changedfromoutsidethisfunction,whichmayleadtodifferentoutputswheneverthisfunctionisexecuted. Thisaddsto additionalcomplexityindeterminingcorrectsolution. Internally SMT solvers use various equation solving techniques to generate solution for such equations. Some of the techniquesareveryadvancedandtheirdiscussionisbeyondthescopeofthisbook. In a real world situation, the functions are much more complex than the above example. The increased complexity of thefunctionscanposesignificantchallengesforclassicalsymbolicexecution. Someofthechallengesaresummarised below: • Loopsandrecursionsinaprogrammayleadtoinfiniteexecutiontree. • Multipleconditionalbranchesornestedconditionsmayleadtopathexplosion. • ComplexequationsgeneratedbysymbolicexecutionmaynotbesolvablebySMTsolversbecauseoftheirlimita- tions. • Programisusingsystemcalls,librarycallsornetworkeventswhichcannotbehandledbysymbolicexecution. Toovercomethesechallenges,typically,symbolicexecutioniscombinedwithothertechniquessuchasdynamicexecution (also called concrete execution) to mitigate the path explosion problem specific to classical symbolic execution. This combinationofconcrete(actual)andsymbolicexecutionisreferredtoasconcolicexecution(thenameconcolicstems fromconcreteandsymbolic),sometimesalsocalledasdynamicsymbolicexecution. To visualize this, in the above example, we can", "metadata": {"doc_id": "OWASP_MASTG", "chunk_id": 42}}