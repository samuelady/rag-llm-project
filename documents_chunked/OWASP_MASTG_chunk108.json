{"text": "AndroidapplicationsrunonaVMwheremostofthememorycorruptionissueshavebeentakencareoff. Thisdoesnot meanthattherearenomemorycorruptionbugs. TakeCVE-2018-9522forinstance,whichisrelatedtoserializationissues usingParcels. Next,innativecode,westillseethesameissuesasweexplainedinthegeneralmemorycorruptionsection. Last,weseememorybugsinsupportingservices,suchaswiththeStagefrightattackasshownatBlackHat. Memoryleaksareoftenanissueaswell. ThiscanhappenforinstancewhenareferencetotheContextobjectispassed aroundtonon-Activityclasses,orwhenyoupassreferencestoActivityclassestoyourhelperclasses. Binary Protection Mechanisms Detectingthepresenceofbinaryprotectionmechanismsheavilydependonthelanguageusedfordevelopingtheappli- cation. Ingeneralallbinariesshouldbetested,whichincludesboththemainappexecutableaswellasalllibraries/dependencies. However,onAndroidwewillfocusonnativelibrariessincethemainexecutablesareconsideredsafeaswewillseenext. AndroidoptimizesitsDalvikbytecodefromtheappDEXfiles(e.g.classes.dex)andgeneratesanewfilecontainingthe nativecode,usuallywithan.odex,.oatextension. ThisAndroidcompiledbinaryiswrappedusingtheELFformatwhich istheformatusedbyLinuxandAndroidtopackageassemblycode. Theapp’sNDKnativelibrariesalsousetheELFformat. • PIE(PositionIndependentExecutable): – SinceAndroid7.0(APIlevel24),PICcompilationisenabledbydefaultforthemainexecutables. – WithAndroid5.0(APIlevel21),supportfornon-PIEenablednativelibrarieswasdroppedandsincethen,PIE isenforcedbythelinker. • Memorymanagement: – Garbage Collection will simply run for the main binaries and there’s nothing to be checked on the binaries themselves. – GarbageCollectiondoesnotapplytoAndroidnativelibraries. Thedeveloperisresponsiblefordoingproper manualmemorymanagement. See“MemoryCorruptionBugs”. • StackSmashingProtection: – AndroidappsgetcompiledtoDalvikbytecodewhichisconsideredmemorysafe(atleastformitigatingbuffer overflows). OtherframeworkssuchasFlutterwillnotcompileusingstackcanariesbecauseofthewaytheir language,inthiscaseDart,mitigatesbufferoverflows. – ItmustbeenabledforAndroidnativelibrariesbutitmightbedifficulttofullydetermineit. ∗ NDKlibrariesshouldhaveitenabledsincethecompilerdoesitbydefault. ∗ OthercustomC/C++librariesmightnothaveitenabled. Learnmore: • Androidexecutableformats • Androidruntime(ART) • AndroidNDK • AndroidlinkerchangesforNDKdevelopers Debuggable Apps Debugging is an essential process for developers to identify and fix errors or bugs in their Android app. By using a debugger, developers can select the device to debug their app on and set breakpoints in their Java, Kotlin, and C/C++ code. Thisallowsthemtoanalyzevariablesandevaluateexpressionsatruntime,whichhelpsthemtoidentifytheroot causeofmanyissues. Bydebuggingtheirapp,developerscanimprovethefunctionalityanduserexperienceoftheirapp, ensuringthatitrunssmoothlywithoutanyerrorsorcrashes. Everydebugger-enabledprocessrunsanextrathreadforhandlingJDWPprotocolpackets. Thisthreadisstartedonlyfor appsthathavetheandroid:debuggable=\"true\"attributeintheApplicationelementwithintheAndroidManifest. 288\\nDebugging Symbols Generally,youshouldprovidecompiledcodewithaslittleexplanationaspossible. Somemetadata,suchasdebugging information,linenumbers,anddescriptivefunctionormethodnames,makethebinaryorbytecodeeasierforthereverse engineertounderstand,butthesearen’tneededinareleasebuildandcanthereforebesafelyomittedwithoutimpacting theapp’sfunctionality. To inspect native binaries, use a standard tool like nm or objdump to examine the symbol table. A release build should generally not contain any debugging symbols. If the goal is to obfuscate the library, removing unnecessary dynamic symbolsisalsorecommended. Debugging Code and Error Logging StrictMode StrictModeisadevelopertoolfordetectingviolations, e.g.accidentaldiskornetworkaccessontheapplication’smain thread. Itcanalsobeusedtocheckforgoodcodingpractices,suchasimplementingperformantcode. HereisanexampleofStrictModewithpoliciesenabledfordiskandnetworkaccesstothemainthread: public void onCreate(){ if(DEVELOPER_MODE){ StrictMode.setThreadPolicy(newStrictMode.ThreadPolicy.Builder() .detectDiskReads() .detectDiskWrites() .detectNetwork() //or.detectAll()foralldetectableproblems .penaltyLog() .build()); StrictMode.setVmPolicy(newStrictMode.VmPolicy.Builder() .detectLeakedSqlLiteObjects() .detectLeakedClosableObjects() .penaltyLog() .penaltyDeath() .build()); } super.onCreate(); } Inserting the policy in the if statement with the DEVELOPER_MODE condition is recommended. To disable StrictMode, DEVELOPER_MODEmustbedisabledforthereleasebuild. Exception Handling Exceptions occur when an application gets into an abnormal or error state. Both Java and C++ may throw exceptions. Testingexceptionhandlingisaboutensuringthattheappwillhandleanexceptionandtransitiontoasafestatewithout exposingsensitiveinformationviatheUIortheapp’sloggingmechanisms. Make Sure That Free Security Features Are Activated Platform: android MASVSV1: MSTG-CODE-9 MASVSV2: MASVS-CODE-4 Overview Static Analysis TesttheappnativelibrariestodetermineiftheyhavethePIEandstacksmashingprotectionsenabled. Youcanuseradare2’srabin2togetthebinaryinformation. We’llusetheUnCrackableAppforAndroidLevel4v1.0APK asanexample. 289\\nAllnativelibrariesmusthavecanaryandpicbothsettotrue. That’sthecaseforlibnative-lib.so: rabin2 -Ilib/x86_64/libnative-lib.so |grep -E\"canary|pic\" canary true pic true Butnotforlibtool-checker.so: rabin2 -Ilib/x86_64/libtool-checker.so |grep -E\"canary|pic\" canary false pic true Inthisexample,libtool-checker.somustberecompiledwithstacksmashingprotectionsupport. Testing for Injection Flaws Platform: android MASVSV1: MSTG-PLATFORM-2 MASVSV2: MASVS-CODE-4 Overview Totestforinjectionflawsyouneedtofirstrelyonothertestsandcheckforfunctionalitythatmighthavebeenexposed: • “TestingDeepLinks” • “TestingforSensitiveFunctionalityExposureThroughIPC” • “TestingforOverlayAttacks” Static Analysis AnexampleofavulnerableIPCmechanismisshownbelow. YoucanuseContentProviderstoaccessdatabaseinformation,andyoucanprobeservicestoseeiftheyreturndata. If dataisnotvalidatedproperly,thecontentprovidermaybepronetoSQLinjectionwhileotherappsareinteractingwith it. SeethefollowingvulnerableimplementationofaContentProvider. <provider android:name=\".OMTG_CODING_003_SQL_Injection_Content_Provider_Implementation\" android:authorities=\"sg.vp.owasp_mobile.provider.College\"> </provider> The AndroidManifest.xml above defines a content provider that’s exported and therefore available to all other apps. ThequeryfunctionintheOMTG_CODING_003_SQL_Injection_Content_Provider_Implementation.javaclassshouldbe inspected. @Override public Cursor query(Uriuri,String[]projection,Stringselection,String[]selectionArgs,StringsortOrder){ SQLiteQueryBuilderqb =newSQLiteQueryBuilder(); qb.setTables(STUDENTS_TABLE_NAME); switch (uriMatcher.match(uri)){ case STUDENTS: qb.setProjectionMap(STUDENTS_PROJECTION_MAP); break; case STUDENT_ID: //SQLInjectionwhenprovidinganID qb.appendWhere(_ID+\"=\"+uri.getPathSegments().get(1)); Log.e(\"appendWhere\",uri.getPathSegments().get(1).toString()); break; 290\\ndefault: throw newIllegalArgumentException(\"UnknownURI\" +uri); } if(sortOrder ==null ||sortOrder ==\"\"){ /** *Bydefaultsortonstudentnames */ sortOrder =NAME; } Cursorc =qb.query(db,projection,selection,selectionArgs,null,null, sortOrder); /** *registertowatchacontentURIforchanges */ c.setNotificationUri(getContext().getContentResolver(),uri); return c; } WhiletheuserisprovidingaSTUDENT_IDatcontent://sg.vp.owasp_mobile.provider.College/students,thequery statement is prone to SQL injection. Obviously prepared statements must be used to avoid SQL injection, but input validationshouldalsobeappliedsothatonlyinputthattheappisexpectingisprocessed. AllappfunctionsthatprocessdatacominginthroughtheUIshouldimplementinputvalidation: • Foruserinterfaceinput,AndroidSaripaarv2canbeused. • ForinputfromIPCorURLschemes,avalidationfunctionshouldbecreated. Forexample,thefollowingdetermines whetherthestringisalphanumeric: public boolean isAlphaNumeric(Strings){ Stringpattern=\"^[a-zA-Z0-9]*$\"; return s.matches(pattern); } An alternative to validation functions is type conversion, with, for example, Integer.parseInt if only integers are ex- pected. TheOWASPInputValidationCheatSheetcontainsmoreinformationaboutthistopic. Dynamic Analysis ThetestershouldmanuallytesttheinputfieldswithstringslikeOR1=1--if,forexample,alocalSQLinjectionvulnerability hasbeenidentified. Onarooteddevice,thecommandcontentcanbeusedtoquerythedatafromacontentprovider. Thefollowingcommand queriesthevulnerablefunctiondescribedabove. ##contentquery--uricontent://sg.vp.owasp_mobile.provider.College/students SQL injection can be exploited with the following command. Instead of getting the record for Bob only, the user can retrievealldata. ##contentquery--uricontent://sg.vp.owasp_mobile.provider.College/students--where\"name='Bob')OR1=1--''\" Testing Local Storage for Input Validation Platform: android MASVSV1: MSTG-PLATFORM-2 MASVSV2: MASVS-CODE-4 291\\nOverview Foranypubliclyaccessibledatastorage,anyprocesscanoverridethedata. Thismeansthatinputvalidationneedstobe appliedthemomentthedataisreadbackagain. Note: Thesameistrueforprivateaccessibledataonarooteddevice Static analysis Using Shared Preferences WhenyouusetheSharedPreferences.Editortoreadorwriteint/boolean/longvalues, youcannotcheckwhetherthe data is overridden or not. However: it can hardly be used for actual", "metadata": {"doc_id": "OWASP_MASTG", "chunk_id": 108}}