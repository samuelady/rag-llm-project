{"text": "Integrity Checks Bypassing the application-source integrity checks 1. Patchtheanti-debuggingfunctionality. Disabletheunwantedbehaviorbysimplyoverwritingtheassociatedbyte- codeornativecodewithNOPinstructions. 2. Use Frida or Xposed to hook file system APIs on the Java and native layers. Return a handle to the original file insteadofthemodifiedfile. 3. Usethekernelmoduletointerceptfile-relatedsystemcalls. Whentheprocessattemptstoopenthemodifiedfile, returnafiledescriptorfortheunmodifiedversionofthefile. Refertothe“TamperingandReverseEngineeringonAndroid”chapterforexamplesofpatching,codeinjection,andkernel modules. Bypassing the storage integrity checks 1. Retrievethedatafromthedevice. 2. Altertheretrieveddataandthenputitbackintostorage. Effectiveness Assessment Application-sourceintegritychecks: Runtheappinanunmodifiedstateandmakesurethateverythingworks. Applysimplepatchestoclasses.dexandany .so libraries in the app package. Re-package and re-sign the app as described in the “Basic Security Testing” chapter, thenruntheapp. Theappshoulddetectthemodificationandrespondinsomeway. Attheveryleast, theappshould alerttheuserand/orterminate. Workonbypassingthedefensesandanswerthefollowingquestions: • Canthemechanismsbebypassedtrivially(e.g.,byhookingasingleAPIfunction)? • Howdifficultisidentifyingtheanti-debuggingcodeviastaticanddynamicanalysis? • Didyouneedtowritecustomcodetodisablethedefenses? Howmuchtimedidyouneed? • Whatisyourassessmentofthedifficultyofbypassingthemechanisms? Storageintegritychecks: Anapproachsimilartothatforapplication-sourceintegritychecksapplies. Answerthefollowingquestions: • Canthemechanismsbebypassedtrivially(e.g.,bychangingthecontentsofafileorakey-value)? 320\\n• HowdifficultisgettingtheHMACkeyortheasymmetricprivatekey? • Didyouneedtowritecustomcodetodisablethedefenses? Howmuchtimedidyouneed? • Whatisyourassessmentofthedifficultyofbypassingthemechanisms? Testing for Debugging Symbols Platform: android MASVSV1: MSTG-CODE-3 MASVSV2: MASVS-RESILIENCE-3 Overview Static Analysis Symbolsareusuallystrippedduringthebuildprocess,soyouneedthecompiledbytecodeandlibrariestomakesurethat unnecessarymetadatahasbeendiscarded. First,findthenmbinaryinyourAndroidNDKandexportit(orcreateanalias). export NM=$ANDROID_NDK_DIR/toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64/bin/arm-linux-androideabi-nm Todisplaydebugsymbols: $NM-alibfoo.so /tmp/toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64/bin/arm-linux-androideabi-nm:libfoo.so:nosymbols Todisplaydynamicsymbols: $NM-Dlibfoo.so Alternatively,openthefileinyourfavoritedisassemblerandcheckthesymboltablesmanually. Dynamicsymbolscanbestrippedviathevisibilitycompilerflag. Addingthisflagcausesgcctodiscardthefunction nameswhilepreservingthenamesoffunctionsdeclaredasJNIEXPORT. Makesurethatthefollowinghasbeenaddedtobuild.gradle: externalNativeBuild{ cmake{ cppFlags\"-fvisibility=hidden\" } } Dynamic Analysis Staticanalysisshouldbeusedtoverifydebuggingsymbols. Testing for Debugging Code and Verbose Error Logging Platform: android MASVSV1: MSTG-CODE-4 MASVSV2: MASVS-RESILIENCE-3 321\\nOverview Static Analysis To determine whether StrictMode is enabled, you can look for the StrictMode.setThreadPolicy or StrictMode. setVmPolicymethods. Mostlikely,theywillbeintheonCreatemethod. Thedetectionmethodsforthethreadpolicyare detectDiskWrites() detectDiskReads() detectNetwork() Thepenaltiesforthreadpolicyviolationare penaltyLog()//LogsamessagetoLogCat penaltyDeath()//Crashesapplication,runsattheendofallenabledpenalties penaltyDialog()//Showsadialog HavealookatthebestpracticesforusingStrictMode. Dynamic Analysis There are several ways of detecting StrictMode; the best choice depends on how the policies’ roles are implemented. Theyinclude • Logcat, • awarningdialog, • applicationcrash. Testing Anti-Debugging Detection Platform: android MASVSV1: MSTG-RESILIENCE-2 MASVSV2: MASVS-RESILIENCE-4 Bypassing Debugger Detection There’s no generic way to bypass anti-debugging: the best method depends on the particular mechanism(s) used to prevent or detect debugging and the other defenses in the overall protection scheme. For example, if there are no integrity checks or you’ve already deactivated them, patching the app might be the easiest method. In other cases, a hooking framework or kernel modules might be preferable. The following methods describe different approaches to bypassdebuggerdetection: • Patchingtheanti-debuggingfunctionality: DisabletheunwantedbehaviorbysimplyoverwritingitwithNOPinstruc- tions. Notethatmorecomplexpatchesmayberequirediftheanti-debuggingmechanismiswelldesigned. • UsingFridaorXposedtohookAPIsontheJavaandnativelayers: manipulatethereturnvaluesoffunctionssuch asisDebuggableandisDebuggerConnectedtohidethedebugger. • Changingtheenvironment: Androidisanopenenvironment. Ifnothingelseworks,youcanmodifytheoperating systemtosubverttheassumptionsthedevelopersmadewhendesigningtheanti-debuggingtricks. 322\\nBypassing Example: UnCrackable App for Android Level 2 When dealing with obfuscated apps, you’ll often find that developers purposely “hide away” data and functionality in nativelibraries. You’llfindanexampleofthisinlevel2ofthe“UnCrackableAppforAndroid”. At first glance, the code looks like the prior challenge. A class called CodeCheck is responsible for verifying the code enteredbytheuser. Theactualcheckappearstooccurinthebarmethod,whichisdeclaredasanativemethod. package sg.vantagepoint.uncrackable2; public class CodeCheck { public CodeCheck(){ super(); } public boolean a(Stringarg2){ return this.bar(arg2.getBytes()); } private native boolean bar(byte[]arg1){ } } static { System.loadLibrary(\"foo\"); } PleaseseedifferentproposedsolutionsfortheAndroidCrackmeLevel2inGitHub. Effectiveness Assessment Checkforanti-debuggingmechanisms,includingthefollowingcriteria: • Attachingjdbandptrace-baseddebuggersfailsorcausestheapptoterminateormalfunction. • Multipledetectionmethodsarescatteredthroughouttheapp’ssourcecode(asopposedtotheirallbeinginasingle methodorfunction). • Theanti-debuggingdefensesoperateonmultipleAPIlayers(Java,nativelibraryfunctions,assembler/systemcalls). • The mechanisms are somehow original (as opposed to being copied and pasted from StackOverflow or other sources). Workonbypassingtheanti-debuggingdefensesandanswerthefollowingquestions: • Canthemechanismsbebypassedtrivially(e.g.,byhookingasingleAPIfunction)? • Howdifficultisidentifyingtheanti-debuggingcodeviastaticanddynamicanalysis? • Didyouneedtowritecustomcodetodisablethedefenses? Howmuchtimedidyouneed? • Whatisyoursubjectiveassessmentofthedifficultyofbypassingthemechanisms? Ifanti-debuggingmechanismsaremissingortooeasilybypassed,makesuggestionsinlinewiththeeffectivenesscriteria above. Thesesuggestionsmayincludeaddingmoredetectionmechanismsandbetterintegrationofexistingmechanisms withotherdefenses. Testing Runtime Integrity Checks Platform: android MASVSV1: MSTG-RESILIENCE-6 MASVSV2: MASVS-RESILIENCE-2 Effectiveness Assessment Makesurethatallfile-baseddetectionofreverseengineeringtoolsisdisabled. Then,injectcodebyusingXposed,Frida, andSubstrate,andattempttoinstallnativehooksandJavamethodhooks. Theappshoulddetectthe“hostile”codein itsmemoryandrespondaccordingly. Workonbypassingthecheckswiththefollowingtechniques: 323\\n1. Patchtheintegritychecks. Disabletheunwantedbehaviorbyoverwritingtherespectivebytecodeornativecode withNOPinstructions. 2. UseFridaorXposedtohooktheAPIsusedfordetectionandreturnfakevalues. Refertothe“TamperingandReverseEngineeringonAndroid”chapterforexamplesofpatching,codeinjection,andkernel modules. Testing Obfuscation Platform: android MASVSV1: MSTG-RESILIENCE-9 MASVSV2: MASVS-RESILIENCE-3 Overview Static Analysis DecompiletheAPKandreviewittodeterminewhetherthecodebasehasbeenobfuscated. Belowyoucanfindasampleforanobfuscatedcodeblock: package com.a.a.a; import com.a.a.b.a; import java.util.List; class a$b extends a { public a$b(ListparamList) { super(paramList); } public boolean areAllItemsEnabled() { return true; } public boolean isEnabled(intparamInt) { return true; } } Herearesomeconsiderations: • Meaningfulidentifiers,suchasclassnames,methodnames,andvariablenames,mighthavebeendiscarded. • Stringresourcesandstringsinbinariesmighthavebeenencrypted. • Codeanddatarelatedtotheprotectedfunctionalitymightbeencrypted,packed,orotherwiseconcealed. Fornativecode: •", "metadata": {"doc_id": "OWASP_MASTG", "chunk_id": 118}}