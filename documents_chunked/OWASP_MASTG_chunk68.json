{"text": "this command fails, try running the following commandmount -o rw,remount -t ext4 /system • Preparetheproxy’sCAcertificatestomatchsystemcertificatesformat. Exporttheproxy’scertificatesinderformat (thisisthedefaultformatinBurpSuite)thenrunthefollowingcommands: $openssl x509 -inform DER-incacert.der -out cacert.pem $openssl x509 -inform PEM-subject_hash_old -incacert.pem |head -1 mvcacert.pem <hash>.0 • Finally,copythe<hash>.0fileintothedirectory/system/etc/security/cacertsandthenrunthefollowingcommand: chmod 644<hash>.0 By following the steps described above you allow any application to trust the proxy’s certificate, which allows you to interceptitstraffic,unlessofcoursetheapplicationusesSSLpinning. Potential Obstacles Applicationsoftenimplementsecuritycontrolsthatmakeitmoredifficulttoperformasecurityreviewoftheapplication, suchasrootdetectionandcertificatepinning. Ideally,youwouldacquirebothaversionoftheapplicationthathasthese controlsenabled,andonewherethecontrolsaredisabled. Thisallowsyoutoanalyzetheproperimplementationofthe controls,afterwhichyoucancontinuewiththeless-secureversionforfurthertests. Of course, this is not always possible, and you may need to perform a black-box assessment on an application where allsecuritycontrolsareenabled. Thesectionbelowshowsyouhowyoucancircumventcertificatepinningfordifferent applications. Client Isolation in Wireless Networks Onceyou have setup an interceptionproxyandhave a MITM position you mightstill not be able to seeanything. This mightbeduetorestrictionsintheapp(seenextsection)butcanalsobeduetosocalledclientisolationintheWi-Fithat youareconnectedto. WirelessClientIsolationisasecurityfeaturethatpreventswirelessclientsfromcommunicatingwithoneanother. This featureisusefulforguestandBYODSSIDsaddingalevelofsecuritytolimitattacksandthreatsbetweendevicesconnected tothewirelessnetworks. WhattodoiftheWi-Fiweneedfortestinghasclientisolation? YoucanconfiguretheproxyonyourAndroiddevicetopointto127.0.0.1:8080,connectyourphoneviaUSBtoyourhost computeranduseadbtomakeareverseportforwarding: 133\\nadbreversetcp:8080tcp:8080 Once you have done this all proxy traffic on your Android phone will be going to port 8080 on 127.0.0.1 and it will be redirectedviaadbto127.0.0.1:8080onyourhostcomputerandyouwillseenowthetrafficinyourBurp. Withthistrick youareabletotestandintercepttrafficalsoinWi-Fisthathaveclientisolation. Non-Proxy Aware Apps OnceyouhavesetupaninterceptionproxyandhaveaMITMpositionyoumightstillnotbeabletoseeanything. Thisis mainlyduetothefollowingreasons: • TheappisusingaframeworklikeXamarinthatsimplyisnotusingtheproxysettingsoftheAndroidOSor • Theappyouaretestingisverifyingifaproxyissetandisnotallowingnowanycommunication. In both scenarios you would need additional steps to finally being able to see the traffic. In the sections below we are describingtwodifferentsolutions,bettercapandiptables. You could also use an access point that is under your control to redirect the traffic, but this would require additional hardwareandwefocusfornowonsoftwaresolutions. Forbothsolutionsyouneedtoactivate“Supportinvisibleproxying”inBurp,inProxyTab/Options/EditInterface. iptables YoucanuseiptablesontheAndroiddevicetoredirectalltraffictoyourinterceptionproxy. Thefollowingcommandwould redirectport80toyourproxyrunningonport8080 iptables -tnat-AOUTPUT -ptcp--dport 80-jDNAT --to-destination <Your-Proxy-IP>:8080 VerifytheiptablessettingsandchecktheIPandport. $iptables -tnat-L ChainPREROUTING (policyACCEPT) target protoptsource destination ChainINPUT (policyACCEPT) target protoptsource destination ChainOUTPUT (policyACCEPT) target protoptsource destination DNAT tcp -- anywhere anywhere tcpdpt:5288to:<Your-Proxy-IP>:8080 ChainPOSTROUTING (policyACCEPT) target protoptsource destination Chainnatctrl_nat_POSTROUTING (0references) target protoptsource destination Chainoem_nat_pre (0references) target protoptsource destination Incaseyouwanttoresettheiptablesconfigurationyoucanflushtherules: iptables -tnat-F bettercap Readthechapter“TestingNetworkCommunication”andthetestcase“SimulatingaMan-in-the-MiddleAttack”forfurther preparationandinstructionsforrunningbettercap. ThehostcomputerwhereyourunyourproxyandtheAndroiddevicemustbeconnectedtothesamewirelessnetwork. Startbettercapwiththefollowingcommand,replacingtheIPaddressbelow(X.X.X.X)withtheIPaddressofyourAndroid device. 134\\n$sudobettercap -eval \"setarp.spoof.targetsX.X.X.X;arp.spoofon;setarp.spoof.internaltrue;setarp.spoof.fullduplextrue;\" bettercapv2.22 (builtfordarwinamd64withgo1.12.1)[type 'help' foralistofcommands] [19:21:39] [sys.log][inf]arp.spoofenablingforwarding [19:21:39] [sys.log][inf]arp.spoofarpspooferstarted,probing1targets. Proxy Detection Somemobileappsaretryingtodetectifaproxyisset. Ifthat’sthecasetheywillassumethatthisismaliciousandwill notworkproperly. Inordertobypasssuchaprotectionmechanismyoucouldeithersetupbettercaporconfigureiptablesthatdon’tneed aproxysetuponyourAndroidphone. Athirdoptionwedidn’tmentionbeforeandthatisapplicableinthisscenariois usingFrida. ItispossibleonAndroidtodetectifasystemproxyissetbyqueryingtheProxyInfoclassandcheckthe getHost()andgetPort()methods. Theremightbevariousothermethodstoachievethesametaskandyouwouldneed todecompiletheAPKinordertoidentifytheactualclassandmethodname. BelowyoucanfindboilerplatesourcecodeforaFridascriptthatwillhelpyoutooverloadthemethod(inthiscasecalled isProxySet)thatisverifyingifaproxyissetandwillalwaysreturnfalse. Evenifaproxyisnowconfiguredtheappwill nowthinkthatnoneissetasthefunctionreturnsfalse. setTimeout(function(){ Java.perform(function (){ console.log(\"[*]Scriptloaded\") varProxy =Java.use(\"<package-name>.<class-name>\") Proxy.isProxySet.overload().implementation =function(){ console.log(\"[*]isProxySetfunctioninvoked\") return false } }); }); Method Hooking Platform: android Xposed Let’sassumeyou’retestinganappthat’sstubbornlyquittingonyourrooteddevice. Youdecompiletheappandfindthe followinghighlysuspectmethod: package com.example.a.b public static boolean c(){ intv3=0; boolean v0=false; String[]v1=newString[]{\"/sbin/\",\"/system/bin/\",\"/system/xbin/\",\"/data/local/xbin/\", \"/data/local/bin/\",\"/system/sd/xbin/\",\"/system/bin/failsafe/\",\"/data/local/\"}; intv2=v1.length; for(intv3=0;v3<v2;v3++){ if(newFile(String.valueOf(v1[v3])+\"su\").exists()){ v0=true; return v0; } } return v0; } Thismethoditeratesthroughalistofdirectoriesandreturnstrue(devicerooted)ifitfindsthesubinaryinanyofthem. Checkslikethisareeasytodeactivateallyouhavetodoisreplacethecodewithsomethingthatreturns“false”. Method hookingwithanXposedmoduleisonewaytodothis(see“AndroidBasicSecurityTesting”formoredetailsonXposed installationandbasics). 135\\nThe method XposedHelpers.findAndHookMethod allows you to override existing class methods. By inspecting the de- compiledsourcecode, youcanfindoutthatthemethodperformingthecheckisc. Thismethodislocatedintheclass com.example.a.b. ThefollowingisanXposedmodulethatoverridesthefunctionsothatitalwaysreturnsfalse: package com.awesome.pentestcompany; import static de.robv.android.xposed.XposedHelpers.findAndHookMethod; import de.robv.android.xposed.IXposedHookLoadPackage; import de.robv.android.xposed.XposedBridge; import de.robv.android.xposed.XC_MethodHook; import de.robv.android.xposed.callbacks.XC_LoadPackage.LoadPackageParam; public class DisableRootCheck implements IXposedHookLoadPackage { public void handleLoadPackage(final LoadPackageParamlpparam)throws Throwable { if(!lpparam.packageName.equals(\"com.example.targetapp\")) return; findAndHookMethod(\"com.example.a.b\",lpparam.classLoader,\"c\",newXC_MethodHook(){ @Override protected void beforeHookedMethod(MethodHookParamparam)throws Throwable { XposedBridge.log(\"Caughtrootcheck!\"); param.setResult(false); } }); } } JustlikeregularAndroidapps,modulesforXposedaredevelopedanddeployedwithAndroidStudio. Formoredetailson writing,compiling,andinstallingXposedmodules,refertothetutorialprovidedbyitsauthor,rovo89. Frida We’lluseFridatosolvetheUnCrackableAppforAndroidLevel1anddemonstratehowwecaneasilybypassrootdetection andextractsecretdatafromtheapp. Whenyoustartthecrackmeapponanemulatororarooteddevice,you’llfindthattheitpresentsadialogboxandexits assoonasyoupress“OK”becauseitdetectedroot: 136\\nLet’sseehowwecanpreventthis. Themainmethod(decompiledwithCFR)lookslikethis: package sg.vantagepoint.uncrackable1; import android.app.Activity; import android.app.AlertDialog; import android.content.Context; import android.content.DialogInterface; import android.os.Bundle; import android.text.Editable; import android.view.View; import android.widget.EditText; import sg.vantagepoint.a.b; import sg.vantagepoint.a.c; import sg.vantagepoint.uncrackable1.a; public class MainActivity extends Activity { private void a(Stringstring){ AlertDialogalertDialog =newAlertDialog.Builder((Context)this).create(); alertDialog.setTitle((CharSequence)string); alertDialog.setMessage((CharSequence)\"Thisisunacceptable.Theappisnowgoingtoexit.\"); alertDialog.setButton(-3,(CharSequence)\"OK\",newDialogInterface.OnClickListener(){ public void onClick(DialogInterfacedialogInterface,intn){ System.exit((int)0); } }); alertDialog.setCancelable(false); alertDialog.show(); } protected void onCreate(Bundlebundle){ if(c.a()||c.b()||c.c()){ this.a(\"Rootdetected!\"); } if(b.a(this.getApplicationContext())) { this.a(\"Appisdebuggable!\"); } super.onCreate(bundle); this.setContentView(2130903040); } 137\\n/* *Enabledaggressiveblocksorting */ public void verify(Viewobject){ object =((EditText)this.findViewById(2130837505)).getText().toString(); AlertDialogalertDialog =newAlertDialog.Builder((Context)this).create(); if(a.a((String)object)){ alertDialog.setTitle((CharSequence)\"Success!\"); object =\"Thisisthecorrectsecret.\"; }else { alertDialog.setTitle((CharSequence)\"Nope...\"); object =\"That'snotit.Tryagain.\"; } alertDialog.setMessage((CharSequence)object); alertDialog.setButton(-3,(CharSequence)\"OK\",newDialogInterface.OnClickListener(){ public void onClick(DialogInterfacedialogInterface,intn){ dialogInterface.dismiss(); } }); alertDialog.show(); } } Notice the “Root detected”", "metadata": {"doc_id": "OWASP_MASTG", "chunk_id": 68}}