{"text": "Youcanusemethodtracingoncryptographicmethodstodetermineinput/outputvaluessuchasthekeysthatarebeing used. Monitor file system access while cryptographic operations are being performed to assess where key material is writtentoorreadfrom. Forexample,monitorthefilesystembyusingtheAPImonitorofRMS-RuntimeMobileSecurity. 226\\nAndroid Local Authentication Overview During local authentication, an app authenticates the user against credentials stored locally on the device. In other words, the user “unlocks” the app or some inner layer of functionality by providing a valid PIN, password or biometric characteristics such as face or fingerprint, which is verified by referencing local data. Generally, this is done so that userscanmoreconvenientlyresumeanexistingsessionwitharemoteserviceorasameansofstep-upauthentication toprotectsomecriticalfunction. Asstatedbeforeinchapter“MobileAppAuthenticationArchitectures”: Thetestershouldbeawarethatlocalauthentica- tionshouldalwaysbeenforcedataremoteendpointorbasedonacryptographicprimitive. Attackerscaneasilybypass localauthenticationifnodatareturnsfromtheauthenticationprocess. OnAndroid,therearetwomechanismssupportedbytheAndroidRuntimeforlocalauthentication: theConfirmCredential flowandtheBiometricAuthenticationflow. Confirm Credential Flow TheconfirmcredentialflowisavailablesinceAndroid6.0andisusedtoensurethatusersdonothavetoenterapp-specific passwordstogetherwiththelockscreenprotection. Instead: ifauserhasloggedintothedevicerecently,thenconfirm- credentialscanbeusedtounlockcryptographicmaterialsfromtheAndroidKeystore. Thatis,iftheuserunlockedthe devicewithinthesettimelimits(setUserAuthenticationValidityDurationSeconds),otherwisethedeviceneedstobe unlockedagain. NotethatthesecurityofConfirmCredentialsisonlyasstrongastheprotectionsetatthelockscreen. Thisoftenmeans thatsimplepredictivelock-screenpatternsareusedandthereforewedonotrecommendanyappswhichrequireL2of securitycontrolstouseConfirmCredentials. Biometric Authentication Flow Biometricauthenticationisaconvenientmechanismforauthentication,butalsointroducesanadditionalattacksurface whenusingit. TheAndroiddeveloperdocumentationgivesaninterestingoverviewandindicatorsformeasuringbiometric unlocksecurity. TheAndroidplatformoffersthreedifferentclassesforbiometricauthentication: • Android10(APIlevel29)andhigher: BiometricManager • Android9(APIlevel28)andhigher: BiometricPrompt • Android6.0(APIlevel23)andhigher: FingerprintManager(deprecatedinAndroid9(APIlevel28)) 227\\nTheclassBiometricManagercanbeusedtoverifyifbiometrichardwareisavailableonthedeviceandifit’sconfigured bytheuser. Ifthat’sthecase,theclassBiometricPromptcanbeusedtoshowasystem-providedbiometricdialog. TheBiometricPromptclassisasignificantimprovement,asitallowstohaveaconsistentUIforbiometricauthentication onAndroidandalsosupportsmoresensorsthanjustfingerprint. This is different to the FingerprintManager class which only supports fingerprint sensors and provides no UI, forcing developerstobuildtheirownfingerprintUI. AverydetailedoverviewandexplanationoftheBiometricAPIonAndroidwaspublishedontheAndroidDeveloperBlog. FingerprintManager (deprecated in Android 9 (API level 28)) Android 6.0 (API level 23) introduced public APIs for authenticating users via fingerprint, but is deprecated in Android 9 (API level 28). Access to the fingerprint hardware is provided through the FingerprintManager class. An app can request fingerprint authentication by instantiating aFingerprintManager object and calling its authenticate method. Thecallerregisterscallbackmethodstohandlepossibleoutcomesoftheauthenticationprocess(i.e.success,failure,or error). Notethatthismethoddoesn’tconstitutestrongproofthatfingerprintauthenticationhasactuallybeenperformed -forexample,theauthenticationstepcouldbepatchedoutbyanattacker,orthe“success”callbackcouldbeoverloaded usingdynamicinstrumentation. You can achieve better security by using the fingerprint API in conjunction with the Android KeyGenerator class. With thisapproach,asymmetrickeyisstoredintheAndroidKeyStoreandunlockedwiththeuser’sfingerprint. Forexample, to enable user access to a remote service, an AES key is created which encrypts the authentication token. By calling setUserAuthenticationRequired(true)whencreatingthekey,itisensuredthattheusermustre-authenticatetore- trieveit. Theencryptedauthenticationtokencanthenbesaveddirectlyonthedevice(e.g.viaSharedPreferences). This designisarelativelysafewaytoensuretheuseractuallyenteredanauthorizedfingerprint. Anevenmoresecureoptionisusingasymmetriccryptography. Here,themobileappcreatesanasymmetrickeypairin theKeyStoreandenrollsthepublickeyontheserverbackend. Latertransactionsarethensignedwiththeprivatekey andverifiedbytheserverusingthepublickey. 228\\nBiometric Library AndroidprovidesalibrarycalledBiometricwhichoffersacompatibilityversionoftheBiometricPromptandBiometric- ManagerAPIs,asimplementedinAndroid10,withfullfeaturesupportbacktoAndroid6.0(API23). YoucanfindareferenceimplementationandinstructionsonhowtoshowabiometricauthenticationdialogintheAndroid developerdocumentation. There are two authenticate methods available in the BiometricPrompt class. One of them expects a CryptoObject, whichaddsanadditionallayerofsecurityforthebiometricauthentication. TheauthenticationflowwouldbeasfollowswhenusingCryptoObject: • TheappcreatesakeyintheKeyStorewithsetUserAuthenticationRequiredandsetInvalidatedByBiometri- cEnrollmentsettotrue. Additionally,setUserAuthenticationValidityDurationSecondsshouldbesetto-1. • Thiskeyisusedtoencryptinformationthatisauthenticatingtheuser(e.g.sessioninformationorauthentication token). • AvalidsetofbiometricsmustbepresentedbeforethekeyisreleasedfromtheKeyStoretodecryptthedata,which isvalidatedthroughtheauthenticatemethodandtheCryptoObject. • This solution cannot be bypassed, even on rooted devices, as the key from the KeyStore can only be used after successfulbiometricauthentication. If CryptoObject is not used as part of the authenticate method, it can be bypassed by using Frida. See the “Dynamic Instrumentation”sectionformoredetails. DeveloperscanuseseveralvalidationclassesofferedbyAndroidtotesttheimplementationofbiometricauthentication intheirapp. FingerprintManager ThissectiondescribeshowtoimplementbiometricauthenticationbyusingtheFingerprintManagerclass. Please keepinmindthatthisclassisdeprecatedandtheBiometriclibraryshouldbeusedinsteadasabestpractice. This sectionisjustforreference,incaseyoucomeacrosssuchanimplementationandneedtoanalyzeit. Begin by searching for FingerprintManager.authenticate calls. The first parameter passed to this method should be a CryptoObject instance which is a wrapper class for crypto objects supported by FingerprintManager. Should the parameterbesettonull,thismeansthefingerprintauthorizationispurelyevent-bound,likelycreatingasecurityissue. ThecreationofthekeyusedtoinitializethecipherwrappercanbetracedbacktotheCryptoObject. Verifythekeywas bothcreatedusingtheKeyGeneratorclassinadditiontosetUserAuthenticationRequired(true)beingcalledduring creationoftheKeyGenParameterSpecobject(seecodesamplesbelow). Makesuretoverifytheauthenticationlogic. Fortheauthenticationtobesuccessful,theremoteendpointmustrequire theclienttopresentthesecretretrievedfromtheKeyStore,avaluederivedfromthesecret,oravaluesignedwiththe clientprivatekey(seeabove). Safelyimplementingfingerprintauthenticationrequiresfollowingafewsimpleprinciples,startingbyfirstcheckingifthat typeofauthenticationisevenavailable. Onthemostbasicfront, thedevicemustrunAndroid6.0orhigher(API23+). Fourotherprerequisitesmustalsobeverified: • ThepermissionmustberequestedintheAndroidManifest: <uses-permission android:name=\"android.permission.USE_FINGERPRINT\" /> • Fingerprinthardwaremustbeavailable: FingerprintManagerfingerprintManager =(FingerprintManager) context.getSystemService(Context.FINGERPRINT_SERVICE); fingerprintManager.isHardwareDetected(); • Theusermusthaveaprotectedlockscreen: KeyguardManagerkeyguardManager =(KeyguardManager)context.getSystemService(Context.KEYGUARD_SERVICE); keyguardManager.isKeyguardSecure(); //noteifthisisnotthecase:asktheusertosetupaprotectedlockscreen 229\\n• Atleastonefingershouldberegistered: fingerprintManager.hasEnrolledFingerprints(); • Theapplicationshouldhavepermissiontoaskforauserfingerprint: context.checkSelfPermission(Manifest.permission.USE_FINGERPRINT)==PermissionResult.PERMISSION_GRANTED; Ifanyoftheabovechecksfail,theoptionforfingerprintauthenticationshouldnotbeoffered. ItisimportanttorememberthatnoteveryAndroiddeviceoffershardware-backedkeystorage. TheKeyInfoclasscanbe usedtofindoutwhetherthekeyresidesinsidesecurehardwaresuchasaTrustedExecutionEnvironment(TEE)orSecure Element(SE). SecretKeyFactoryfactory =SecretKeyFactory.getInstance(getEncryptionKey().getAlgorithm(),ANDROID_KEYSTORE); KeyInfosecetkeyInfo =(KeyInfo)factory.getKeySpec(yourencryptionkeyhere,KeyInfo.class); secetkeyInfo.isInsideSecureHardware() On certain systems, it is possible to enforce the policy for biometric authentication through hardware as well. This is checkedby: keyInfo.isUserAuthenticationRequirementEnforcedBySecureHardware(); Thefollowingdescribeshowtodofingerprintauthenticationusingasymmetrickeypair. Fingerprint authentication may be implemented by creating a new AES key using the KeyGenerator class by adding setUserAuthenticationRequired(true)inKeyGenParameterSpec.Builder. generator =KeyGenerator.getInstance(KeyProperties.KEY_ALGORITHM_AES,KEYSTORE); generator.init(newKeyGenParameterSpec.Builder (KEY_ALIAS, KeyProperties.PURPOSE_ENCRYPT |KeyProperties.PURPOSE_DECRYPT) .setBlockModes(KeyProperties.BLOCK_MODE_CBC) .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_PKCS7) .setUserAuthenticationRequired(true) .build() ); generator.generateKey(); Toperformencryptionordecryptionwiththeprotectedkey,createaCipherobjectandinitializeitwiththekeyalias. SecretKeykeyspec =(SecretKey)keyStore.getKey(KEY_ALIAS,null); if(mode ==Cipher.ENCRYPT_MODE){ cipher.init(mode,keyspec); Keep in mind, a new key cannot be used immediately - it has to be authenticated through the FingerprintMan- ager first.", "metadata": {"doc_id": "OWASP_MASTG", "chunk_id": 91}}