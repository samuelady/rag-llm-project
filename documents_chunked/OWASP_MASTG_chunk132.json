{"text": "decompiler, making it a compellingalternativetouseforreverseengineering. IfyouhavearegularIDAProlicenseanddonotwanttobuytheHex-Raysdecompiler,youcanuseGhidra’sdecompiler byinstallingtheGhIDApluginforIDAPro. ThemajorityofthischapterappliestoapplicationswritteninObjective-Corhavingbridgedtypes,whicharetypescom- patible with both Swift and Objective-C. The Swift compatibility of most tools that work well with Objective-C is being improved. 376\\nReviewing Decompiled Objective-C and Swift Code Platform: ios TODO:Don’thavethisyet Reviewing Disassembled Objective-C and Swift Code Platform: ios In this section we will be exploring iOS application’s binary code manually and perform static analysis on it. Manual analysiscanbeaslowprocessandrequiresimmensepatience. Agoodmanualanalysiscanmakethedynamicanalysis moresuccessful. Therearenohardwrittenrulesforperformingstaticanalysis,buttherearefewrulesofthumbwhichcanbeusedtohave asystematicapproachtomanualanalysis: • Understandtheworkingoftheapplicationunderevaluation-theobjectiveoftheapplicationandhowitbehaves incaseofwronginput. • Explore the various strings present in the application binary, this can be very helpful, for example in spotting interestingfunctionalitiesandpossibleerrorhandlinglogicintheapplication. • Lookforfunctionsandclasseshavingnamesrelevanttoourobjective. • Lastly,findthevariousentrypointsintotheapplicationandfollowalongfromtheretoexploretheapplication. Techniquesdiscussedinthissectionaregenericandapplicableirrespectiveofthetoolsusedforanalysis. Objective-C Inadditiontothetechniqueslearnedinthe“DisassemblingandDecompiling”section,forthissectionyou’llneedsome understanding of the Objective-C runtime. For instance, functions like _objc_msgSend or _objc_release are specially meaningfulfortheObjective-Cruntime. WewillbeusingtheUnCrackableAppforiOSLevel1,whichhasthesimplegoaloffindingasecretstringhiddensomewhere inthebinary. Theapplicationhasasinglehomescreenandausercaninteractviainputtingcustomstringsintheprovided textfield. Whentheuserinputsthewrongstring,theapplicationshowsapop-upwiththe“VerificationFailed”message. 377\\nYou can keep note of the strings displayed in the pop-up, as this might be helpful when searching for the code where the input is processed and a decision is being made. Luckily, the complexity and interaction with this application is straightforward,whichbodeswellforourreversingendeavors. Forstaticanalysisinthissection,wewillbeusingGhidra9.0.4. Ghidra9.1_betaauto-analysishasabuganddoes notshowtheObjective-Cclasses. WecanstartbycheckingthestringspresentinthebinarybyopeningitinGhidra. Thelistedstringsmightbeoverwhelming atfirst,butwithsomeexperienceinreversingObjective-Ccode,you’lllearnhowtofilteranddiscardthestringsthatare notreallyhelpfulorrelevant. Forinstance,theonesshowninscreenshotbelow,whicharegeneratedfortheObjective-C runtime. Otherstringsmightbehelpfulinsomecases,suchasthosecontainingsymbols(functionnames,classnames, etc.) andwe’llbeusingthemwhenperformingstaticanalysistocheckifsomespecificfunctionisbeingused. 378\\nIf we continue our careful analysis, we can spot the string, “Verification Failed”, which is used for the pop-up when a wronginputisgiven. Ifyoufollowthecross-references(Xrefs)ofthisstring,youwillreachbuttonClickfunctionofthe ViewControllerclass. WewilllookintothebuttonClickfunctionlaterinthissection. Whenfurthercheckingtheother strings in the application, only a few of them look a likely candidate for a hidden flag. You can try them and verify as well. 379\\nMoving forward, we have two paths to take. Either we can start analyzing the buttonClick function identified in the abovestep,orstartanalyzingtheapplicationfromthevariousentrypoints. Inrealworldsituation,mosttimesyouwill betakingthefirstpath,butfromalearningperspective,inthissectionwewilltakethelatterpath. AniOSapplicationcallsdifferentpredefinedfunctionsprovidedbytheiOSruntimedependingonitsthestatewithinthe applicationlifecycle. Thesefunctionsareknownastheentrypointsoftheapp. Forexample: • [AppDelegate application:didFinishLaunchingWithOptions:] iscalledwhentheapplicationisstartedforthe firsttime. • [AppDelegate applicationDidBecomeActive:] iscalled when the application is moving frominactive to active state. Manyapplicationsexecutecriticalcodeinthesesectionsandthereforethey’renormallyagoodstartingpointinorderto followthecodesystematically. Oncewe’redonewiththeanalysisofallthefunctionsintheAppDelegateclass,wecanconcludethatthereisnorelevant codepresent. Thelackofanycodeintheabovefunctionsraisesthequestion-fromwhereistheapplication’sinitialization codebeingcalled? Luckilythecurrentapplicationhasasmallcodebase,andwecanfindanotherViewControllerclassintheSymbolTree view. Inthisclass,functionviewDidLoadfunctionlooksinteresting. IfyoucheckthedocumentationofviewDidLoad,you canseethatitcanalsobeusedtoperformadditionalinitializationonviews. 380\\nIfwecheckthedecompilationofthisfunction,thereareafewinterestingthingsgoingon. Forinstance,thereisacallto anativefunctionatline31andalabelisinitializedwithasetHiddenflagsetto1inlines27-29. Youcankeepanoteof theseobservationsandcontinueexploringtheotherfunctionsinthisclass. Forbrevity,exploringtheotherpartsofthe functionisleftasanexerciseforthereaders. In our first step, we observed that the application verifies the input string only when the UI button is pressed. Thus, analyzingthebuttonClickfunctionisanobvioustarget. Asearliermentioned,thisfunctionalsocontainsthestringwe seeinthepop-ups. Atline29adecisionisbeingmade,whichisbasedontheresultofisEqualString(outputsavedin uVar1atline23). Theinputforthecomparisoniscomingfromthetextinputfield(fromtheuser)andthevalueofthe label. Therefore,wecanassumethatthehiddenflagisstoredinthatlabel. 381\\nNowwehavefollowedthecompleteflowandhavealltheinformationabouttheapplicationflow. Wealsoconcludedthat thehiddenflagispresentinatextlabelandinordertodeterminethevalueofthelabel,weneedtorevisitviewDidLoad function,andunderstandwhatishappeninginthenativefunctionidentified. Analysisofthenativefunctionisdiscussed in“ReviewingDisassembledNativeCode”. Bypassing Certificate Pinning Platform: ios SomeapplicationswillimplementSSLPinning,whichpreventstheapplicationfromacceptingyourinterceptingcertificate asavalidcertificate. Thismeansthatyouwillnotbeabletomonitorthetrafficbetweentheapplicationandtheserver. Formostapplications,certificatepinningcanbebypassedwithinseconds,butonlyiftheappusestheAPIfunctionsthat 382\\narecoveredbythesetools. IftheappisimplementingSSLPinningwithacustomframeworkorlibrary,theSSLPinning mustbemanuallypatchedanddeactivated,whichcanbetime-consuming. ThissectiondescribesvariouswaystobypassSSLPinningandgivesguidanceaboutwhatyoushoulddowhentheexisting toolsdon’twork. Methods for Jailbroken and Non-jailbroken Devices Ifyouhaveajailbrokendevicewithfrida-serverinstalled,youcanbypassSSLpinningbyrunningthefollowingObjection command(repackageyourappifyou’reusinganon-jailbrokendevice): iossslpinningdisable Here’sanexampleoftheoutput: SeealsoObjection’shelponDisablingSSLPinningforiOSforfurtherinformationandinspectthepinning.tsfiletounder- standhowthebypassworks. Methods for Jailbroken Devices Only IfyouhaveajailbrokendeviceyoucantryoneofthefollowingtoolsthatcanautomaticallydisableSSLPinning: • “SSLKillSwitch2”isonewaytodisablecertificatepinning. ItcanbeinstalledviatheCydiastore. Itwillhookonto allhigh-levelAPIcallsandbypasscertificatepinning. • TheBurpSuiteMobileAssistantappcanalsobeusedtobypasscertificatepinning. When the Automated Bypasses Fail Technologiesandsystemschangeovertime,andsomebypasstechniquesmightnotworkeventually. Hence,it’spartof thetesterworktodosomeresearch,sincenoteverytoolisabletokeepupwithOSversionsquicklyenough. SomeappsmightimplementcustomSSLpinningmethods,sothetestercouldalsodevelopnewbypassscriptsmaking useofexistingonesasabaseorinspirationandusingsimilartechniquesbuttargetingtheapp’scustomAPIs. Hereyou caninspectthreegoodexamplesofsuchscripts: • “objection-PinningBypassModule”(pinning.ts) • “FridaCodeShare-ios10-ssl-bypass”by@dki • “CircumventingSSLPinninginobfuscatedappswithOkHttp”byJeroenBeckers 383\\nOtherTechniques: Ifyoudon’thaveaccesstothesource,youcantrybinarypatching: • IfOpenSSLcertificatepinningisused,youcantrybinarypatching. • Sometimes,thecertificateisafileintheapplicationbundle. ReplacingthecertificatewithBurp’scertificatemay besufficient,butbewareofthecertificate’sSHAsum. Ifit’shardcodedintothebinary,youmustreplaceittoo! • Ifyoucanaccessthesourcecodeyoucouldtrytodisablecertificatepinningandrecompiletheapp, lookforAPI callsforNSURLSession,CFStream,andAFNetworkingandmethods/stringscontainingwordslike“pinning”,“X.509”, “Certificate”,etc. Listing Installed Apps Platform: ios When targeting apps that are installed on the device, you’ll first have to figure out the correct bundle identifier of the applicationyouwanttoanalyze. Youcanusefrida-ps-Uaitogetallapps(-a)currentlyinstalled(-i)ontheconnected USBdevice(-U): $frida-ps -Uai PID Name Identifier ---- ------------------- ----------------------------------------- 6847 Calendar com.apple.mobilecal 6815 Mail com.apple.mobilemail - AppStore com.apple.AppStore - AppleStore com.apple.store.Jolly - Calculator com.apple.calculator - Camera com.apple.camera - iGoat-Swift OWASP.iGoat-Swift Italsoshowswhichofthemarecurrentlyrunning. Takeanoteofthe“Identifier”(bundleidentifier)andthePIDifanyas you’llneedthemafterwards. YoucanalsodirectlyopenGrapefruitandafterselectingyouriOSdeviceyou’llgetthelistofinstalledapps. Debugging Platform: ios ComingfromaLinuxbackgroundyou’dexpecttheptracesystemcalltobeaspowerfulasyou’reusedtobut,forsome reason, Apple decided to leave it incomplete. iOS debuggers such as LLDB use it for attaching, stepping or continuing theprocessbuttheycannotuseittoreadorwritememory(allPT_READ_*andPT_WRITE*requestsaremissing). Instead, they have to obtain a so-called Mach task port (by calling task_for_pid with the target process ID) and then use the", "metadata": {"doc_id": "OWASP_MASTG", "chunk_id": 132}}