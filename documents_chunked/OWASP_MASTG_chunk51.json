{"text": "vulnerable to the padding oracle attack. Therefore, it is best to use OAEP (Optimal Asymmetric Encryption Padding) captured in PKCS#1 v2.0 (in code: OAEPPadding, OAEPwithSHA-256andMGF1Padding, OAEPwithSHA-224andMGF1Padding, OAEPwithSHA-384andMGF1Padding, OAEPwithSHA-512andMGF1Padding). Note that, even when using OAEP, you can still run into an issue known best as the Manger’s attack as described in the blog at Kudelskisecurity. Note: AES-CBCwithPKCS#5hasshowntobevulnerabletopaddingoracleattacksaswell,giventhattheimplementation giveswarnings,suchas“Paddingerror”,“MACerror”,or“decryptionfailed”. SeeThePaddingOracleAttackandTheCBC PaddingOracleProblemforanexample. Next,itisbesttoensurethatyouaddanHMACafteryouencrypttheplaintext: afterallaciphertextwithafailingMACwillnothavetobedecryptedandcanbediscarded. Protecting Keys in Storage and in Memory When memory dumping is part of your threat model, then keys can be accessed the moment they are actively used. Memorydumpingeitherrequiresroot-access(e.g.arooteddeviceorjailbrokendevice)oritrequiresapatchedapplication withFrida(soyoucanusetoolslikeFridump). Thereforeitisbesttoconsiderthefollowing,ifkeysarestillneededatthe device: • KeysinaRemoteServer: youcanuseremoteKeyvaultssuchasAmazonKMSorAzureKeyVault. Forsomeuse cases,developinganorchestrationlayerbetweentheappandtheremoteresourcemightbeasuitableoption. For instance,aserverlessfunctionrunningonaFunctionasaService(FaaS)system(e.g.AWSLambdaorGoogleCloud Functions)whichforwardsrequeststoretrieveanAPIkeyorsecret. ThereareotheralternativessuchasAmazon Cognito,GoogleIdentityPlatformorAzureActiveDirectory. • Keys inside Secure Hardware-backed Storage: make sure that all cryptographic actions and the key itself remainintheTrustedExecutionEnvironment(e.g.useAndroidKeystore)orSecureEnclave(e.g.usetheKeychain). RefertotheAndroidDataStorageandiOSDataStoragechaptersformoreinformation. • KeysprotectedbyEnvelopeEncryption: IfkeysarestoredoutsideoftheTEE/SE,considerusingmulti-layered encryption: anenvelopeencryptionapproach(seeOWASPCryptographicStorageCheatSheet,GoogleCloudKey managementguide,AWSWell-ArchitectedFrameworkguide),oraHPKEapproachtoencryptdataencryptionkeys withkeyencryptionkeys. 75\\n• KeysinMemory: makesurethatkeysliveinmemoryfortheshortesttimepossibleandconsiderzeroingoutand nullifyingkeysaftersuccessfulcryptographicoperations,andincaseoferror. Forgeneralcryptocodingguidelines, refertoCleanmemoryofsecretdata. Note: giventheeaseofmemorydumping,neversharethesamekeyamongaccountsand/ordevices,otherthanpublic keysusedforsignatureverificationorencryption. Protecting Keys in Transport Whenkeysneedtobetransportedfromonedevicetoanother,orfromtheapptoabackend,makesurethatproperkey protectionisinplace,bymeansofatransportkeypairoranothermechanism. Often,keysaresharedwithobfuscation methods which can be easily reversed. Instead, make sure asymmetric cryptography or wrapping keys are used. For example,asymmetrickeycanbeencryptedwiththepublickeyfromanasymmetrickeypair. Cryptographic APIs on Android and iOS WhilesamebasiccryptographicprinciplesapplyindependentoftheparticularOS,eachoperatingsystemoffersitsown implementationandAPIs. Platform-specificcryptographicAPIsfordatastoragearecoveredingreaterdetailinthe“Data StorageonAndroid”and“TestingDataStorageoniOS”chapters. Encryptionofnetworktraffic,especiallyTransportLayer Security(TLS),iscoveredinthe“AndroidNetworkAPIs”chapter. Cryptographic Policy Inlargerorganizations,orwhenhigh-riskapplicationsarecreated,itcanoftenbeagoodpracticetohaveacryptographic policy, based on frameworks such as NIST Recommendation for Key Management. When basic errors are found in the applicationofcryptography,itcanbeagoodstartingpointofsettingupalessonslearned/cryptographickeymanagement policy. Cryptography Regulations WhenyouuploadtheapptotheAppStoreorGooglePlay,yourapplicationistypicallystoredonaUSserver. Ifyourapp containscryptographyandisdistributedtoanyothercountry,itisconsideredacryptographyexport. Itmeansthatyou needtofollowUSexportregulationsforcryptography. Also,somecountrieshaveimportregulationsforcryptography. Learnmore: • ComplyingwithEncryptionExportRegulations(Apple) • Exportcomplianceoverview(Apple) • Exportcompliance(Google) • EncryptionandExportAdministrationRegulations(USA) • EncryptionControl(France) • Worldmapofencryptionlawsandpolicies 76\\nMobile App Code Quality Mobileappdevelopersuseawidevarietyofprogramminglanguagesandframeworks. Assuch,commonvulnerabilities such as SQL injection, buffer overflows, and cross-site scripting (XSS), may manifest in apps when neglecting secure programmingpractices. The same programming flaws may affect both Android and iOS apps to some degree, so we’ll provide an overview of the most common vulnerability classes frequently in the general section of the guide. In later sections, we will cover OS-specificinstancesandexploitmitigationfeatures. Injection Flaws Aninjectionflawdescribesaclassofsecurityvulnerabilityoccurringwhenuserinputisinsertedintobackendqueriesor commands. By injecting meta-characters, an attacker can execute malicious code that is inadvertently interpreted as partofthecommandorquery. Forexample,bymanipulatingaSQLquery,anattackercouldretrievearbitrarydatabase recordsormanipulatethecontentofthebackenddatabase. Vulnerabilitiesofthisclassaremostprevalentinserver-sidewebservices. Exploitableinstancesalsoexistwithinmobile apps,butoccurrencesarelesscommon,plustheattacksurfaceissmaller. Forexample,whileanappmightqueryalocalSQLitedatabase,suchdatabasesusuallydonotstoresensitivedata(assum- ingthedeveloperfollowedbasicsecuritypractices). ThismakesSQLinjectionanon-viableattackvector. Nevertheless, exploitable injection vulnerabilities sometimes occur, meaning proper input validation is a necessary best practice for programmers. SQL Injection A SQL injection attack involves integrating SQL commands into input data, mimicking the syntax of a predefined SQL command. A successful SQL injection attack allows the attacker to read or write to the database and possibly execute administrativecommands,dependingonthepermissionsgrantedbytheserver. AppsonbothAndroidandiOSuseSQLitedatabasesasameanstocontrolandorganizelocaldatastorage. Assumean Android app handles local user authentication by storing the user credentials in a local database (a poor programming practicewe’lloverlookforthesakeofthisexample). Uponlogin,theappqueriesthedatabasetosearchforarecordwith theusernameandpasswordenteredbytheuser: SQLiteDatabasedb; Stringsql =\"SELECT*FROMusersWHEREusername='\" + username +\"'ANDpassword='\" +password +\"'\"; Cursorc =db.rawQuery(sql,null ); return c.getCount()!=0; Let’sfurtherassumeanattackerentersthefollowingvaluesintothe“username”and“password”fields: username =1'or'1'='1 password =1'or'1'='1 Thisresultsinthefollowingquery: SELECT *FROM users WHERE username='1'OR'1'='1'ANDPassword='1'OR'1'= '1' Becausethecondition'1'='1'alwaysevaluatesastrue,thisqueryreturnallrecordsinthedatabase,causingthelogin functiontoreturntrueeventhoughnovaliduseraccountwasentered. OstorlabexploitedthesortparameterofYahoo’sweathermobileapplicationwithadbusingthisSQLinjectionpayload. Another real-world instance of client-side SQL injection was discovered by Mark Woods within the “Qnotes” and “Qget” AndroidappsrunningonQNAPNASstorageappliances. TheseappsexportedcontentprovidersvulnerabletoSQLinjection, allowinganattackertoretrievethecredentialsfortheNASdevice. Adetaileddescriptionofthisissuecanbefoundon theNettitudeBlog. 77\\nXML Injection InaXMLinjectionattack,theattackerinjectsXMLmeta-characterstostructurallyalterXMLcontent. Thiscanbeusedto eithercompromisethelogicofanXML-basedapplicationorservice,aswellaspossiblyallowanattackertoexploitthe operationoftheXMLparserprocessingthecontent. ApopularvariantofthisattackisXMLeXternalEntity(XXE).Here, anattackerinjectsanexternalentitydefinitioncon- taininganURIintotheinputXML.Duringparsing,theXMLparserexpandstheattacker-definedentitybyaccessingthe resourcespecifiedbytheURI.Theintegrityoftheparsingapplicationultimatelydeterminescapabilitiesaffordedtothe attacker, wherethemalicioususer coulddoany(orall) ofthefollowing: accesslocalfiles, triggerHTTPrequeststoar- bitraryhostsandports, launchacross-siterequestforgery(CSRF)attack, andcauseadenial-of-servicecondition. The OWASPwebtestingguidecontainsthefollowingexampleforXXE: <?xml version=\"1.0\" encoding=\"ISO-8859-1\"?> <!DOCTYPE foo[ <!ELEMENT fooANY> <!ENTITY xxeSYSTEM \"file:///dev/random\" >]><foo>&xxe;</foo> Inthisexample,thelocalfile/dev/randomisopenedwhereanendlessstreamofbytesisreturned,potentiallycausinga denial-of-service. The current trend in app development focuses mostly on REST/JSON-based services as XML is becoming less common. However,intherarecaseswhereuser-suppliedorotherwiseuntrustedcontentisusedtoconstructXMLqueries,itcould be interpreted by local XML parsers, such as NSXMLParser on", "metadata": {"doc_id": "OWASP_MASTG", "chunk_id": 51}}