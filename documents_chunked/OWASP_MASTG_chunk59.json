{"text": "TouseIPC,appscallIPCmethodsinproxyobjects. TheproxyobjectstransparentlymarshallthecallparametersintoaparcelandsendatransactiontotheBinderserver, whichisimplementedasacharacterdriver(/dev/binder). Theserverholdsathreadpoolforhandlingincomingrequests anddeliversmessagestothedestinationobject. Fromtheperspectiveoftheclientapp,allofthisseemslikearegular methodcall,alltheheavyliftingisdonebytheBinderframework. • BinderOverview-Imagesource: AndroidBinderbyThorstenSchreiber Servicesthatallowotherapplicationstobindtothemarecalledboundservices. TheseservicesmustprovideanIBinder interface to clients. Developers use the Android Interface Descriptor Language (AIDL) to write interfaces for remote services. ServiceManagerisasystemdaemonthatmanagestheregistrationandlookupofsystemservices. Itmaintainsalistof name/Binderpairsforallregisteredservices. ServicesareaddedwithaddServiceandretrievedbynamewiththestatic getServicemethodinandroid.os.ServiceManager: ExampleinJava: 101\\npublic static IBinder getService(Stringname){ try{ IBinderservice =sCache.get(name); if(service !=null){ return service; }else { return getIServiceManager().getService(name); } }catch (RemoteExceptione){ Log.e(TAG,\"erroringetService\",e); } return null; } ExampleinKotlin: companion object { private valsCache:Map<String,IBinder>=ArrayMap() fungetService(name:String):IBinder?{ try{ valservice =sCache[name] return service ?:getIServiceManager().getService(name) }catch (e:RemoteException){ Log.e(FragmentActivity.TAG,\"erroringetService\",e) } return null } } Youcanquerythelistofsystemserviceswiththeservice listcommand. $adbshellservicelist Found99services: 0carrier_config: [com.android.internal.telephony.ICarrierConfigLoader] 1phone: [com.android.internal.telephony.ITelephony] 2isms: [com.android.internal.telephony.ISms] 3iphonesubinfo: [com.android.internal.telephony.IPhoneSubInfo] Intents IntentmessagingisanasynchronouscommunicationframeworkbuiltontopofBinder. Thisframeworkallowsbothpoint- to-pointandpublish-subscribemessaging. AnIntent isamessagingobjectthatcanbeusedtorequestanactionfrom another app component. Although intents facilitate inter-component communication in several ways, there are three fundamentalusecases: • Startinganactivity – An activity represents a single screen in an app. You can start a new instance of an activity by passing an intenttostartActivity. Theintentdescribestheactivityandcarriesnecessarydata. • Startingaservice – AServiceisacomponentthatperformsoperationsinthebackground,withoutauserinterface. WithAndroid 5.0(APIlevel21)andlater,youcanstartaservicewithJobScheduler. • Deliveringabroadcast – Abroadcastisamessagethatanyappcanreceive. Thesystemdeliversbroadcastsforsystemevents,includ- ingsystembootandcharginginitialization. Youcandeliverabroadcasttootherappsbypassinganintentto sendBroadcastorsendOrderedBroadcast. Therearetwotypesofintents. Explicitintentsnamethecomponentthatwillbestarted(thefullyqualifiedclassname). Forinstance: ExampleinJava: Intentintent =newIntent(this,myActivity.myClass); ExampleinKotlin: 102\\nvarintent =Intent(this,myActivity.myClass) ImplicitintentsaresenttotheOStoperformagivenactiononagivensetofdata(TheURLoftheOWASPwebsiteinour examplebelow). Itisuptothesystemtodecidewhichapporclasswillperformthecorrespondingservice. Forinstance: ExampleinJava: Intentintent =newIntent(Intent.MY_ACTION,Uri.parse(\"https://www.owasp.org\")); ExampleinKotlin: varintent =Intent(Intent.MY_ACTION,Uri.parse(\"https://www.owasp.org\")) An intent filter is an expression in Android Manifest files that specifies the type of intents the component would like to receive. Forinstance,bydeclaringanintentfilterforanactivity,youmakeitpossibleforotherappstodirectlystartyour activitywithacertainkindofintent. Likewise,youractivitycanonlybestartedwithanexplicitintentifyoudon’tdeclare anyintentfiltersforit. Androidusesintentstobroadcastmessagestoapps(suchasanincomingcallorSMS)importantpowersupplyinformation (lowbattery,forexample),andnetworkchanges(lossofconnection,forinstance). Extradatamaybeaddedtointents (throughputExtra/getExtras). Hereisashortlistofintentssentbytheoperatingsystem. AllconstantsaredefinedintheIntentclass,andthewhole listisintheofficialAndroiddocumentation: • ACTION_CAMERA_BUTTON • ACTION_MEDIA_EJECT • ACTION_NEW_OUTGOING_CALL • ACTION_TIMEZONE_CHANGED To improve security and privacy, a Local Broadcast Manager is used to send and receive intents within an app without havingthemsenttotherestoftheoperatingsystem. Thisisveryusefulforensuringthatsensitiveandprivatedatadon’t leavetheappperimeter(geolocationdataforinstance). Broadcast Receivers BroadcastReceiversarecomponentsthatallowappstoreceivenotificationsfromotherappsandfromthesystemitself. With them, apps can react to events (internal, initiated by other apps, or initiated by the operating system). They are generallyusedtoupdateuserinterfaces,startservices,updatecontent,andcreateusernotifications. TherearetwowaystomakeaBroadcastReceiverknowntothesystem. OnewayistodeclareitintheAndroidManifest file. ThemanifestshouldspecifyanassociationbetweentheBroadcastReceiverandanintentfiltertoindicatetheactions thereceiverismeanttolistenfor. AnexampleBroadcastReceiverdeclarationwithanintentfilterinamanifest: <receiver android:name=\".MyReceiver\" > <intent-filter> <action android:name=\"com.owasp.myapplication.MY_ACTION\" /> </intent-filter> </receiver> Pleasenotethatinthisexample,theBroadcastReceiverdoesnotincludetheandroid:exportedattribute. Asatleast onefilterwasdefined,thedefaultvaluewillbesetto“true”. Inabsenceofanyfilters,itwillbesetto“false”. Theotherwayistocreatethereceiverdynamicallyincode. ThereceivercanthenregisterwiththemethodContext. registerReceiver. AnexampleofregisteringaBroadcastReceiverdynamically: ExampleinJava: 103\\n//Defineabroadcastreceiver BroadcastReceivermyReceiver =newBroadcastReceiver(){ @Override public void onReceive(Contextcontext,Intentintent){ Log.d(TAG,\"IntentreceivedbymyReceiver\"); } }; //Defineanintentfilterwithactionsthatthebroadcastreceiverlistensfor IntentFilterintentFilter =newIntentFilter(); intentFilter.addAction(\"com.owasp.myapplication.MY_ACTION\"); //Toregisterthebroadcastreceiver registerReceiver(myReceiver,intentFilter); //Toun-registerthebroadcastreceiver unregisterReceiver(myReceiver); ExampleinKotlin: //Defineabroadcastreceiver valmyReceiver:BroadcastReceiver =object :BroadcastReceiver(){ override funonReceive(context:Context,intent:Intent){ Log.d(FragmentActivity.TAG,\"IntentreceivedbymyReceiver\") } } //Defineanintentfilterwithactionsthatthebroadcastreceiverlistensfor valintentFilter =IntentFilter() intentFilter.addAction(\"com.owasp.myapplication.MY_ACTION\") //Toregisterthebroadcastreceiver registerReceiver(myReceiver,intentFilter) //Toun-registerthebroadcastreceiver unregisterReceiver(myReceiver) Notethatthesystemstartsanappwiththeregisteredreceiverautomaticallywhenarelevantintentisraised. According to Broadcasts Overview, a broadcast is considered “implicit” if it does not target an app specifically. After receivinganimplicitbroadcast,Androidwilllistallappsthathaveregisteredagivenactionintheirfilters. Ifmorethan oneapphasregisteredforthesameaction,Androidwillprompttheusertoselectfromthelistofavailableapps. An interesting feature of Broadcast Receivers is that they can be prioritized; this way, an intent will be delivered to all authorized receivers according to their priority. A priority can be assigned to an intent filter in the manifest via the android:priority attribute as well as programmatically via the IntentFilter.setPriority method. However, note thatreceiverswiththesameprioritywillberuninanarbitraryorder. Ifyourappisnotsupposedtosendbroadcastsacrossapps,useaLocalBroadcastManager(LocalBroadcastManager). Theycanbeusedtomakesureintentsarereceivedfromtheinternalapponly, andanyintentfromanyotherappwill bediscarded. Thisisveryusefulforimprovingsecurityandtheefficiencyoftheapp,asnointerprocesscommunication isinvolved. However,pleasenotethattheLocalBroadcastManagerclassisdeprecatedandGooglerecommendsusing alternativessuchasLiveData. FormoresecurityconsiderationsregardingBroadcastReceiver,seeSecurityConsiderationsandBestPractices. Implicit Broadcast Receiver Limitation AccordingtoBackgroundOptimizations,appstargetingAndroid7.0(APIlevel24)orhighernolongerreceiveCONNECTIV- ITY_ACTION broadcast unless they register their Broadcast Receivers with Context.registerReceiver(). The system doesnotsendACTION_NEW_PICTUREandACTION_NEW_VIDEObroadcastsaswell. According to Background Execution Limits, apps that target Android 8.0 (API level 26) or higher can no longer register BroadcastReceiversforimplicitbroadcastsintheirmanifest,exceptforthoselistedinImplicitBroadcastExceptions. The BroadcastReceiverscreatedatruntimebycallingContext.registerReceiverarenotaffectedbythislimitation. AccordingtoChangestoSystemBroadcasts,beginningwithAndroid9(APIlevel28),theNETWORK_STATE_CHANGED_ACTION broadcastdoesn’treceiveinformationabouttheuser’slocationorpersonallyidentifiabledata. Android Application Publishing Onceanapphasbeensuccessfullydeveloped,thenextstepistopublishandshareitwithothers. However,appscan’t simplybeaddedtoastoreandshared,theymustbefirstsigned. Thecryptographicsignatureservesasaverifiablemark placedbythedeveloperoftheapp. Itidentifiestheapp’sauthorandensuresthattheapphasnotbeenmodifiedsince itsinitialdistribution. 104\\nSigning Process Duringdevelopment,appsaresignedwithanautomaticallygeneratedcertificate. Thiscertificateisinherentlyinsecure andisfordebuggingonly. Moststoresdon’tacceptthiskindofcertificateforpublishing;therefore,acertificatewithmore securefeaturesmustbecreated. WhenanapplicationisinstalledontheAndroiddevice,thePackageManagerensures thatithasbeensignedwiththecertificateincludedinthecorrespondingAPK.Ifthecertificate’spublickeymatchesthe key used to sign any other APK on the device, the new APK may share a UID with the pre-existing APK. This facilitates interactionsbetweenapplicationsfromasinglevendor. Alternatively, specifyingsecuritypermissionsfortheSignature protectionlevelispossible;thiswillrestrictaccesstoapplicationsthathavebeensignedwiththesamekey. APK Signing Schemes Androidsupportsthreeapplicationsigningschemes. StartingwithAndroid9(APIlevel28),APKscanbeverifiedwithAPK SignatureSchemev3(v3scheme),APKSignatureSchemev2(v2scheme)orJARsigning(v1scheme). ForAndroid7.0 (APIlevel24)andabove,APKscanbeverifiedwiththeAPKSignatureSchemev2(v2scheme)orJARsigning(v1scheme).", "metadata": {"doc_id": "OWASP_MASTG", "chunk_id": 59}}