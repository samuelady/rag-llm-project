{"text": "IfweclickonLocation,anothermethodwillbetraced: 11186ms +[CLLocationManagerauthorizationStatus] 11186ms |+[CLLocationManager_authorizationStatus] 11186ms | |+[CLLocationManager_authorizationStatusForBundleIdentifier:0x0bundle:0x0] Use the auto-generated stubs of frida-trace to get more information like the return values and a backtrace. Do the followingmodificationstotheJavaScriptfilebelow(thepathisrelativetothecurrentdirectory): 473\\n//__handlers__/__CLLocationManager_authorizationStatus_.js onEnter:function (log,args,state){ log(\"+[CLLocationManagerauthorizationStatus]\"); log(\"Calledfrom:\\n\"+ Thread.backtrace(this.context,Backtracer.ACCURATE) .map(DebugSymbol.fromAddress).join(\"\\n\\t\")+\"\\n\"); }, onLeave:function (log,retval,state){ console.log('RET:' +retval.toString()); } Clickingagainon“Location”revealsmoreinformation: 3630ms -[CLLocationManager init] 3630ms |-[CLLocationManagerinitWithEffectiveBundleIdentifier:0x0bundle:0x0] 3634ms -[CLLocationManager setDelegate:0x14c9ab000] 3641ms +[CLLocationManagerauthorizationStatus] RET:0x4 3641ms Calledfrom: 0x1031aa158TelegramUI!+[TGLocationUtilsrequestWhenInUserLocationAuthorizationWithLocationManager:] 0x10337e2c0TelegramUI!-[TGLocationPickerControllerinitWithContext:intent:] 0x101ee93acTelegramUI!0x1013ac Weseethat+[CLLocationManager authorizationStatus]returned0x4(CLAuthorizationStatus.authorizedWhenInUse) and was called by +[TGLocationUtils requestWhenInUserLocationAuthorizationWithLocationManager:]. As we anticipatedbefore,youmightusethiskindofinformationasanentrypointwhenreverseengineeringtheappandfrom theregetinputs(e.g.namesofclassesormethods)tokeepfeedingthedynamicanalysis. Next,thereisavisualwaytoinspectthestatusofsomeapppermissionswhenusingtheiPhone/iPadbyopening“Settings” andscrollingdownuntilyoufindtheappyou’reinterestedin. Whenclickingonit,thiswillopenthe“ALLOWAPP_NAME TOACCESS”screen. However, notallpermissionsmightbedisplayedyet. Youwillhavetotriggertheminordertobe listedonthatscreen. Forexample,inthepreviousexample,the“Location”entrywasnotbeinglisteduntilwetriggeredthepermissiondialogue forthefirsttime. Oncewedidit,nomatterifweallowedtheaccessornot,thethe“Location”entrywillbedisplayed. Determining Whether Native Methods Are Exposed Through WebViews 474\\nPlatform: ios MASVSV1: MSTG-PLATFORM-7 MASVSV2: MASVS-PLATFORM-2 Overview Static Analysis Testing UIWebView JavaScript to Native Bridges SearchforcodethatmapsnativeobjectstotheJSContextassociatedwithaWebViewandanalyzewhatfunctionalityit exposes,forexamplenosensitivedatashouldbeaccessibleandexposedtoWebViews. InObjective-C,theJSContextassociatedwithaUIWebViewisobtainedasfollows: [webViewvalueForKeyPath:@\"documentView.webView.mainFrame.javaScriptContext\"] Testing WKWebView JavaScript to Native Bridges VerifyifaJavaScripttonativebridgeexistsbysearchingforWKScriptMessageHandlerandcheckallexposedmethods. Thenverifyhowthemethodsarecalled. Thefollowingexamplefrom“Where’sMyBrowser?” demonstratesthis. FirstweseehowtheJavaScriptbridgeisenabled: func enableJavaScriptBridge(_enabled:Bool){ options_dict[\"javaScriptBridge\"]?.value =enabled letuserContentController =wkWebViewConfiguration.userContentController userContentController.removeScriptMessageHandler(forName:\"javaScriptBridge\") ifenabled { letjavaScriptBridgeMessageHandler =JavaScriptBridgeMessageHandler() userContentController.add(javaScriptBridgeMessageHandler,name:\"javaScriptBridge\") } } Addingascriptmessagehandlerwithname\"name\"(or\"javaScriptBridge\"intheexampleabove)causestheJavaScript functionwindow.webkit.messageHandlers.myJavaScriptMessageHandler.postMessagetobedefinedinallframesin allwebviewsthatusetheusercontentcontroller. ItcanbethenusedfromtheHTMLfilelikethis: function invokeNativeOperation(){ value1 =document.getElementById(\"value1\").value value2 =document.getElementById(\"value2\").value window.webkit.messageHandlers.javaScriptBridge.postMessage([\"multiplyNumbers\",value1,value2]); } ThecalledfunctionresidesinJavaScriptBridgeMessageHandler.swift: class JavaScriptBridgeMessageHandler:NSObject,WKScriptMessageHandler { //... case \"multiplyNumbers\": letarg1 =Double(messageArray[1])! letarg2 =Double(messageArray[2])! result =String(arg1 *arg2) //... letjavaScriptCallBack =\"javascriptBridgeCallBack('\\(functionFromJS)','\\(result)')\" message.webView?.evaluateJavaScript(javaScriptCallBack,completionHandler:nil) TheproblemhereisthattheJavaScriptBridgeMessageHandlernotonlycontainsthatfunction,italsoexposesasensitive function: 475\\ncase \"getSecret\": result =\"XSRSOGKC342\" Dynamic Analysis At this point you’ve surely identified all potentially interesting WebViews in the iOS app and got an overview of the potentialattacksurface(viastaticanalysis,thedynamicanalysistechniquesthatwehaveseeninprevioussectionsora combinationofthem). ThiswouldincludeHTMLandJavaScriptfiles,usageoftheJSContext/JSExportforUIWebView andWKScriptMessageHandlerforWKWebView,aswellaswhichfunctionsareexposedandpresentinaWebView. Further dynamic analysis can help you exploit those functions and get sensitive data that they might be exposing. As wehaveseeninthestaticanalysis,inthepreviousexampleitwastrivialtogetthesecretvaluebyperformingreverse engineering (the secret value was found in plain text inside the source code) but imagine that the exposed function retrievesthesecretfromsecurestorage. Inthiscase,onlydynamicanalysisandexploitationwouldhelp. TheprocedureforexploitingthefunctionsstartswithproducingaJavaScriptpayloadandinjectingitintothefilethatthe appisrequesting. Theinjectioncanbeaccomplishedviavarioustechniques,forexample: • IfsomeofthecontentisloadedinsecurelyfromtheInternetoverHTTP(mixedcontent),youcantrytoimplement aMITMattack. • YoucanalwaysperformdynamicinstrumentationandinjecttheJavaScriptpayloadbyusingframeworkslikeFrida and the corresponding JavaScript evaluation functions available for the iOS WebViews (stringByEvaluating- JavaScriptFromString: forUIWebViewandevaluateJavaScript:completionHandler: forWKWebView). In order to get the secret from the previous example of the “Where’s My Browser?” app, you can use one of these techniquestoinjectthefollowingpayloadthatwillrevealthesecretbywritingittothe“result”fieldoftheWebView: function javascriptBridgeCallBack(name,value){ document.getElementById(\"result\").innerHTML=value; }; window.webkit.messageHandlers.javaScriptBridge.postMessage([\"getSecret\"]); Ofcourse,youmayalsousetheExploitationHelperitprovides: 476\\nSeeanotherexampleforavulnerableiOSappandfunctionthatisexposedtoaWebViewin[#thiel2]page156. Determining Whether Sensitive Data Is Exposed via IPC Mechanisms Platform: ios MASVSV1: MSTG-STORAGE-6 MASVSV2: MASVS-PLATFORM-1 477\\nOverview Static Analysis The following section summarizes keywords that you should look for to identify IPC implementations within iOS source code. XPC Services SeveralclassesmaybeusedtoimplementtheNSXPCConnectionAPI: • NSXPCConnection • NSXPCInterface • NSXPCListener • NSXPCListenerEndpoint Youcansetsecurityattributesfortheconnection. Theattributesshouldbeverified. CheckforthefollowingtwofilesintheXcodeprojectfortheXPCServicesAPI(whichisC-based): • xpc.h • connection.h Mach Ports Keywordstolookforinlow-levelimplementations: • mach_port_t • mach_msg_* Keywordstolookforinhigh-levelimplementations(CoreFoundationandFoundationwrappers): • CFMachPort • CFMessagePort • NSMachPort • NSMessagePort NSFileCoordinator Keywordstolookfor: • NSFileCoordinator Dynamic Analysis VerifyIPCmechanismswithstaticanalysisoftheiOSsourcecode. NoiOStooliscurrentlyavailabletoverifyIPCusage. Testing UIPasteboard Platform: ios MASVSV1: MSTG-PLATFORM-4 MASVSV2: MASVS-PLATFORM-1 478\\nOverview Static Analysis The systemwide general pasteboard can be obtained by using generalPasteboard, search the source code or the compiledbinaryforthismethod. Usingthesystemwidegeneralpasteboardshouldbeavoidedwhendealingwithsensitive data. Custom pasteboards can be created with pasteboardWithName:create: or pasteboardWithUniqueName. Verify if custom pasteboards are set to be persistent as this is deprecated since iOS 10. A shared container should be used instead. Inaddition,thefollowingcanbeinspected: • CheckifpasteboardsarebeingremovedwithremovePasteboardWithName:,whichinvalidatesanapppasteboard, freeingupallresourcesusedbyit(noeffectforthegeneralpasteboard). • Checkifthereareexcludedpasteboards,thereshouldbeacalltosetItems:options: withtheUIPasteboardOp- tionLocalOnlyoption. • Checkifthereareexpiringpasteboards,thereshouldbeacalltosetItems:options: withtheUIPasteboardOp- tionExpirationDateoption. • Checkiftheappswipesthepasteboarditemswhengoingtobackgroundorwhenterminating. Thisisdonebysome passwordmanagerappstryingtorestrictsensitivedataexposure. Dynamic Analysis Detect Pasteboard Usage Hookortracethefollowing: • generalPasteboardforthesystem-widegeneralpasteboard. • pasteboardWithName:create: andpasteboardWithUniqueNameforcustompasteboards. Detect Persistent Pasteboard Usage HookortracethedeprecatedsetPersistent: methodandverifyifit’sbeingcalled. Monitoring and Inspecting Pasteboard Items Whenmonitoringthepasteboards,thereisseveraldetailsthatmaybedynamicallyretrieved: • ObtainpasteboardnamebyhookingpasteboardWithName:create: andinspectingitsinputparametersorpaste- boardWithUniqueNameandinspectingitsreturnvalue. • Getthefirstavailablepasteboarditem: e.g.forstringsusestringmethod. Oruseanyoftheothermethodsfor thestandarddatatypes. • GetthenumberofitemswithnumberOfItems. • Checkforexistenceofstandarddatatypeswiththeconveniencemethods,e.g.hasImages,hasStrings,hasURLs (startinginiOS10). • Check for other data types (typically UTIs) with containsPasteboardTypes: inItemSet:. You may inspect for moreconcretedatatypeslike,forexampleanpictureaspublic.pngandpublic.tiff(UTIs)orforcustomdatasuch ascom.mycompany.myapp.mytype. Rememberthat,inthiscase,onlythoseappsthatdeclareknowledgeofthe", "metadata": {"doc_id": "OWASP_MASTG", "chunk_id": 157}}