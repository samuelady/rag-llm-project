{"text": "Java 3:00004e49 112FUNC GLOBALDEFAULT 11Java_sg_vantagepoint_helloworld_MainActivity_stringFromJNI Youcanalsoseethisusingradare2’srabin2: $rabin2 -sHelloWord-JNI/lib/armeabi-v7a/libnative-lib.so |grep -iJava 0030x00000e780x00000e78GLOBAL FUNC 16Java_sg_vantagepoint_helloworldjni_MainActivity_stringFromJNI ThisisthenativefunctionthateventuallygetsexecutedwhenthestringFromJNInativemethodiscalled. Todisassemblethecode,youcanloadlibnative-lib.sointoanydisassemblerthatunderstandsELFbinaries(i.e.,any disassembler). Iftheappshipswithbinariesfordifferentarchitectures,youcantheoreticallypickthearchitectureyou’re mostfamiliarwith,aslongasitiscompatiblewiththedisassembler. Eachversioniscompiledfromthesamesourceand implements the same functionality. However, if you’re planning to debug the library on a live device later, it’s usually wisetopickanARMbuild. To support both older and newer ARM processors, Android apps ship with multiple ARM builds compiled for different ApplicationBinaryInterface(ABI)versions. TheABIdefineshowtheapplication’smachinecodeissupposedtointeract withthesystematruntime. ThefollowingABIsaresupported: • armeabi: ABIisforARM-basedCPUsthatsupportatleasttheARMv5TEinstructionset. • armeabi-v7a: ThisABIextendsarmeabitoincludeseveralCPUinstructionsetextensions. • arm64-v8a: ABIforARMv8-basedCPUsthatsupportAArch64,thenew64-bitARMarchitecture. Mostdisassemblerscanhandleanyofthosearchitectures. Below,we’llbeviewingthearmeabi-v7aversion(locatedin HelloWord-JNI/lib/armeabi-v7a/libnative-lib.so)inradare2andinIDAPro. Seethesection“ReviewingDisassem- bledNativeCode”belowtolearnonhowtoproceedwheninspectingthedisassemblednativecode. radare2 Toopenthefileinradare2youonlyhavetorunr2-AHelloWord-JNI/lib/armeabi-v7a/libnative-lib.so. Thechapter “Android Basic Security Testing” already introduced radare2. Remember that you can use the flag -A to run the aaa commandrightafterloadingthebinaryinordertoanalyzeallreferencedcode. $r2 -AHelloWord-JNI/lib/armeabi-v7a/libnative-lib.so [x]Analyzeallflagsstartingwithsym.andentry0 (aa) [x]Analyzefunctioncalls (aac) [x]Analyzelenbytesofinstructionsforreferences (aar) [x]Checkforobjcreferences 176\\n[x]Checkforvtables [x]Findingxrefsinnoncodesectionwithanal.in=io.maps [x]Analyzevaluepointers (aav) [x]Valuefrom0x00000000to0x00001dcf (aav) [x]0x00000000-0x00001dcfin0x0-0x1dcf (aav) [x]Emulatecodetofindcomputedreferences (aae) [x]Typematchinganalysisforallfunctions (aaft) [x]Use -AAoraaaatoperformadditionalexperimentalanalysis. --Printthecontentsofthecurrentblockwiththe 'p'command [0x00000e3c]> Note that for bigger binaries, starting directly with the flag -A might be very time consuming as well as unnecessary. Dependingonyourpurpose,youmayopenthebinarywithoutthisoptionandthenapplyalesscomplexanalysislikeaa oramoreconcretetypeofanalysissuchastheonesofferedinaa(basicanalysisofallfunctions)oraac(analyzefunction calls). Remembertoalwaystype? togetthehelporattachittocommandstoseeevenmorecommandoroptions. For example,ifyouenteraa? you’llgetthefulllistofanalysiscommands. [0x00001760]>aa? Usage:aa[0*?] #seealso'af'and'afna' |aa aliasfor 'af@@sym.*;af@entry0;afva' |aaa[?] autonamefunctionsafteraa (seeafna) |aab abbacrossbin.sections.rx |aac[len] analyzefunctioncalls (af@@ `pilen~call[1]`) |aac* [len] flagfunctioncallswithoutperformingacompleteanalysis |aad[len] analyzedatareferencestocode |aae[len]([addr]) analyzereferenceswithESIL (optionallytoaddress) |aaf[e|t] analyzeallfunctions (eanal.hasnext=1;afr@@c:isq)(aafe=aef@@f) |aaF[sym*] setanal.in=blockforallthespacesbetweenflagsmatchingglob |aaFa [sym*] sameasaaFbutusesaf/a2finsteadofaf+/afb+ (slowerbutmoreaccurate) |aai[j] showinfoofallanalysisparameters |aan autonamefunctionsthateitherstartwithfcn.*orsym.func.* |aang findfunctionandsymbolnamesfromgolangbinaries |aao analyzeallobjcreferences |aap findandanalyzefunctionpreludes |aar[?][len] analyzelenbytesofinstructionsforreferences |aas[len] analyzesymbols (af@@= `isq~[0]`) |aaS analyzeallflagsstartingwithsym. (af@@sym.*) |aat[len] analyzeallconsecutivefunctionsinsection |aaT[len] analyzecodeaftertrap-sleds |aau[len] listmemareas (largerthanlenbytes)notcoveredbyfunctions |aav[sat] findvaluesreferencingaspecificsectionormap Thereisathingthatisworthnoticingaboutradare2vsotherdisassemblerslikee.g.IDAPro. Thefollowingquotefrom thisarticleofradare2’sblog(https://radareorg.github.io/blog/)offersagoodsummary. Codeanalysisisnotaquickoperation,andnotevenpredictableortakingalineartimetobeprocessed. Thismakes startingtimesprettyheavy,comparedtojustloadingtheheadersandstringsinformationlikeit’sdonebydefault. People that are used to IDA or Hopper just load the binary, go out to make a coffee and then when the analysis isdone, they startdoingthemanualanalysis tounderstandwhattheprogramis doing. It’s truethatthosetools performtheanalysisinbackground,andtheGUIisnotblocked. ButthistakesalotofCPUtime,andr2aimstorun inmanymoreplatformsthanjusthigh-enddesktopcomputers. Thissaid,pleaseseesection“ReviewingDisassembledNativeCode”tolearnmorebouthowradare2canhelpusperform- ingourreversingtasksmuchfaster. Forexample,gettingthedisassemblyofaspecificfunctionisatrivialtaskthatcan beperformedinonecommand. IDA Pro IfyouownanIDAProlicense,openthefileandonceinthe“Loadnewfile”dialog,choose“ELFforARM(SharedObject)” asthefiletype(IDAshoulddetectthisautomatically),and“ARMLittle-Endian”astheprocessortype. 177\\nThefreewareversionofIDAProunfortunatelydoesnotsupporttheARMprocessortype. Execution Tracing Platform: android Besides being useful for debugging, the jdb command line tool offers basic execution tracing functionality. To trace an apprightfromthestart,youcanpausetheappwiththeAndroid“WaitforDebugger”featureorakill -STOPcommand andattachjdbtosetadeferredmethodbreakpointonanyinitializationmethod. Oncethebreakpointisreached,activate methodtracingwiththetrace go methodscommandandresumeexecution. jdbwilldumpallmethodentriesandexits fromthatpointonwards. $adbforwardtcp:7777jdwp:7288 ${echo \"suspend\";cat;}|jdb-attach localhost:7777 Setuncaughtjava.lang.Throwable Setdeferreduncaughtjava.lang.Throwable Initializingjdb... >Allthreadssuspended. >stop incom.acme.bob.mobile.android.core.BobMobileApplication.<clinit>() Deferringbreakpointcom.acme.bob.mobile.android.core.BobMobileApplication.<clinit>(). Itwillbesetaftertheclassisloaded. >resume Allthreadsresumed.M Setdeferredbreakpointcom.acme.bob.mobile.android.core.BobMobileApplication.<clinit>() Breakpointhit: \"thread=main\",com.acme.bob.mobile.android.core.BobMobileApplication.<clinit>(),line=44 bci=0 main[1]tracegomethods main[1]resume Methodentered:Allthreadsresumed. The Dalvik Debug Monitor Server (DDMS) is a GUI tool included with Android Studio. It may not look like much, but its Javamethodtracerisoneofthemostawesometoolsyoucanhaveinyourarsenal,anditisindispensableforanalyzing obfuscatedbytecode. DDMS is somewhat confusing, however; it can be launched several ways, and different trace viewers will be launched depending on how a method was traced. There’s a standalone tool called “Traceview” as well as a built-in viewer in AndroidStudio,bothofwhichofferdifferentwaystonavigatethetrace. You’llusuallyuseAndroidstudio’sbuilt-inviewer, whichgivesyouazoomablehierarchicaltimelineofallmethodcalls. However,thestandalonetoolisalsouseful,ithasa profilepanelthatshowsthetimespentineachmethodalongwiththeparentsandchildrenofeachmethod. TorecordanexecutiontraceinAndroidStudio,opentheAndroidtabatthebottomoftheGUI.Selectthetargetprocess inthelistandclickthelittlestopwatchbuttonontheleft. Thisstartstherecording. Onceyou’redone,clickthesame buttontostoptherecording. Theintegratedtraceviewwillopenandshowtherecordedtrace. Youcanscrollandzoom thetimelineviewwiththemouseortrackpad. ExecutiontracescanalsoberecordedinthestandaloneAndroidDeviceMonitor. TheDeviceMonitorcanbestartedwithin AndroidStudio(Tools->Android->AndroidDeviceMonitor)orfromtheshellwiththeddmscommand. To start recording tracing information, select the target process in the Devices tab and click Start Method Profiling. Clickthestopbuttontostoprecording,afterwhichtheTraceviewtoolwillopenandshowtherecordedtrace. Clicking anyofthemethodsintheprofilepanelhighlightstheselectedmethodinthetimelinepanel. 178\\nDDMSalsooffersaconvenientheapdumpbuttonthatwilldumptheJavaheapofaprocesstoa.hproffile. TheAndroid StudiouserguidecontainsmoreinformationaboutTraceview. Tracing System Calls MovingdownalevelintheOShierarchy, youarriveatprivilegedfunctionsthatrequirethepowersoftheLinuxkernel. Thesefunctionsareavailabletonormalprocessesviathesystemcallinterface. Instrumentingandinterceptingcallsinto thekernelisaneffectivemethodforgettingaroughideaofwhatauserprocessisdoing, andoftenthemostefficient waytodeactivatelow-leveltamperingdefenses. Strace is a standard Linux utility that is not included with Android by default, but can be easily built from source via theAndroidNDK.Itmonitorstheinteractionbetweenprocessesandthekernel,beingaveryconvenientwaytomonitor systemcalls. However,there’sadownside: asstracedependsontheptracesystemcalltoattachtothetargetprocess, onceanti-debuggingmeasuresbecomeactiveitwillstopworking. Ifthe“Waitfordebugger”featureinSettings>Developeroptionsisunavailable,youcanuseashellscripttolaunch theprocessandimmediatelyattachstrace(notanelegantsolution,butitworks): while true;dopid=$(pgrep 'target_process' |head -1);if[[-n\"$pid\"]];then strace -s2000 -e\"!read\" -ff-p\"$pid\";break;fi;done Ftrace FtraceisatracingutilitybuiltdirectlyintotheLinuxkernel. Onarooteddevice,ftracecantracekernelsystemcallsmore transparentlythanstracecan(stracereliesontheptracesystemcalltoattachtothetargetprocess). Conveniently,thestockAndroidkernelonbothLollipopandMarshmallowincludeftracefunctionality. Thefeaturecanbe enabledwiththefollowingcommand: echo1 >/proc/sys/kernel/ftrace_enabled The /sys/kernel/debug/tracing directory holds all control and output files related to ftrace. The following files are foundinthisdirectory: • available_tracers: Thisfileliststheavailabletracerscompiledintothekernel. • current_tracer: Thisfilesetsordisplaysthecurrenttracer. • tracing_on: Echo “1”intothis filetoallow/start updateofthe", "metadata": {"doc_id": "OWASP_MASTG", "chunk_id": 77}}