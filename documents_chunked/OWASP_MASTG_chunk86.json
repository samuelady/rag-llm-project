{"text": "thegetExternal*functions(useexternalstorage) ∗ thegetWritableDatabasefunction(returnsaSQLiteDatabaseforwriting) ∗ thegetReadableDatabasefunction(returnsaSQLiteDatabaseforreading) ∗ thegetCacheDirandgetExternalCacheDirsfunction(usecachedfiles) EncryptionshouldbeimplementedusingprovenSDKfunctions. Thefollowingdescribesbadpracticestolookforinthe sourcecode: • Locallystoredsensitiveinformation“encrypted”viasimplebitoperationslikeXORorbitflipping. Theseoperations shouldbeavoidedbecausetheencrypteddatacanberecoveredeasily. • KeysusedorcreatedwithoutAndroidonboardfeatures,suchastheAndroidKeyStore • Keysdisclosedbyhard-coding 206\\nA typical misuse are hard-coded cryptographic keys. Hard-coded and world-readable cryptographic keys significantly increasethepossibilitythatencrypteddatawillberecovered. Onceanattackerobtainsthedata,decryptingitistrivial. Symmetric cryptography keys must be stored on the device, so identifying them is just a matter of time and effort. Considerthefollowingcode: this.db=localUserSecretStore.getWritableDatabase(\"SuperPassword123\"); Obtainingthekeyistrivialbecauseitiscontainedinthesourcecodeandidenticalforallinstallationsoftheapp. Encrypting datathis way is notbeneficial. Lookfor hard-codedAPI keys/privatekeysand other valuable data; they pose asimilar risk. Encoded/encryptedkeysrepresentanotherattempttomakeitharderbutnotimpossibletogetthecrownjewels. Considerthefollowingcode: ExampleinJava: //AmorecomplicatedefforttostoretheXOR'edhalvesofakey(insteadofthekeyitself) private static final String[]myCompositeKey =newString[]{ \"oNQavjbaNNSgEqoCkT9Em4imeQQ=\",\"3o8eFOX4ri/F8fgHgiy/BS47\" }; ExampleinKotlin: private valmyCompositeKey =arrayOf<String>(\"oNQavjbaNNSgEqoCkT9Em4imeQQ=\", \"3o8eFOX4ri/F8fgHgiy/BS47\") Thealgorithmfordecodingtheoriginalkeymightbesomethinglikethis: ExampleinJava: public void useXorStringHiding(StringmyHiddenMessage){ byte[]xorParts0 =Base64.decode(myCompositeKey[0],0); byte[]xorParts1 =Base64.decode(myCompositeKey[1],0); byte[]xorKey =newbyte[xorParts0.length]; for(inti=0;i<xorParts1.length;i++){ xorKey[i]=(byte)(xorParts0[i]^xorParts1[i]); } HidingUtil.doHiding(myHiddenMessage.getBytes(),xorKey,false); } ExampleinKotlin: funuseXorStringHiding(myHiddenMessage:String){ valxorParts0 =Base64.decode(myCompositeKey[0],0) valxorParts1 =Base64.decode(myCompositeKey[1],0) valxorKey =ByteArray(xorParts0.size) for(iinxorParts1.indices) { xorKey[i]=(xorParts0[i]xorxorParts1[i]).toByte() } HidingUtil.doHiding(myHiddenMessage.toByteArray(),xorKey,false) } Verifycommonlocationsofsecrets: • resources(typicallyatres/values/strings.xml)Example: <resources> <string name=\"app_name\">SuperApp</string> <string name=\"hello_world\">Helloworld!</string> <string name=\"action_settings\">Settings</string> <string name=\"secret_key\">My_Secret_Key</string> </resources> • buildconfigs,suchasinlocal.propertiesorgradle.propertiesExample: buildTypes { debug { minifyEnabled true buildConfigField \"String\",\"hiddenPassword\",\"\\\"${hiddenPassword}\\\"\" } } 207\\nDynamic Analysis Installandusetheapp,executingallfunctionsatleastonce. Datacanbegeneratedwhenenteredbytheuser,sentby theendpoint,orshippedwiththeapp. Thencompletethefollowing: • Checkbothinternalandexternallocalstorageforanyfilescreatedbytheapplicationthatcontainsensitivedata. • Identifydevelopmentfiles,backupfiles,andoldfilesthatshouldn’tbeincludedwithaproductionrelease. • Determine whether SQLite databases are available and whether they contain sensitive information. SQLite databasesarestoredin/data/data/<package-name>/databases. • IdentifyifSQLitedatabasesareencrypted. Ifso, determinehowthedatabasepasswordisgeneratedandstored andifthisissufficientlyprotectedasdescribedinthe“StoringaKey”sectionoftheKeystoreoverview. • Check Shared Preferences that are stored as XML files (in /data/data/<package-name>/shared_prefs) for sen- sitive information. Shared Preferences are insecure and unencrypted by default. Some apps might opt to use secure-preferencestoencryptthevaluesstoredinSharedPreferences. • Check the permissions of the files in /data/data/<package-name>. Only the user and group created when you installedtheapp(e.g.,u0_a82)shouldhaveuserread,write,andexecutepermissions(rwx). Otherusersshould nothavepermissiontoaccessfiles,buttheymayhaveexecutepermissionsfordirectories. • CheckfortheusageofanyFirebaseReal-timedatabasesandattempttoidentifyiftheyaremisconfiguredbymaking thefollowingnetworkcall: – https://_firebaseProjectName_.firebaseio.com/.json • Determine whether a Realm database is available in /data/data/<package-name>/files/, whether it is unen- crypted,andwhetheritcontainssensitiveinformation. Bydefault,thefileextensionisrealmandthefilenameis default. InspecttheRealmdatabasewiththeRealmBrowser. Testing Memory for Sensitive Data Platform: android MASVSV1: MSTG-STORAGE-10 MASVSV2: MASVS-STORAGE-2 Overview Analyzingmemorycanhelpdevelopersidentifytherootcausesofseveralproblems,suchasapplicationcrashes. However, itcanalsobeusedtoaccesssensitivedata. Thissectiondescribeshowtocheckfordatadisclosureviaprocessmemory. First identify sensitive information that is stored in memory. Sensitive assets have likely been loaded into memory at somepoint. Theobjectiveistoverifythatthisinformationisexposedasbrieflyaspossible. To investigate an application’s memory, you must first create a memory dump. You can also analyze the memory in real-time,e.g.,viaadebugger. Regardlessofyourapproach,memorydumpingisaveryerror-proneprocessintermsof verificationbecauseeachdumpcontainstheoutputofexecutedfunctions. Youmaymissexecutingcriticalscenarios. In addition,overlookingdataduringanalysisisprobableunlessyouknowthedata’sfootprint(eithertheexactvalueorthe dataformat). Forexample,iftheappencryptswitharandomlygeneratedsymmetrickey,youlikelywon’tbeabletospot itinmemoryunlessyoucanrecognizethekey’svalueinanothercontext. Therefore,youarebetteroffstartingwithstaticanalysis. Static Analysis Whenperformingstaticanalysistoidentifysensitivedatathatisexposedinmemory,youshould: • Trytoidentifyapplicationcomponentsandmapwheredataisused. • Makesurethatsensitivedataishandledbyasfewcomponentsaspossible. • Makesurethatobjectreferencesareproperlyremovedoncetheobjectcontainingthesensitivedataisnolonger needed. • Makesurethatgarbagecollectionisrequestedafterreferenceshavebeenremoved. 208\\n• Makesurethatsensitivedatagetsoverwrittenassoonasitisnolongerneeded. – Don’trepresentsuchdatawithimmutabledatatypes(suchasStringandBigInteger). – Avoidnon-primitivedatatypes(suchasStringBuilder). – Overwritereferencesbeforeremovingthem,outsidethefinalizemethod. – Payattentiontothird-partycomponents(librariesandframeworks). PublicAPIsaregoodindicators. Determine whetherthepublicAPIhandlesthesensitivedataasdescribedinthischapter. Thefollowingsectiondescribespitfallsofdataleakageinmemoryandbestpracticesforavoidingthem. Don’tuseimmutablestructures(e.g., StringandBigInteger)torepresentsecrets. Nullifyingthesestructureswillbe ineffective: thegarbagecollectormaycollectthem, buttheymayremainontheheapaftergarbagecollection. Never- theless, you should ask for garbage collection after every critical operation (e.g., encryption, parsing server responses thatcontainsensitiveinformation). Whencopiesoftheinformationhavenotbeenproperlycleaned(asexplainedbelow), yourrequestwillhelpreducethelengthoftimeforwhichthesecopiesareavailableinmemory. Toproperlycleansensitiveinformationfrommemory,storeitinprimitivedatatypes,suchasbyte-arrays(byte[])and char-arrays(char[]). Youshouldavoidstoringtheinformationinmutablenon-primitivedatatypes. Makesuretooverwritethecontentofthecriticalobjectoncetheobjectisnolongerneeded. Overwritingthecontentwith zeroesisonesimpleandverypopularmethod: ExampleinJava: byte[]secret =null; try{ //getorgeneratethesecret,doworkwithit,makesureyoumakenolocalcopies }finally { if(null !=secret){ Arrays.fill(secret,(byte)0); } } ExampleinKotlin: valsecret:ByteArray?=null try{ //getorgeneratethesecret,doworkwithit,makesureyoumakenolocalcopies }finally { if(null !=secret){ Arrays.fill(secret,0.toByte()) } } Thisdoesn’t,however,guaranteethatthecontentwillbeoverwrittenatruntime. Tooptimizethebytecode,thecompiler willanalyzeanddecidenottooverwritedatabecauseitwillnotbeusedafterwards(i.e.,itisanunnecessaryoperation). EvenifthecodeisinthecompiledDEX,theoptimizationmayoccurduringthejust-in-timeorahead-of-timecompilation intheVM. Thereisnosilverbulletforthisproblembecausedifferentsolutionshavedifferentconsequences. Forexample,youmay performadditionalcalculations(e.g., XORthedataintoadummybuffer), butyou’llhavenowaytoknowtheextentof thecompiler’soptimizationanalysis. Ontheotherhand, usingtheoverwrittendataoutsidethecompiler’sscope(e.g., serializingitinatempfile)guaranteesthatitwillbeoverwrittenbutobviouslyimpactsperformanceandmaintenance. Then,usingArrays.filltooverwritethedataisabadideabecausethemethodisanobvioushookingtarget(seethe chapter“TamperingandReverseEngineeringonAndroid”formoredetails). Thefinalissuewiththeaboveexampleisthatthecontentwasoverwrittenwithzeroesonly. Youshouldtrytooverwrite criticalobjectswithrandomdataorcontentfromnon-criticalobjects. Thiswillmakeitreallydifficulttoconstructscanners thatcanidentifysensitivedataonthebasisofitsmanagement. Belowisanimprovedversionofthepreviousexample: ExampleinJava: byte[]nonSecret =somePublicString.getBytes(\"ISO-8859-1\"); byte[]secret =null; try{ //getorgeneratethesecret,doworkwithit,makesureyoumakenolocalcopies }finally { 209\\nif(null !=secret){ for(inti=0;i<secret.length;i++){ secret[i]=nonSecret[i%nonSecret.length]; } FileOutputStreamout =newFileOutputStream(\"/dev/null\"); out.write(secret); out.flush(); out.close(); } } ExampleinKotlin: valnonSecret:ByteArray =somePublicString.getBytes(\"ISO-8859-1\") valsecret:ByteArray?=null try{ //getorgeneratethesecret,doworkwithit,makesureyoumakenolocalcopies }finally { if(null !=secret){ for(iinsecret.indices){ secret[i]=nonSecret[i%nonSecret.size] } valout=FileOutputStream(\"/dev/null\") out.write(secret) out.flush() out.close() } } Formoreinformation,takealookatSecurelyStoringSensitiveDatainRAM. Inthe“StaticAnalysis”section,wementionedtheproperwaytohandlecryptographickeyswhenyouareusingAndroid- KeyStoreorSecretKey. For a better implementation of SecretKey, look at the SecureSecretKey class below. Although the implementation is probably missing some boilerplate code that would make the class compatible with SecretKey, it addresses the main securityconcerns: • Nocross-contexthandlingofsensitivedata. Eachcopyofthekeycanbeclearedfromwithinthescopeinwhichit wascreated. • Thelocalcopyisclearedaccordingtotherecommendationsgivenabove. ExampleinJava: public class", "metadata": {"doc_id": "OWASP_MASTG", "chunk_id": 86}}