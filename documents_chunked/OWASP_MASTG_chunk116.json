{"text": "can try to make it harder to detect the implemented protection mechanisms by using various obfuscation techniques. At the end, this is part of thecatandmousegameofprotectingdatabeingprocessedonanuntrustedenvironment(anapprunningintheuser device). Itisimportanttonotethatthesecontrolsareonlyincreasingthecomplexityofthereverseengineeringprocess. If used, the best approachis to combine the controlscleverly instead of using them individually. However, none of themcanassurea100%effectiveness,asthereverseengineerwillalwayshavefullaccesstothedeviceandwill thereforealwayswin! Youalsohavetoconsiderthatintegratingsomeofthecontrolsintoyourappmightincrease thecomplexityofyourappandevenhaveanimpactonitsperformance. Emulator Detection In the context of anti-reversing, the goal of emulator detection is to increase the difficulty of running the app on an emulateddevice,whichimpedessometoolsandtechniquesreverseengineersliketouse. Thisincreaseddifficultyforces thereverseengineertodefeattheemulatorchecksorutilizethephysicaldevice,therebybarringtheaccessrequiredfor large-scaledeviceanalysis. There are several indicators that the device in question is being emulated. Although all these API calls can be hooked, theseindicatorsprovideamodestfirstlineofdefense. Thefirstsetofindicatorsareinthefilebuild.prop. APIMethod Value Meaning Build.ABI armeabi possiblyemulator BUILD.ABI2 unknown possiblyemulator Build.BOARD unknown emulator Build.Brand generic emulator Build.DEVICE generic emulator Build.FINGERPRINT generic emulator Build.Hardware goldfish emulator Build.Host android-test possiblyemulator Build.ID FRF91 emulator Build.MANUFACTURER unknown emulator Build.MODEL sdk emulator Build.PRODUCT sdk emulator Build.RADIO unknown possiblyemulator Build.SERIAL null emulator Build.USER android-build emulator Youcaneditthefilebuild.proponarootedAndroiddeviceormodifyitwhilecompilingAOSPfromsource. Bothtechniques willallowyoutobypassthestaticstringchecksabove. ThenextsetofstaticindicatorsutilizetheTelephonymanager. AllAndroidemulatorshavefixedvaluesthatthisAPIcan query. 313\\nAPI Value Meaning TelephonyManager.getDeviceId() 0's emulator TelephonyManager.getLine1Number() 155552155 emulator TelephonyManager.getNetworkCountryIso() us possiblyemulator TelephonyManager.getNetworkType() 3 possiblyemulator TelephonyManager.getNetworkOperator().substring(0,3) 310 possiblyemulator TelephonyManager.getNetworkOperator().substring(3) 260 possiblyemulator TelephonyManager.getPhoneType() 1 possiblyemulator TelephonyManager.getSimCountryIso() us possiblyemulator TelephonyManager.getSimSerialNumber() 89014103211118510720 emulator TelephonyManager.getSubscriberId() 310260000000000 emulator TelephonyManager.getVoiceMailNumber() 15552175049 emulator Keepinmindthatahookingframework,suchasXposedorFrida,canhookthisAPItoprovidefalsedata. Runtime Integrity Verification Controlsinthiscategoryverifytheintegrityoftheapp’smemoryspacetodefendtheappagainstmemorypatchesapplied duringruntime. Suchpatchesincludeunwantedchangestobinarycode,bytecode,functionpointertables,andimportant datastructures,aswellasroguecodeloadedintoprocessmemory. Integritycanbeverifiedby: 1. comparingthecontentsofmemoryorachecksumoverthecontentstogoodvalues, 2. searchingmemoryforthesignaturesofunwantedmodifications. There’ssomeoverlapwiththecategory“detectingreverseengineeringtoolsandframeworks”,and,infact,wedemon- stratedthesignature-basedapproachinthatchapterwhenweshowedhowtosearchprocessmemoryforFrida-related strings. Belowareafewmoreexamplesofvariouskindsofintegritymonitoring. Detecting Tampering with the Java Runtime Thisdetectioncodeisfromthedead&&endblog. try{ throw newException(); } catch(Exceptione){ intzygoteInitCallCount =0; for(StackTraceElementstackTraceElement :e.getStackTrace()){ if(stackTraceElement.getClassName().equals(\"com.android.internal.os.ZygoteInit\")){ zygoteInitCallCount++; if(zygoteInitCallCount ==2){ Log.wtf(\"HookDetection\",\"Substrateisactiveonthedevice.\"); } } if(stackTraceElement.getClassName().equals(\"com.saurik.substrate.MS$2\")&& stackTraceElement.getMethodName().equals(\"invoked\")){ Log.wtf(\"HookDetection\",\"AmethodonthestacktracehasbeenhookedusingSubstrate.\"); } if(stackTraceElement.getClassName().equals(\"de.robv.android.xposed.XposedBridge\")&& stackTraceElement.getMethodName().equals(\"main\")){ Log.wtf(\"HookDetection\",\"Xposedisactiveonthedevice.\"); } if(stackTraceElement.getClassName().equals(\"de.robv.android.xposed.XposedBridge\")&& stackTraceElement.getMethodName().equals(\"handleHookedMethod\")){ Log.wtf(\"HookDetection\",\"AmethodonthestacktracehasbeenhookedusingXposed.\"); } } } Detecting Native Hooks By using ELF binaries, native function hooks can be installed by overwriting function pointers in memory (e.g., Global Offset Table or PLT hooking) or patching parts of the function code itself (inline hooking). Checking the integrity of the respectivememoryregionsisonewaytodetectthiskindofhook. TheGlobalOffsetTable(GOT)isusedtoresolvelibraryfunctions. Duringruntime,thedynamiclinkerpatchesthistable withtheabsoluteaddressesofglobalsymbols. GOThooksoverwritethestoredfunctionaddressesandredirectlegitimate functioncallstoadversary-controlledcode. Thistypeofhookcanbedetectedbyenumeratingtheprocessmemorymap andverifyingthateachGOTentrypointstoalegitimatelyloadedlibrary. 314\\nIncontrasttoGNUld,whichresolvessymboladdressesonlyaftertheyareneededforthefirsttime(lazybinding),the AndroidlinkerresolvesallexternalfunctionsandwritestherespectiveGOTentriesimmediatelyafteralibraryisloaded (immediatebinding). YoucanthereforeexpectallGOTentriestopointtovalidmemorylocationsinthecodesectionsof theirrespectivelibrariesduringruntime. GOThookdetectionmethodsusuallywalktheGOTandverifythis. Inline hooks work by overwriting a few instructions at the beginning or end of the function code. During runtime, this so-called trampoline redirects execution to the injected code. You can detect inline hooks by inspecting the prologues andepiloguesoflibraryfunctionsforsuspectinstructions,suchasfarjumpstolocationsoutsidethelibrary. Obfuscation Thechapter“MobileAppTamperingandReverseEngineering”introducesseveralwell-knownobfuscationtechniquesthat canbeusedinmobileappsingeneral. Androidappscanimplementsomeofthoseobfuscationtechniquesusingdifferenttooling. Forexample,ProGuardoffers an easy way to shrink and obfuscate code and to strip unneeded debugging information from the bytecode of Android Javaapps. Itreplacesidentifiers,suchasclassnames,methodnames,andvariablenames,withmeaninglesscharacter strings. Thisisatypeoflayoutobfuscation,whichdoesn’timpacttheprogram’sperformance. DecompilingJavaclassesistrivial,thereforeitisrecommendedtoalwaysapplyingsomebasicobfuscationtothe productionbytecode. LearnmoreaboutAndroidobfuscationtechniques: • “SecurityHardeningofAndroidNativeCode”byGautamArvind • “APKiD:FastIdentificationofAppShieldingProducts”byEduardoNovella • “ChallengesofNativeAndroidApplications: ObfuscationandVulnerabilities”byPierreGraux Using ProGuard Developersusethebuild.gradlefiletoenableobfuscation. Intheexamplebelow,youcanseethatminifyEnabledand proguardFilesareset. Creatingexceptionstoprotectsomeclassesfromobfuscation(with-keepclassmembersand- keepclass)iscommon. Therefore,auditingtheProGuardconfigurationfiletoseewhatclassesareexemptedisimportant. ThegetDefaultProguardFile('proguard-android.txt')methodgetsthedefaultProGuardsettingsfromthe<Android SDK>/tools/proguard/folder. Furtherinformationonhowtoshrink,obfuscate,andoptimizeyourappcanbefoundintheAndroiddeveloperdocumen- tation. WhenyoubuildyourprojectusingAndroidStudio3.4orAndroidGradleplugin3.4.0orhigher,thepluginnolonger usesProGuardtoperformcompile-timecodeoptimization. Instead,thepluginusestheR8compiler. R8workswith allofyourexistingProGuardrulesfiles,soupdatingtheAndroidGradleplugintouseR8shouldnotrequireyouto changeyourexistingrules. R8isthenewcodeshrinkerfromGoogleandwasintroducedinAndroidStudio3.3beta. Bydefault,R8removesattributes thatareusefulfordebugging,includinglinenumbers,sourcefilenames,andvariablenames. R8isafreeJavaclassfile shrinker,optimizer,obfuscator,andpre-verifierandisfasterthanProGuard,seealsoanAndroidDeveloperblogpostfor further details. It is shipped with Android’s SDK tools. To activate shrinking for the release build, add the following to build.gradle: android{ buildTypes{ release{ //Enablescodeshrinking,obfuscation,andoptimizationforonly //yourproject'sreleasebuildtype. minifyEnabledtrue //IncludesthedefaultProGuardrulesfilesthatarepackagedwith //theAndroidGradleplugin.Tolearnmore,gotothesectionabout //R8configurationfiles. proguardFilesgetDefaultProguardFile( 'proguard-android-optimize.txt'), 'proguard-rules.pro' } 315\\n} ... } Thefileproguard-rules.proiswhereyoudefinecustomProGuardrules. Withtheflag-keepyoucankeepcertaincode thatisnotbeingremovedbyR8,whichmightotherwiseproduceerrors. ForexampletokeepcommonAndroidclasses, asinoursampleconfigurationproguard-rules.profile: ... -keeppublicclass*extendsandroid.app.Activity -keeppublicclass*extendsandroid.app.Application -keeppublicclass*extendsandroid.app.Service ... Youcandefinethismoregranularlyonspecificclassesorlibrariesinyourprojectwiththefollowingsyntax: -keeppublicclassMyClass Obfuscationoftencarriesacostinruntimeperformance,thereforeitisusuallyonlyappliedtocertainveryspecificparts ofthecode,typicallythosedealingwithsecurityandruntimeprotection. Device Binding ThegoalofdevicebindingistoimpedeanattackerwhotriestobothcopyanappanditsstatefromdeviceAtodeviceB andcontinueexecutingtheappondeviceB.AfterdeviceAhasbeendeterminedtrustworthy,itmayhavemoreprivileges thandeviceB.ThesedifferentialprivilegesshouldnotchangewhenanappiscopiedfromdeviceAtodeviceB. Beforewedescribetheusableidentifiers,let’squicklydiscusshowtheycanbeusedforbinding. Therearethreemethods thatallowdevicebinding: • Augmentingthecredentialsusedforauthenticationwithdeviceidentifiers. Thismakesenseiftheapplicationneeds tore-authenticateitselfand/ortheuserfrequently. • Encryptingthedatastoredinthedevicewiththekeymaterialwhichisstronglyboundtothedevicecanstrengthen the device binding. The Android Keystore offers non-exportable private keys which we can use for this. When a maliciousactorwouldextractsuchdatafromadevice,itwouldn’tbepossibletodecryptthedata,asthekeyisnot accessible. Implementingthis,takesthefollowingsteps: – GeneratethekeypairintheAndroidKeystoreusingKeyGenParameterSpecAPI. //Source:<https://developer.android.com/reference/android/security/keystore/KeyGenParameterSpec.html> KeyPairGeneratorkeyPairGenerator =KeyPairGenerator.getInstance( KeyProperties.KEY_ALGORITHM_RSA,\"AndroidKeyStore\"); keyPairGenerator.initialize( newKeyGenParameterSpec.Builder( \"key1\", KeyProperties.PURPOSE_DECRYPT) .setDigests(KeyProperties.DIGEST_SHA256,KeyProperties.DIGEST_SHA512) .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_RSA_OAEP) .build()); KeyPairkeyPair =keyPairGenerator.generateKeyPair(); Ciphercipher =Cipher.getInstance(\"RSA/ECB/OAEPWithSHA-256AndMGF1Padding\"); cipher.init(Cipher.DECRYPT_MODE,keyPair.getPrivate()); ...", "metadata": {"doc_id": "OWASP_MASTG", "chunk_id": 116}}