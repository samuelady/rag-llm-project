{"text": "}else { //authorizationnotpassed } Objective-C //1.CreatetheAccessControlobjectthatwillrepresentauthenticationsettings CFErrorRef *err=nil; SecAccessControlRefsacRef =SecAccessControlCreateWithFlags(kCFAllocatorDefault, kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly, kSecAccessControlUserPresence, err); //2.Createthekeychainservicesquery.PayattentionthatkSecAttrAccessControlismutuallyexclusivewithkSecAttrAccessibleattribute NSDictionary*query =@{ (__bridgeid)kSecClass:(__bridgeid)kSecClassGenericPassword, (__bridgeid)kSecAttrLabel:@\"com.me.myapp.password\", (__bridgeid)kSecAttrAccount:@\"OWASPAccount\", (__bridgeid)kSecValueData:[@\"test_strong_password\" dataUsingEncoding:NSUTF8StringEncoding], (__bridgeid)kSecAttrAccessControl:(__bridge_transferid)sacRef }; //3.Savetheitem OSStatusstatus =SecItemAdd((__bridgeCFDictionaryRef)query,nil); if(status ==noErr){ //successfullysaved }else { //errorwhilesaving } //4.Nowwecanrequestthesaveditemfromthekeychain.Keychainserviceswillpresenttheauthenticationdialogto theuserandreturndataornildepending ↪ onwhetherasuitablefingerprintwasprovidedornot. //5.Createthequery NSDictionary *query =@{(__bridgeid)kSecClass:(__bridgeid)kSecClassGenericPassword, (__bridgeid)kSecReturnData:@YES, (__bridgeid)kSecAttrAccount:@\"MyName1\", (__bridgeid)kSecAttrLabel:@\"com.me.myapp.password\", (__bridgeid)kSecUseOperationPrompt:@\"Please,passauthorisationtoenterthisarea\" }; //6.Gettheitem CFTypeRefqueryResult =NULL; OSStatusstatus =SecItemCopyMatching((__bridgeCFDictionaryRef)query,&queryResult); if(status ==noErr){ NSData*resultData =(__bridge_transferNSData*)queryResult; NSString*password =[[NSStringalloc]initWithData:resultDataencoding:NSUTF8StringEncoding]; NSLog(@\"%@\",password); }else { NSLog(@\"Somethingwentwrong\"); } Note regarding temporariness of keys in the Keychain UnlikemacOSandAndroid,iOSdoesnotsupporttemporarinessofanitem’saccessibilityinthekeychain: whenthereis noadditionalsecuritycheckwhenenteringthekeychain(e.g.kSecAccessControlUserPresenceorsimilarisset),then oncethedeviceisunlocked,akeywillbeaccessible. Testing Local Authentication Platform: ios MASVSV1: MSTG-AUTH-8,MSTG-STORAGE-11 MASVSV2: MASVS-AUTH-2 424\\nOverview Theusageofframeworksinanappcanbedetectedbyanalyzingtheappbinary’slistofshareddynamiclibraries. This canbedonebyusingotool: otool -L<AppName>.app/<AppName> IfLocalAuthentication.frameworkisusedinanapp,theoutputwillcontainbothofthefollowinglines(rememberthat LocalAuthentication.frameworkusesSecurity.frameworkunderthehood): /System/Library/Frameworks/LocalAuthentication.framework/LocalAuthentication /System/Library/Frameworks/Security.framework/Security IfSecurity.frameworkisused,onlythesecondonewillbeshown. Static Analysis It is important to remember that the LocalAuthentication framework is an event-based procedure and as such, should not be the sole method of authentication. Though this type of authentication is effective on the user-interface level, it iseasilybypassedthroughpatchingorinstrumentation. Therefore,itisbesttousethekeychainservicemethod,which meansyoushould: • Verifythatsensitiveprocesses,suchasre-authenticatingauserperformingapaymenttransaction,areprotected usingthekeychainservicesmethod. • Verifythataccesscontrolflagsaresetforthekeychainitemwhichensurethatthedataofthekeychainitemcan onlybeunlockedbymeansofauthenticatingtheuser. Thiscanbedonewithoneofthefollowingflags: – kSecAccessControlBiometryCurrentSet (before iOS 11.3 kSecAccessControlTouchIDCurrentSet). This willmakesurethatauserneedstoauthenticatewithbiometrics(e.g.FaceIDorTouchID)beforeaccessing thedatainthekeychainitem. Whenevertheuseraddsafingerprintorfacialrepresentationtothedevice,it willautomaticallyinvalidatetheentryintheKeychain. Thismakessurethatthekeychainitemcanonlyever beunlockedbyusersthatwereenrolledwhentheitemwasaddedtothekeychain. – kSecAccessControlBiometryAny(beforeiOS11.3kSecAccessControlTouchIDAny). Thiswillmakesurethat a user needs to authenticate with biometrics (e.g. Face ID or Touch ID) before accessing the data in the Keychainentry. TheKeychainentrywillsurviveany(re-)enrolingofnewfingerprintsorfacialrepresentation. Thiscanbeveryconvenientiftheuserhasachangingfingerprint. However,italsomeansthatattackers,who aresomehowabletoenroletheirfingerprintsorfacialrepresentationstothedevice, cannowaccessthose entriesaswell. – kSecAccessControlUserPresence can be used as an alternative. This will allow the user to authenticate through a passcode if the biometric authentication no longer works. This is considered to be weaker than kSecAccessControlBiometryAny since it is much easier to steal someone’s passcode entry by means of shouldersurfing,thanitistobypasstheTouchIDorFaceIDservice. • Inordertomakesurethatbiometricscanbeused,verifythatthekSecAttrAccessibleWhenPasscodeSetThisDe- viceOnlyorthekSecAttrAccessibleWhenPasscodeSetprotectionclassissetwhentheSecAccessControlCre- ateWithFlagsmethodiscalled. Notethatthe...ThisDeviceOnlyvariantwillmakesurethatthekeychainitem isnotsynchronizedwithotheriOSdevices. Note,adataprotectionclassspecifiestheaccessmethodologyusedtosecurethedata. Eachclassusesdifferent policiestodeterminewhenthedataisaccessible. Dynamic Analysis Objection Biometrics Bypass can be used to bypass LocalAuthentication. Objection uses Frida to instrument theeval- uatePolicy function so that it returns True even if authentication was not successfully performed. Use the ios ui biometrics_bypasscommandtobypasstheinsecurebiometricauthentication. Objectionwillregisterajob,whichwill replacetheevaluatePolicyresult. Itwillworkinboth,SwiftandObjective-Cimplementations. 425\\n...itudehacks.DVIAswiftv2.developon (iPhone:13.2.3)[usb] #iosuibiometrics_bypass (agent)Registeringjob3mhtws9x47q.Type:ios-biometrics-disable ...itudehacks.DVIAswiftv2.developon (iPhone:13.2.3)[usb] #(agent)[3mhtws9x47q]LocalizedReasonforauthrequirement:Pleaseauthenticateyourself (agent)[3mhtws9x47q]OSauthenticationresponse:false (agent)[3mhtws9x47q]MarkingOSresponseasTrueinstead (agent)[3mhtws9x47q]Biometricsbypasshookcomplete Ifvulnerable,themodulewillautomaticallybypasstheloginform. 426\\niOS Network Communication Overview AlmosteveryiOSappactsasaclienttooneormoreremoteservices. Asthisnetworkcommunicationusuallytakesplace overuntrustednetworkssuchaspublicWi-Fi,classicalnetworkbased-attacksbecomeapotentialissue. Most modern mobile apps use variants of HTTP-based web services, as these protocols are well-documented and sup- ported. iOS App Transport Security Starting with iOS 9, Apple introduced App Transport Security (ATS) which is a set of security checks enforced by the operatingsystemforconnectionsmadeusingtheURLLoadingSystem(typicallyviaURLSession)toalwaysuseHTTPS. AppsshouldfollowApple’sbestpracticestoproperlysecuretheirconnections. WatchATSIntroductoryVideofromtheAppleWWDC2015. ATSperformsdefaultservertrustevaluationandrequiresaminimumsetofsecurityrequirements. DefaultServerTrustEvaluation: When an app connects to a remote server, the server provides its identity using an X.509 digital certificate. The ATS defaultservertrustevaluationincludesvalidatingthatthecertificate: • Isn’texpired. • Hasanamethatmatchestheserver’sDNSname. • Has a digital signature that is valid (hasn’t been tampered with) and can be traced back to a trusted Certificate Authority(CA)includedintheoperatingsystemTrustStore, orbeinstalledontheclientbytheuserorasystem administrator. MinimumSecurityRequirementsforConnections: ATSwillblockconnectionsthatfurtherfailtomeetasetofminimumsecurityrequirementsincluding: • TLSversion1.2orgreater. • DataencryptionwithAES-128orAES-256. • ThecertificatemustbesignedwithanRSAkey(2048bitsorgreater),oranECCkey(256bitsorgreater). • Thecertificate’sfingerprintmustuseSHA-256orgreater. • Thelinkmustsupportperfectforwardsecrecy(PFS)throughEllipticCurveDiffie-HellmanEphemeral(ECDHE)key exchange. Certificatevaliditychecking: AccordingtoApple,“evaluatingthetrustedstatusofaTLScertificateisperformedinaccordancewithestablishedindustry standards,assetoutinRFC5280,andincorporatesemergingstandardssuchasRFC6962(CertificateTransparency). In iOS 11 or later, Apple devices are periodically updated with a current list of revoked and constrained certificates. The list is aggregated from certificate revocation lists (CRLs), which are published by each of the built-in root certificate authorities trusted by Apple, as well as by their subordinate CA issuers. The list may also include other constraints at Apple’sdiscretion. ThisinformationisconsultedwheneveranetworkAPIfunctionisusedtomakeasecureconnection. If there are too many revoked certificates from a CA to list individually, a trust evaluation may instead require that an onlinecertificatestatusresponse(OCSP)isneeded,andiftheresponseisn’tavailable,thetrustevaluationwillfail.” When does ATS not apply? • Whenusinglower-levelAPIs: ATSonlyappliestotheURLLoadingSystemincludingURLSessionandAPIslayered ontopofthem.", "metadata": {"doc_id": "OWASP_MASTG", "chunk_id": 144}}