{"text": "security, quality, etc., rulescanbechecked. Ifcasecomplianceisconfirmed,theprocesscancontinue;otherwise,thedevelopmentteam mustremediatetheissue(s)andproposechanges. • ContinuousDeliverycandidatereleasescanproceedtothepre-productionenvironment. Ifthereleasecanthenbe validated(eithermanuallyorautomatically),deploymentcancontinue. Ifnot,theprojectteamwillbenotifiedand properaction(s)mustbetaken. 39\\n• ContinuousDeploymentreleasesaredirectlytransitionedfromintegrationtoproduction,e.g.,theybecomeacces- sible to the user. However, no release should go to production if significant defects have been identified during previousactivities. The delivery and deployment of apps with low or medium sensitivity may be merged into a single step, and validation maybeperformedafterdelivery. However,keepingthesetwoactionsseparateandusingstrongvalidationarestrongly advisedforsensitiveapps. Security Atthispoint,thebigquestionis: nowthatotheractivitiesrequiredfordeliveringcodearecompletedsignificantlyfaster andmoreeffectively,howcansecuritykeepup? Howcanwemaintainanappropriatelevelofsecurity? Deliveringvalue tousersmoreoftenwithdecreasedsecuritywoulddefinitelynotbegood! Onceagain,theanswerisautomationandtooling: byimplementingthesetwoconceptsthroughouttheprojectlifecycle, youcanmaintainandimprovesecurity. Thehighertheexpectedlevelofsecurity, themorecontrols, checkpoints, and emphasiswilltakeplace. Thefollowingareexamples: • Static Application Security Testing can take place during the development phase, and it can be integrated into the Continuous Integration process with more or less emphasis on scan results. You can establish more or less demandingSecureCodingRulesanduseSASTtoolstochecktheeffectivenessoftheirimplementation. • Dynamic Application Security Testing may be automatically performed after the app has been built (e.g., after ContinuousIntegrationhastakenplace)andbeforedelivery,again,withmoreorlessemphasisonresults. • You can add manual validation checkpoints between consecutive phases, for example, between delivery and de- ployment. ThesecurityofanappdevelopedwithDevOpsmustbeconsideredduringoperations. Thefollowingareexamples: • Scanningshouldtakeplaceregularly(atboththeinfrastructureandapplicationlevel). • Pentesting may take place regularly. (The version of the app used in production is the version that should be pentested, and the testing should take place in a dedicated environment and include data that’s similar to the productionversiondata. SeethesectiononPenetrationTestingformoredetails.) • Activemonitoringshouldbeperformedtoidentifyissuesandremediatethemassoonaspossibleviathefeedback loop. 40\\nReferences • [paul]-M.Paul. Official(ISC)2GuidetotheCSSLPCBK,SecondEdition((ISC)2Press),2014 • [mcgraw]-GMcGraw. SoftwareSecurity: BuildingSecurityIn,2006 41\\nMobile App Tampering and Reverse Engineering Reverseengineeringandtamperingtechniqueshavelongbelongedtotherealmofcrackers,modders,malwareanalysts, etc. For“traditional”securitytestersandresearchers,reverseengineeringhasbeenmoreofacomplementaryskill. But thetidesareturning: mobileappblack-boxtestingincreasinglyrequiresdisassemblingcompiledapps,applyingpatches, and tampering with binary code or even live processes. The fact that many mobile apps implement defenses against unwelcometamperingdoesn’tmakethingseasierforsecuritytesters. Reverseengineeringamobileappistheprocessofanalyzingthecompiledapptoextractinformationaboutitssource code. Thegoalofreverseengineeringiscomprehendingthecode. Tamperingistheprocessofchangingamobileapp(eitherthecompiledapportherunningprocess)oritsenvironmentto affectitsbehavior. Forexample,anappmightrefusetorunonyourrootedtestdevice,makingitimpossibletorunsome ofyourtests. Insuchcases,you’llwanttoaltertheapp’sbehavior. Mobile security testers are served well by understanding basic reverse engineering concepts. They should also know mobile devices and operating systems inside out: processor architecture, executable format, programming language intricacies,andsoforth. Reverse engineering is an art, and describing its every facet would fill a whole library. The sheer range of techniques and specializations is mind-blowing: one can spend years working on a very specific and isolated sub-problem, such as automating malware analysis or developing novel de-obfuscation methods. Security testers are generalists; to be effectivereverseengineers,theymustfilterthroughthevastamountofrelevantinformation. There is no generic reverse engineering process that always works. That said, we’ll describe commonly used methods andtoolslaterinthisguide,andgiveexamplesoftacklingthemostcommondefenses. Why You Need It Mobilesecuritytestingrequiresatleastbasicreverseengineeringskillsforseveralreasons: 1. Toenableblack-boxtestingofmobileapps. Modernappsoftenincludecontrolsthatwillhinderdynamicanalysis. SSLpinningandend-to-end(E2E)encryptionsometimespreventyoufrominterceptingormanipulatingtrafficwithaproxy. Rootdetectioncouldpreventtheappfromrunningonarooteddevice,preventingyoufromusingadvancedtestingtools. Youmustbeabletodeactivatethesedefenses. 2. Toenhancestaticanalysisinblack-boxsecuritytesting. Inablack-boxtest,staticanalysisoftheappbytecode orbinarycodehelpsyouunderstandtheinternallogicoftheapp. Italsoallowsyoutoidentifyflawssuchashardcoded credentials. 3. Toassessresilienceagainstreverseengineering. Appsthatimplementthesoftwareprotectionmeasureslisted intheMobileApplicationSecurityVerificationStandardAnti-ReversingControls(MASVS-R)shouldwithstandreverseengi- neeringtoacertaindegree. Toverifytheeffectivenessofsuchcontrols,thetestermayperformaresilienceassessment aspartofthegeneralsecuritytest. Fortheresilienceassessment,thetesterassumestheroleofthereverseengineer andattemptstobypassdefenses. Beforewediveintotheworldofmobileappreversing,wehavesomegoodnewsandsomebadnews. Let’sstartwiththe goodnews: Ultimately,thereverseengineeralwayswins. Thisisparticularlytrueinthemobileindustry,wherethereverseengineerhasanaturaladvantage: thewaymobileapps aredeployedandsandboxedisbydesignmorerestrictivethanthedeploymentandsandboxingofclassicalDesktopapps, so including the rootkit-like defensive mechanisms often found in Windows software (e.g., DRM systems) is simply not feasible. TheopennessofAndroidallowsreverseengineerstomakefavorablechangestotheoperatingsystem,aiding thereverseengineeringprocess. iOSgivesreverseengineerslesscontrol,butdefensiveoptionsarealsomorelimited. The bad news is that dealing with multi-threaded anti-debugging controls, cryptographic white-boxes, stealthy anti- tampering features, and highly complex control flow transformations is not for the faint-hearted. The most effective software protection schemes are proprietary and won’t be beaten with standard tweaks and tricks. Defeating them re- quires tedious manual analysis, coding, frustration and, depending on your personality, sleepless nights and strained relationships. 42\\nIt’s easy for beginners to get overwhelmed by the sheer scope of reversing. The best way to get started is to set up some basic tools (see the relevant sections in the Android and iOS reversing chapters) and start with simple reversing tasks and", "metadata": {"doc_id": "OWASP_MASTG", "chunk_id": 40}}