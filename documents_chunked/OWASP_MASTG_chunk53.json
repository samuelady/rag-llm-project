{"text": "• Dangling pointers: These occur when an object with an incoming reference to a memory location is deleted ordeallocated, buttheobjectpointerisnotreset. Iftheprogramlaterusesthedanglingpointertocallavirtual functionofthealreadydeallocatedobject,itispossibletohijackexecutionbyoverwritingtheoriginalvtablepointer. Alternatively,itispossibletoreadorwriteobjectvariablesorothermemorystructuresreferencedbyadangling pointer. • Use-after-free: Thisreferstoaspecialcaseofdanglingpointersreferencingreleased(deallocated)memory. After amemoryaddressiscleared,allpointersreferencingthelocationbecomeinvalid,causingthememorymanagerto returntheaddresstoapoolofavailablememory. Whenthismemorylocationiseventuallyre-allocated,accessing theoriginalpointerwillreadorwritethedatacontainedinthenewlyallocatedmemory. Thisusuallyleadstodata corruptionandundefinedbehavior,butcraftyattackerscansetuptheappropriatememorylocationstoleverage controloftheinstructionpointer. • Integeroverflows: Whentheresultofanarithmeticoperationexceedsthemaximumvaluefortheintegertype defined by the programmer, this results in the value “wrapping around” the maximum integer value, inevitably resultinginasmallvaluebeingstored. Conversely,whentheresultofanarithmeticoperationissmallerthanthe minimumvalueoftheintegertype,anintegerunderflowoccurswheretheresultislargerthanexpected. Whether aparticularintegeroverflow/underflowbugisexploitabledependsonhowtheintegerisused. Forexample,ifthe integertypeweretorepresentthelengthofabuffer,thiscouldcreateabufferoverflowvulnerability. • Formatstringvulnerabilities: Whenuncheckeduserinputispassedtotheformatstringparameteroftheprintf familyofCfunctions,attackersmayinjectformattokenssuchas‘%c’and‘%n’toaccessmemory. Formatstring bugsareconvenienttoexploitduetotheirflexibility. Shouldaprogramoutputtheresultofthestringformatting operation,theattackercanreadandwritetomemoryarbitrarily,thusbypassingprotectionfeaturessuchasASLR. Theprimarygoalinexploitingmemorycorruptionisusuallytoredirectprogramflowintoalocationwheretheattackerhas placedassembledmachineinstructionsreferredtoasshellcode. OniOS,thedataexecutionpreventionfeature(asthe nameimplies)preventsexecutionfrommemorydefinedasdatasegments. Tobypassthisprotection,attackersleverage return-orientedprogramming(ROP).Thisprocessinvolveschainingtogethersmall,pre-existingcodechunks(“gadgets”) in the text segment where these gadgets may execute a function useful to the attacker or, call mprotect to change memoryprotectionsettingsforthelocationwheretheattackerstoredtheshellcode. Android apps are, for the most part, implemented in Java which is inherently safe from memory corruption issues by design. However,nativeappsutilizingJNIlibrariesaresusceptibletothiskindofbug. Inrarecases,Androidappsthatuse XML/JSONparserstounwrapJavaobjectsarealsosubjecttomemorycorruptionbugs. Anexampleofsuchvulnerability wasfoundinthePayPalapp. Similarly,iOSappscanwrapC/C++callsinObj-CorSwift,makingthemsusceptibletothesekindofattacks. Example: Thefollowingcodesnippetshowsasimpleexampleforaconditionresultinginabufferoverflowvulnerability. void copyData(char *userId){ char smallBuffer[10];//sizeof10 strcpy(smallBuffer,userId); } Toidentifypotentialbufferoverflows,lookforusesofunsafestringfunctions(strcpy,strcat,otherfunctionsbeginning withthe“str”prefix,etc.) andpotentiallyvulnerableprogrammingconstructs,suchascopyinguserinputintoalimited- sizebuffer. Thefollowingshouldbeconsideredredflagsforunsafestringfunctions: • strcat 81\\n• strcpy • strncat • strlcat • strncpy • strlcpy • sprintf • snprintf • gets Also,lookforinstancesofcopyoperationsimplementedas“for”or“while”loopsandverifylengthchecksareperformed correctly. Verifythatthefollowingbestpracticeshavebeenfollowed: • Whenusingintegervariablesforarrayindexing,bufferlengthcalculations,oranyothersecurity-criticaloperation, verifythatunsignedintegertypesareusedandperformpreconditiontestsareperformedtopreventthepossibility ofintegerwrapping. • Theappdoesnotuseunsafestringfunctionssuchasstrcpy,mostotherfunctionsbeginningwiththe“str”prefix, sprint,vsprintf,gets,etc.; • IftheappcontainsC++code,ANSIC++stringclassesareused; • Incaseofmemcpy,makesureyoucheckthatthetargetbufferisatleastofequalsizeasthesourceandthatboth buffersarenotoverlapping. • iOSappswritteninObjective-CuseNSStringclass. CappsoniOSshoulduseCFString,theCoreFoundationrepre- sentationofastring. • Nountrusteddataisconcatenatedintoformatstrings. Static Analysis Security Testing Considerations Staticcodeanalysisoflow-levelcodeisacomplextopicthatcouldeasilyfillitsownbook. AutomatedtoolssuchasRATS combinedwithlimitedmanualinspectioneffortsareusuallysufficienttoidentifylow-hangingfruits. However, memory corruption conditions often stem from complex causes. For example, a use-after-free bug may actually be the result of an intricate, counter-intuitive race condition not immediately apparent. Bugs manifesting from deep instances of overlookedcodedeficienciesaregenerallydiscoveredthroughdynamicanalysisorbytesterswhoinvesttimetogaina deepunderstandingoftheprogram. Dynamic Analysis Security Testing Considerations Memory corruption bugs are best discovered via input fuzzing: an automated black-box software testing technique in whichmalformeddataiscontinuallysenttoanapptosurveyforpotentialvulnerabilityconditions. Duringthisprocess, theapplicationismonitoredformalfunctionsandcrashes. Shouldacrashoccur,thehope(atleastforsecuritytesters) isthattheconditionscreatingthecrashrevealanexploitablesecurityflaw. Fuzztestingtechniquesorscripts(oftencalled“fuzzers”)willtypicallygeneratemultipleinstancesofstructuredinputina semi-correctfashion. Essentially,thevaluesorargumentsgeneratedareatleastpartiallyacceptedbythetargetapplica- tion,yetalsocontaininvalidelements,potentiallytriggeringinputprocessingflawsandunexpectedprogrambehaviors. A good fuzzer exposes a substantial amount of possible program execution paths (i.e. high coverage output). Inputs are either generated from scratch (“generation-based”) or derived from mutating known, valid input data (“mutation- based”). Formoreinformationonfuzzing,refertotheOWASPFuzzingGuide. Binary Protection Mechanisms Position Independent Code PIC(PositionIndependentCode)iscodethat,beingplacedsomewhereintheprimarymemory,executesproperlyregard- lessofitsabsoluteaddress. PICiscommonlyusedforsharedlibraries,sothatthesamelibrarycodecanbeloadedina 82\\nlocationineachprogramaddressspacewhereitdoesnotoverlapwithothermemoryinuse(forexample,othershared libraries). PIE (Position Independent Executable) are executable binaries made entirely from PIC. PIE binaries are used to enable ASLR(AddressSpaceLayoutRandomization)whichrandomlyarrangestheaddressspacepositionsofkeydataareasof aprocess,includingthebaseoftheexecutableandthepositionsofthestack,heapandlibraries. Memory Management Automatic Reference Counting ARC(AutomaticReferenceCounting)isamemorymanagementfeatureoftheClangcompilerexclusivetoObjective-Cand Swift. ARCautomaticallyfreesupthememoryusedbyclassinstanceswhenthoseinstancesarenolongerneeded. ARC differsfromtracinggarbagecollectioninthatthereisnobackgroundprocessthatdeallocatestheobjectsasynchronously atruntime. Unliketracinggarbagecollection,ARCdoesnothandlereferencecyclesautomatically. Thismeansthataslongasthere are“strong”referencestoanobject,itwillnotbedeallocated. Strongcross-referencescanaccordinglycreatedeadlocks andmemoryleaks. Itisuptothedevelopertobreakcyclesbyusingweakreferences. Youcanlearnmoreabouthowit differsfromGarbageCollectionhere. Garbage Collection GarbageCollection(GC)isanautomaticmemorymanagementfeatureofsomelanguagessuchasJava/Kotlin/Dart. The garbage collector attempts to reclaim memory which was allocated by the program, but is no longer referenced—also called garbage. The Android runtime (ART) makes use of an improved version of GC. You can learn more about how it differsfromARChere. Manual Memory Management Manualmemory managementistypically requiredin native librarieswritten inC/C++ whereARCand GC donot apply. Thedeveloperisresponsiblefordoingpropermemorymanagement. Manualmemorymanagementisknowntoenable several major classes of bugs into a program when used incorrectly, notably violations of memory safety or memory leaks. Moreinformationcanbefoundin“MemoryCorruptionBugs”. Stack Smashing Protection Stackcanarieshelppreventstackbufferoverflowattacksbystoringahiddenintegervalueonthestackrightbeforethe return pointer. This value is then validated before the return statement of the function is executed. A buffer overflow attack often overwrites a region of memory in order to overwrite the return pointer and take over the program flow. If stackcanariesareenabled,theywillbeoverwrittenaswellandtheCPUwillknowthatthememoryhasbeentampered with. Stackbufferoverflowisatypeofthemoregeneralprogrammingvulnerabilityknownasbufferoverflow(orbufferoverrun). Overfillingabufferonthestackismorelikelytoderailprogramexecutionthanoverfillingabufferontheheapbecause thestackcontainsthereturnaddressesforallactivefunctioncalls. 83\\nMobile App User Privacy Protection Overview IMPORTANTDISCLAIMER:TheMASTGisnotalegalhandbook. Therefore,wewillnotdeepdiveintotheGDPRorother possibly relevant legislation here. This chapter is meant to introduce you to the topics and provide you with essential referencesthatyoucanusetocontinueresearchingbyyourself. We’llalsodoourbestefforttoprovideyouwithtestsor guidelinesfortestingtheprivacy-relatedrequirementslistedintheOWASPMASVS. The Main Problem Mobileappshandleallkindsofsensitiveuserdata,fromidentificationandbankinginformationtohealthdata. Thereisan understandableconcernabouthowthisdataishandledandwhereitendsup. Wecanalsotalkabout“benefitsusersget fromusingtheapps”vs“therealpricethattheyarepayingforit”(usuallyandunfortunatelywithoutevenbeingaware ofit). The Solution", "metadata": {"doc_id": "OWASP_MASTG", "chunk_id": 53}}