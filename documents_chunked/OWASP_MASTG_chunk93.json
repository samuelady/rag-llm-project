{"text": "settings using the so-called NetworkSecurityConfigurationfeaturewhichoffersthefollowingkeycapabilities: • Cleartexttraffic: Protectappsfromaccidentalusageofcleartexttraffic(orenablesit). • Customtrustanchors: CustomizewhichCertificateAuthorities(CAs)aretrustedforanapp’ssecureconnections. Forexample,trustingparticularself-signedcertificatesorrestrictingthesetofpublicCAsthattheapptrusts. • Certificatepinning: Restrictanapp’ssecureconnectiontoparticularcertificates. • Debug-onlyoverrides: Safelydebugsecureconnectionsinanappwithoutaddedrisktotheinstalledbase. If an app defines a custom Network Security Configuration, you can obtain its location by searching for an- droid:networkSecurityConfigintheAndroidManifest.xmlfile. <application android:networkSecurityConfig=\"@xml/network_security_config\" Inthiscasethefileislocatedat@xml(equivalentto/res/xml)andhasthename“network_security_config”(whichmight vary). Youshouldbeabletofinditas“res/xml/network_security_config.xml”. Ifaconfigurationexists,thefollowingevent shouldbevisibleinthesystemlogs: D/NetworkSecurityConfig:UsingNetworkSecurityConfigfromresourcenetwork_security_config TheNetworkSecurityConfigurationisXML-basedandcanbeusedtoconfigureapp-wideanddomain-specificsettings: • base-configappliestoallconnectionsthattheappattemptstomake. • domain-configoverridesbase-configforspecificdomains(itcancontainmultipledomainentries). Forexample,thefollowingconfigurationusesthebase-configtopreventcleartexttrafficforalldomains. Butitoverrides thatruleusingadomain-config,explicitlyallowingcleartexttrafficforlocalhost. <?xml version=\"1.0\" encoding=\"utf-8\"?> <network-security-config> <base-config cleartextTrafficPermitted=\"false\" /> <domain-config cleartextTrafficPermitted=\"true\"> <domain>localhost</domain> </domain-config> </network-security-config> Learnmore: • “ASecurityAnalyst’sGuidetoNetworkSecurityConfigurationinAndroidP” • AndroidDevelopers-NetworkSecurityConfiguration • AndroidCodelab-NetworkSecurityConfiguration Default Configurations ThedefaultconfigurationforappstargetingAndroid9(APIlevel28)andhigherisasfollows: 234\\n<base-config cleartextTrafficPermitted=\"false\"> <trust-anchors> <certificates src=\"system\" /> </trust-anchors> </base-config> ThedefaultconfigurationforappstargetingAndroid7.0(APIlevel24)toAndroid8.1(APIlevel27)isasfollows: <base-config cleartextTrafficPermitted=\"true\"> <trust-anchors> <certificates src=\"system\" /> </trust-anchors> </base-config> ThedefaultconfigurationforappstargetingAndroid6.0(APIlevel23)andlowerisasfollows: <base-config cleartextTrafficPermitted=\"true\"> <trust-anchors> <certificates src=\"system\" /> <certificates src=\"user\" /> </trust-anchors> </base-config> Certificate Pinning The Network Security Configuration can also be used to pin declarative certificates to specific domains. This is done by providing a <pin-set> in the Network Security Configuration, which is a set of digests (hashes) of the public key (SubjectPublicKeyInfo)ofthecorrespondingX.509certificate. Whenattemptingtoestablishaconnectiontoaremoteendpoint,thesystemwill: • Getandvalidatetheincomingcertificate. • Extractthepublickey. • Calculateadigestovertheextractedpublickey. • Comparethedigestwiththesetoflocalpins. If at least one of the pinned digests matches, the certificate chain will be considered valid and the connection will pro- ceed. <?xml version=\"1.0\" encoding=\"utf-8\"?> <network-security-config> <domain-config> UsecertificatepinningforOWASPwebsiteaccessincludingsubdomains <domain includeSubdomains=\"true\">owasp.org</domain> <pin-set expiration=\"2018/8/10\"> <!--Hashofthepublickey(SubjectPublicKeyInfooftheX.509certificate)of theIntermediateCAoftheOWASPwebsiteservercertificate--> <pindigest=\"SHA-256\">YLh1dUR9y6Kja30RrAn7JKnbQG/uEtLMkBgFF2Fuihg=</pin> <!--Hashofthepublickey(SubjectPublicKeyInfooftheX.509certificate)of theRootCAoftheOWASPwebsiteservercertificate--> <pindigest=\"SHA-256\">Vjs8r4z+80wjNcr1YKepWQboSIRi63WsWXhIMN+eWys=</pin> </pin-set> </domain-config> </network-security-config> Security Provider AndroidreliesonasecurityprovidertoprovideSSL/TLS-basedconnections. Theproblemwiththiskindofsecurityprovider (oneexampleisOpenSSL),whichcomeswiththedevice,isthatitoftenhasbugsand/orvulnerabilities. Toavoidknownvulnerabilities, developersneedtomakesurethattheapplicationwillinstallapropersecurityprovider. SinceJuly11, 2016, GooglehasbeenrejectingPlayStoreapplicationsubmissions(bothnewapplicationsandupdates) thatusevulnerableversionsofOpenSSL. Testing Custom Certificate Stores and Certificate Pinning 235\\nPlatform: android MASVSV1: MSTG-NETWORK-4 MASVSV2: MASVS-NETWORK-2 Overview Static Analysis Network Security Configuration InspecttheNetworkSecurityConfigurationlookingforany<pin-set>elements. Checktheirexpirationdate,ifany. If expired,certificatepinningwillbedisabledfortheaffecteddomains. TestingTip: Ifacertificatepinningvalidationcheckhasfailed,thefollowingeventshouldbeloggedinthesystem logs: I/X509Util:Failedtovalidatethecertificatechain,error:Pinverificationfailed TrustManager Implementingcertificatepinninginvolvesthreemainsteps: • Obtainthecertificateofthedesiredhost(s). • Makesurethecertificateisin.bksformat. • PinthecertificatetoaninstanceofthedefaultApacheHttpclient. Toanalyzethecorrectimplementationofcertificatepinning,theHTTPclientshouldloadtheKeyStore: InputStreamin =resources.openRawResource(certificateRawResource); keyStore =KeyStore.getInstance(\"BKS\"); keyStore.load(resourceStream,password); OncetheKeyStorehasbeenloaded,wecanusetheTrustManagerthattruststheCAsinourKeyStore: StringtmfAlgorithm =TrustManagerFactory.getDefaultAlgorithm(); TrustManagerFactorytmf =TrustManagerFactory.getInstance(tmfAlgorithm); tmf.init(keyStore); //CreateanSSLContextthatusestheTrustManager //SSLContextcontext=SSLContext.getInstance(\"TLS\"); sslContext.init(null,tmf.getTrustManagers(),null); Theapp’simplementationmaybedifferent, pinningagainstthecertificate’spublickeyonly, thewholecertificate, ora wholecertificatechain. Network Libraries and WebViews Applicationsthatusethird-partynetworkinglibrariesmayutilizethelibraries’certificatepinningfunctionality. Forexample, okhttpcanbesetupwiththeCertificatePinnerasfollows: OkHttpClientclient =newOkHttpClient.Builder() .certificatePinner(newCertificatePinner.Builder() .add(\"example.com\",\"sha256/UwQAapahrjCOjYI3oLUx5AQxPBR02Jz6/E2pt0IeLXA=\") .build()) .build(); ApplicationsthatuseaWebViewcomponentmayutilizetheWebViewClient’seventhandlerforsomekindof“certificate pinning”ofeachrequestbeforethetargetresourceisloaded. Thefollowingcodeshowsanexampleverification: 236\\nWebViewmyWebView =(WebView)findViewById(R.id.webview); myWebView.setWebViewClient(newWebViewClient(){ private StringexpectedIssuerDN =\"CN=Let'sEncryptAuthorityX3,O=Let'sEncrypt,C=US;\"; @Override public void onLoadResource(WebViewview,Stringurl) { //FromAndroidAPIdocumentationabout\"WebView.getCertificate()\": //GetstheSSLcertificateforthemaintop-levelpage //ornullifthereisnocertificate(thesiteisnotsecure). // //AvailableinformationonSslCertificateclassare\"IssuerDN\",\"SubjectDN\"andvaliditydatehelpers SslCertificateserverCert =view.getCertificate(); if(serverCert !=null){ //applyeithercertificateorpublickeypinningcomparisonhere //Throwexceptiontocancelresourceloading... } } } }); Alternatively, itisbettertouseanOkHttpClientwithconfiguredpinsandletitactasaproxyoverridingshouldInter- ceptRequestoftheWebViewClient. Xamarin Applications ApplicationsdevelopedinXamarinwilltypicallyuseServicePointManagertoimplementpinning. Normallyafunctioniscreatedtocheckthecertificate(s)andreturnthebooleanvaluetothemethodServerCertificat- eValidationCallback: [Activity(Label =\"XamarinPinning\",MainLauncher =true)] public class MainActivity :Activity { //SupportedPublicKey-Hexadecimalvalueofthepublickey. //UseGetPublicKeyString()methodtodeterminethepublickeyofthecertificatewewanttopin.Uncommentthedebugcode inthe ↪ ValidateServerCertificatefunctionafirsttimetodeterminethevaluetopin. private const string SupportedPublicKey =\"3082010A02820101009CD30CF05AE52E47B7725D3783B...\";//Shortened forreadability private static bool ValidateServerCertificate( object sender, X509Certificatecertificate, X509Chainchain, SslPolicyErrorssslPolicyErrors ) { //Log.Debug(\"XamarinPinning\",chain.ChainElements[X].Certificate.GetPublicKeyString()); //returntrue; return SupportedPublicKey ==chain.ChainElements[1].Certificate.GetPublicKeyString(); } protected override void OnCreate(BundlesavedInstanceState) { System.Net.ServicePointManager.ServerCertificateValidationCallback +=ValidateServerCertificate; base.OnCreate(savedInstanceState); SetContentView(Resource.Layout.Main); TesteAsync(\"https://security.claudio.pt\"); } InthisparticularexamplewearepinningtheintermediateCAofthecertificatechain. TheoutputoftheHTTPresponse willbeavailableinthesystemlogs. SampleXamarinappwiththepreviousexamplecanbeobtainedontheMASTGrepository After decompressing the APK file, use a .NET decompiler like dotPeak, ILSpy or dnSpy to decompile the app dlls stored insidethe‘Assemblies’folderandconfirmtheusageoftheServicePointManager. Learnmore: • Certificate and Public Key Pinning with Xamarin - https://thomasbandt.com/certificate-and-public-key-pinning- with-xamarin • ServicePointManager-https://msdn.microsoft.com/en-us/library/system.net.servicepointmanager(v=vs.110).aspx Cordova Applications 237\\nHybrid applications based on Cordova do not support Certificate Pinning natively, so plugins are used to achieve this. The most common one is PhoneGap SSL Certificate Checker. The check method is used to confirm the fingerprint and callbackswilldeterminethenextsteps. //Endpointtoverifyagainstcertificatepinning. varserver =\"https://www.owasp.org\"; //SHA256Fingerprint(Canbeobtainedvia\"openssls_client-connecthostname:443|opensslx509-noout-fingerprint-sha256\" varfingerprint =\"D8EF3CDF7EF644BA04ECD59714BB004A7AF52663 53874E766777F0F4CCED67B9\"; window.plugins.sslCertificateChecker.check( successCallback, errorCallback, server, fingerprint); function successCallback(message){ alert(message); //Messageisalways:CONNECTION_SECURE. //Nowdosomethingwiththetrustedserver. } function errorCallback(message){ alert(message); if(message ===\"CONNECTION_NOT_SECURE\"){ //Thereislikelyamaninthemiddleattackgoingon,becareful! }else if(message.indexOf(\"CONNECTION_FAILED\")>-1){ //Therewasnoconnection(yet).Internetmaybedown.Tryagain(afewtimes)afteralittletimeout. } } AfterdecompressingtheAPKfile,Cordova/Phonegapfileswillbelocatedinthe/assets/wwwfolder. The‘plugins’folderwill giveyouthevisibilityofthepluginsused. WewillneedtosearchforthismethodsintheJavaScriptcodeoftheapplication toconfirmitsusage. Dynamic Analysis Followtheinstructionsfrom“TestingEndpointIdentifyVerification>DynamicAnalysis”. Ifdoingsodoesn’tleadtotraffic beingproxied,itmaymeanthatcertificatepinningisactuallyimplementedandallsecuritymeasuresareinplace. Does thesamehappenforalldomains? As a quick smoke test, you can try to bypass certificate pinning using objection as described in “Bypassing Certificate Pinning”. PinningrelatedAPIsbeinghookedbyobjectionshouldappearinobjection’soutput. However,keepinmindthat:", "metadata": {"doc_id": "OWASP_MASTG", "chunk_id": 93}}