{"text": ";likely │ │││ 0x00001818 ldrbr4,[fp,-0x19] │ │││ 0x0000181c blfcn.00001728 │ │││ 0x00001820 movr3,r0 │ │││ 0x00001824 cmpr4,r3 │ ╭────<0x00001828 bne0x1854 ;likely │ ││││ 0x0000182c ldrbr4,[fp,-0x18] │ ││││ 0x00001830 blfcn.00001744 │ ││││ 0x00001834 movr3,r0 │ ││││ 0x00001838 cmpr4,r3 │ ╭─────<0x0000183c bne0x1854 ;likely │ │││││ 0x00001840 ldrr3,[0x0000186c] ;[0x186c:4]=0x270section..hash;section..hash │ │││││ 0x00001844 addr3,pc,r3 ;0x1abc;\"Productactivationpassed.Congratulations!\" │ │││││ 0x00001848 movr0,r3 ;0x1abc;\"Productactivationpassed.Congratulations!\"; │ │││││ 0x0000184c blsym.imp.puts ;intputs(constchar*s) │ │││││ ;intputs(\"Productactivationpassed.Congratulations!\") │ ╭──────<0x00001850 b0x1864 │ ││││││ ;CODEXREFSfromfcn.00001760(0x17ec,0x1800,0x1814,0x1828,0x183c) │ │╰╰╰╰╰─>0x00001854 ldrr3,aav.0x00000288 ;[0x1870:4]=0x288aav.0x00000288 │ │ 0x00001858 addr3,pc,r3 ;0x1ae8;\"Incorrectserial.\"; │ │ 0x0000185c movr0,r3 ;0x1ae8;\"Incorrectserial.\"; │ │ 0x00001860 blsym.imp.puts ;intputs(constchar*s) │ │ ;intputs(\"Incorrectserial.\") │ │ ;CODEXREFfromfcn.00001760(0x1850) │ ╰──────>0x00001864 subsp,fp,8 ╰ 0x00001868 pop{r4,fp,pc} ;entry.preinit0;entry.preinit0; Discussingalltheinstructionsinthefunctionisbeyondthescopeofthischapter,insteadwewilldiscussonlytheimportant pointsneededfortheanalysis. Inthevalidationfunction, thereisalooppresentat0x00001784whichperformsaXOR operationatoffset0x00001798. Theloopismoreclearlyvisibleinthegraphviewbelow. 119\\nXORisaverycommonlyusedtechniquetoencryptinformationwhereobfuscationisthegoalratherthansecurity. XOR shouldnotbeusedforanyseriousencryption,asitcanbecrackedusingfrequencyanalysis. Therefore,themere presenceofXORencryptioninsuchavalidationlogicalwaysrequiresspecialattentionandanalysis. Movingforward,atoffset0x000017dc,theXORdecodedvalueobtainedfromaboveisbeingcomparedagainstthereturn valuefromasub-functioncallat0x000017e8. Clearlythisfunctionisnotcomplex,andcanbeanalyzedmanually,butstillremainsacumbersometask. Especiallywhile 120\\nworking on a big code base, time can be a major constraint, and it is desirable to automate such analysis. Dynamic symbolic execution is helpful in exactly those situations. In the above crackme, the symbolic execution engine can determinetheconstraintsoneachbyteoftheinputstringbymappingapathbetweenthefirstinstructionofthelicense check(at0x00001760)andthecodethatprintsthe“Productactivationpassed”message(at0x00001840). Theconstraintsobtainedfromtheabovestepsarepassedtoasolverengine,whichfindsaninputthatsatisfiesthem-a validlicensekey. YouneedtoperformseveralstepstoinitializeAngr’ssymbolicexecutionengine: • LoadthebinaryintoaProject,whichisthestartingpointforanykindofanalysisinAngr. • Passtheaddressfromwhichtheanalysisshouldstart. Inthiscase,wewillinitializethestatewiththefirstinstruction oftheserialvalidationfunction. Thismakestheproblemsignificantlyeasiertosolvebecauseyouavoidsymbolically executingtheBase32implementation. • Passtheaddressofthecodeblockthattheanalysisshouldreach. Inthiscase,that’stheoffset0x00001840,where thecoderesponsibleforprintingthe“Productactivationpassed”messageislocated. • Also,specifytheaddressesthattheanalysisshouldnotreach. Inthiscase,thecodeblockthatprintsthe“Incorrect serial”messageat0x00001854isnotinteresting. NotethattheAngrloaderwillloadthePIEexecutablewithabaseaddressof0x400000,whichneedstobeadded totheoffsetsfromiaitobeforepassingittoAngr. Thefinalsolutionscriptispresentedbelow: importangr #Version:9.2.2 importbase64 load_options ={} b=angr.Project(\"./validate\",load_options =load_options) ##Thekeyvalidationfunctionstartsat0x401760,sothat'swherewecreatetheinitialstate. ##Thisspeedsthingsupalotbecausewe'rebypassingtheBase32-encoder. options ={ angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY, angr.options.ZERO_FILL_UNCONSTRAINED_REGISTERS, } state =b.factory.blank_state(addr=0x401760,add_options=options) simgr =b.factory.simulation_manager(state) simgr.explore(find=0x401840,avoid=0x401854) ##0x401840=Productactivationpassed ##0x401854=Incorrectserial found =simgr.found[0] ##Getthesolutionstringfrom*(R11-0x20). addr =found.memory.load(found.regs.r11 -0x20,1,endness=\"Iend_LE\") concrete_addr =found.solver.eval(addr) solution =found.solver.eval(found.memory.load(concrete_addr,10),cast_to=bytes) print(base64.b32encode(solution)) 121\\nAs discussed previously in the section “Dynamic Binary Instrumentation”, the symbolic execution engine constructs a binary tree of the operations for the program input given and generates a mathematical equation for each possible paththatmightbetaken. Internally,Angrexploresallthepathsbetweenthetwopointsspecifiedbyus,andpassesthe correspondingmathematicalequationstothesolvertoreturnmeaningfulconcreteresults. Wecanaccessthesesolutions viasimulation_manager.foundlist,whichcontainsallthepossiblepathsexploredbyAngrwhichsatisfiesourspecified searchcriteria. Take a closer look at the latter part of the script where the final solution string is being retrieved. The address of the string is obtained from address r11 - 0x20. This may appear magical at first, but a careful analysis of the function at 0x00001760holdstheclue,asitdeterminesifthegiveninputstringisavalidlicensekeyornot. Inthedisassemblyabove, youcanseehowtheinputstringtothefunction(inregisterR0)isstoredintoalocalstackvariable0x0000176c str r0,[var_20h]. Hence,wedecidedtousethisvaluetoretrievethefinalsolutioninthescript. Usingfound.solver.eval youcanaskthesolverquestionslike“giventheoutputofthissequenceofoperations(thecurrentstateinfound),what musttheinput(ataddr)havebeen?”. InARMv7,R11iscalledfp(functionpointer),thereforeR11 - 0x20isequivalenttofp-0x20: var int32_t var_20h @ fp-0x20 Next,theendnessparameterinthescriptspecifiesthatthedataisstoredin“little-endian”fashion,whichisthecasefor almostalloftheAndroiddevices. Also, it may appear as if the script is simply reading the solution string from the memory of the script. However, it’s readingitfromthesymbolicmemory. Neitherthestringnorthepointertothestringactuallyexist. Thesolverensures thatthesolutionitprovidesisthesameasiftheprogramwouldbeexecutedtothatpoint. Runningthisscriptshouldreturnthefollowingoutput: $python3solve.py WARNING |...|cle.loader |Themainbinaryisaposition-independentexecutable.Itisbeingloadedwithabaseaddressof0x400000. b'JACE6ACIARNAAIIA' NowyoucanrunthevalidatebinaryinyourAndroiddevicetoverifythesolutionasindicatedhere. Youmayobtaindifferentsolutionsusingthescript,astherearemultiplevalidlicensekeyspossible. To conclude, learning symbolic execution might look a bit intimidating at first, as it requires deep understanding and extensive practice. However, the effort is justified considering the valuable time it can save in contrast to analyzing complexdisassembledinstructionsmanually. Typicallyyou’dusehybridtechniques,asintheaboveexample,wherewe performed manual analysis of the disassembled code to provide the correct criteria to the symbolic execution engine. PleaserefertotheiOSchapterformoreexamplesonAngrusage. Patching Platform: android MakingsmallchangestotheAndroidManifestorbytecodeisoftenthequickestwaytofixsmallannoyancesthatprevent youfromtestingorreverseengineeringanapp. OnAndroid,twoissuesinparticularhappenregularly: 1. Youcan’tinterceptHTTPStrafficwithaproxybecausetheappemploysSSLpinning. 2. Youcan’tattachadebuggertotheappbecausetheandroid:debuggableflagisnotsetto\"true\"intheAndroid Manifest. In most cases, both issues can be fixed by making minor changes to the app (aka. patching) and then re-signing and repackagingit. AppsthatrunadditionalintegritychecksbeyonddefaultAndroidcode-signingareanexception. Inthose cases,youhavetopatchtheadditionalchecksaswell. ThefirststepisunpackinganddisassemblingtheAPKwithapktool: 122\\napktooldtarget_apk.apk Note: To save time, you may use the flag --no-src if you only want to unpack the APK but not disassemble the code. Forexample,whenyouonlywanttomodifytheAndroidManifestandrepackimmediately. Patching Example: Disabling Certificate Pinning Certificate pinning is an issue for security testers who want to intercept HTTPS communication for legitimate reasons. PatchingbytecodetodeactivateSSLpinningcanhelpwiththis. Todemonstratebypassingcertificatepinning,we’llwalk throughanimplementationinanexampleapplication. Onceyou’veunpackedanddisassembledtheAPK,it’stimetofindthecertificatepinningchecksintheSmalisourcecode. Searchingthecodeforkeywordssuchas“X509TrustManager”shouldpointyouintherightdirection. Inourexample,asearchfor“X509TrustManager”returnsoneclassthatimplementsacustomTrustManager. Thederived classimplementsthemethodscheckClientTrusted,checkServerTrusted,andgetAcceptedIssuers. To bypass the pinning", "metadata": {"doc_id": "OWASP_MASTG", "chunk_id": 64}}