{"text": "classes, which are explained in more detail in theiOS Security Guide: • CompleteProtection(NSFileProtectionComplete): AkeyderivedfromtheuserpasscodeandthedeviceUID protectsthisclasskey. Thederivedkeyiswipedfrommemoryshortlyafterthedeviceislocked,makingthedata inaccessibleuntiltheuserunlocksthedevice. • ProtectedUnlessOpen(NSFileProtectionCompleteUnlessOpen): ThisprotectionclassissimilartoComplete Protection,but,ifthefileisopenedwhenunlocked,theappcancontinuetoaccessthefileeveniftheuserlocks thedevice. Thisprotectionclassisusedwhen,forexample,amailattachmentisdownloadinginthebackground. • Protected Until First User Authentication (NSFileProtectionCompleteUntilFirstUserAuthentication): Thefilecanbeaccessedassoonastheuserunlocksthedeviceforthefirsttimeafterbooting. Itcanbeaccessed eveniftheusersubsequentlylocksthedeviceandtheclasskeyisnotremovedfrommemory. • No Protection (NSFileProtectionNone): The key for this protection class is protected with the UID only. The class key is stored in “Effaceable Storage”, which is a region of flash memory on the iOS device that allows the storage of small amounts of data. This protection class exists for fast remote wiping (immediate deletion of the classkey,whichmakesthedatainaccessible). AllclasskeysexceptNSFileProtectionNoneareencryptedwithakeyderivedfromthedeviceUIDandtheuser’spass- code. Asaresult,decryptioncanhappenonlyonthedeviceitselfandrequiresthecorrectpasscode. SinceiOS7,thedefaultdataprotectionclassis“ProtectedUntilFirstUserAuthentication”. External Storage The Keychain TheiOSKeychaincanbeusedtosecurelystoreshort,sensitivebitsofdata,suchasencryptionkeysandsessiontokens. ItisimplementedasanSQLitedatabasethatcanbeaccessedthroughtheKeychainAPIsonly. OnmacOS,everyuserapplicationcancreateasmanyKeychainsasdesired,andeveryloginaccounthasitsownKeychain. ThestructureoftheKeychainoniOSisdifferent: onlyoneKeychainisavailabletoallapps. Accesstotheitemscanbe sharedbetweenappssignedbythesamedeveloperviatheaccessgroupsfeatureoftheattributekSecAttrAccessGroup. Access to the Keychain is managed by the securityd daemon, which grants access according to the app’s Keychain- access-groups,application-identifier,andapplication-groupentitlements. TheKeychainAPIincludesthefollowingmainoperations: • SecItemAdd • SecItemUpdate • SecItemCopyMatching • SecItemDelete 401\\nDatastoredintheKeychainisprotectedviaaclassstructurethatissimilartotheclassstructureusedforfileencryption. ItemsaddedtotheKeychainareencodedasabinaryplistandencryptedwitha128-bitAESper-itemkeyinGalois/Counter Mode(GCM).Notethatlargerblobsofdataaren’tmeanttobesaveddirectlyintheKeychain-that’swhattheDataProtec- tionAPIisfor. YoucanconfiguredataprotectionforKeychainitemsbysettingthekSecAttrAccessiblekeyinthecallto SecItemAddorSecItemUpdate. ThefollowingconfigurableaccessibilityvaluesforkSecAttrAccessiblearetheKeychain DataProtectionclasses: • kSecAttrAccessibleAlways: The data in the Keychain item can always be accessed, regardless of whether the deviceislocked. • kSecAttrAccessibleAlwaysThisDeviceOnly: ThedataintheKeychainitemcanalwaysbeaccessed,regardless ofwhetherthedeviceislocked. Thedatawon’tbeincludedinaniCloudorlocalbackup. • kSecAttrAccessibleAfterFirstUnlock: ThedataintheKeychainitemcan’tbeaccessedafterarestartuntilthe devicehasbeenunlockedoncebytheuser. • kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly: The data in the Keychainitem can’t be accessed after a restart until the device has been unlocked once by the user. Items with this attribute do not migrate to a new device. Thus,afterrestoringfromabackupofadifferentdevice,theseitemswillnotbepresent. • kSecAttrAccessibleWhenUnlocked: The data in the Keychain item can be accessed only while the device is un- lockedbytheuser. • kSecAttrAccessibleWhenUnlockedThisDeviceOnly: The data in the Keychain item can be accessed only while thedeviceisunlockedbytheuser. Thedatawon’tbeincludedinaniCloudorlocalbackup. • kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly: ThedataintheKeychaincanbeaccessedonlywhenthe device is unlocked. This protection class is only available if a passcode is set on the device. The data won’t be includedinaniCloudorlocalbackup. AccessControlFlags define the mechanisms with which users can authenticate the key (SecAccessControlCreate- Flags): • kSecAccessControlDevicePasscode: Accesstheitemviaapasscode. • kSecAccessControlBiometryAny: Access the item via one of the fingerprints registered to Touch ID. Adding or removingafingerprintwon’tinvalidatetheitem. • kSecAccessControlBiometryCurrentSet:AccesstheitemviaoneofthefingerprintsregisteredtoTouchID.Adding orremovingafingerprintwillinvalidatetheitem. • kSecAccessControlUserPresence: Accesstheitemviaeitheroneoftheregisteredfingerprints(usingTouchID)or defaulttothepasscode. Please note that keys secured by Touch ID (via kSecAccessControlBiometryAny or kSecAccessControlBiometryCur- rentSet)areprotectedbytheSecureEnclave: TheKeychainholdsatokenonly,nottheactualkey. Thekeyresidesin theSecureEnclave. StartingwithiOS9,youcandoECC-basedsigningoperationsintheSecureEnclave. Inthatscenario,theprivatekeyand thecryptographicoperationsresidewithintheSecureEnclave. Seethestaticanalysissectionformoreinfooncreating theECCkeys. iOS9supportsonly256-bitECC.Furthermore,youneedtostorethepublickeyintheKeychainbecauseit can’tbestoredintheSecureEnclave. Afterthekeyiscreated,youcanusethekSecAttrKeyTypetoindicatethetypeof algorithmyouwanttousethekeywith. In case you want to use these mechanisms, it is recommended to test whether the passcode has been set. In iOS 8, you will need to check whether you can read/write from an item in the Keychain protected by the kSecAttrAccessi- bleWhenPasscodeSetThisDeviceOnly attribute. From iOS 9 onward you can check whether a lock screen is set, using LAContext: Swift: public func devicePasscodeEnabled()->Bool { return LAContext().canEvaluatePolicy(.deviceOwnerAuthentication,error:nil) } Objective-C: -(BOOL)devicePasscodeEnabled:(LAContext)context{ if([contextcanEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationerror:nil]) { return true; }else { return false; } } 402\\nHere is sample Swift code you can use to create keys (Notice the kSecAttrTokenID as String: kSecAttrTokenIDSe- cureEnclave: thisindicatesthatwewanttousetheSecureEnclavedirectly.): //privatekeyparameters letprivateKeyParams =[ kSecAttrLabel asString:\"privateLabel\", kSecAttrIsPermanent asString:true, kSecAttrApplicationTag asString:\"applicationTag\", ]asCFDictionary //publickeyparameters letpublicKeyParams =[ kSecAttrLabel asString:\"publicLabel\", kSecAttrIsPermanent asString:false, kSecAttrApplicationTag asString:\"applicationTag\", ]asCFDictionary //globalparameters letparameters =[ kSecAttrKeyType asString:kSecAttrKeyTypeEC, kSecAttrKeySizeInBits asString:256, kSecAttrTokenID asString:kSecAttrTokenIDSecureEnclave, kSecPublicKeyAttrs asString:publicKeyParams, kSecPrivateKeyAttrs asString:privateKeyParams, ]asCFDictionary varpubKey,privKey:SecKey? letstatus =SecKeyGeneratePair(parameters,&pubKey,&privKey) ifstatus !=errSecSuccess { //Keyscreatedsuccessfully } Keychain Data Persistence OniOS,whenanapplicationisuninstalled,theKeychaindatausedbytheapplicationisretainedbythedevice,unlikethe datastoredbytheapplicationsandboxwhichiswiped. Intheeventthatausersellstheirdevicewithoutperforminga factoryreset,thebuyerofthedevicemaybeabletogainaccesstotheprevioususer’sapplicationaccountsanddataby reinstallingthesameapplicationsusedbytheprevioususer. Thiswouldrequirenotechnicalabilitytoperform. When assessing an iOS application, you should look for Keychain data persistence. This is normally done by using the application to generate sample data that may be", "metadata": {"doc_id": "OWASP_MASTG", "chunk_id": 137}}