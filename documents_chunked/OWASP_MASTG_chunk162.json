{"text": "returncompletion(.failure(.jsonError)) } returncompletion(.success(response)) } } } task.resume() } Testing Object Persistence Platform: ios MASVSV1: MSTG-PLATFORM-8 MASVSV2: MASVS-CODE-4 Overview Static Analysis Alldifferentflavorsofobjectpersistencesharethefollowingconcerns: • Ifyouuseobjectpersistencetostoresensitiveinformationonthedevice,thenmakesurethatthedataisencrypted: eitheratthedatabaselevel,orspecificallyatthevaluelevel. • Needtoguaranteetheintegrityoftheinformation? UseanHMACmechanismorsigntheinformationstored. Always verifytheHMAC/signaturebeforeprocessingtheactualinformationstoredintheobjects. • MakesurethatkeysusedinthetwonotionsabovearesafelystoredintheKeyChainandwellprotected. Seethe chapter“DataStorageoniOS”formoredetails. • Ensurethatthedatawithinthedeserializedobjectiscarefullyvalidatedbeforeitisactivelyused(e.g.,noexploit ofbusiness/applicationlogicispossible). • DonotusepersistencemechanismsthatuseRuntimeReferencetoserialize/deserializeobjectsinhigh-riskappli- cations,astheattackermightbeabletomanipulatethestepstoexecutebusinesslogicviathismechanism(see thechapter“iOSAnti-ReversingDefenses”formoredetails). • NotethatinSwift2andbeyond,aMirrorcanbeusedtoreadpartsofanobject,butcannotbeusedtowriteagainst theobject. Dynamic Analysis Thereareseveralwaystoperformdynamicanalysis: • Fortheactualpersistence: Usethetechniquesdescribedinthe“DataStorageoniOS”chapter. • For the serialization itself: Use a debug build or use Frida / objection to see how the serialization methods are handled(e.g.,whethertheapplicationcrashesorextrainformationcanbeextractedbyenrichingtheobjects). Memory Corruption Bugs Platform: ios MASVSV1: MSTG-CODE-8 MASVSV2: MASVS-CODE-4 501\\nOverview Static Analysis Aretherenativecodeparts? Ifso: checkforthegivenissuesinthegeneralmemorycorruptionsection. Nativecodeisa littlehardertospotwhencompiled. IfyouhavethesourcesthenyoucanseethatCfilesuse.csourcefilesand.hheader files and C++ uses .cpp files and .h files. This is a little different from the .swift and the .m source files for Swift and Objective-C.Thesefilescanbepartofthesources,orpartofthirdpartylibraries,registeredasframeworksandimported throughvarioustools,suchasCarthage,theSwiftPackageManagerorCocoapods. Foranymanagedcode(Objective-C/Swift)intheproject,checkthefollowingitems: • ThedoubleFreeissue: whenfreeiscalledtwiceforagivenregioninsteadofonce. • Retainingcycles: lookforcyclicdependenciesbymeansofstrongreferencesofcomponentstooneanotherwhich keepmaterialsinmemory. • UsinginstancesofUnsafePointercanbemanagedwrongly,whichwillallowforvariousmemorycorruptionissues. • TryingtomanagethereferencecounttoanobjectbyUnmanagedmanually,leadingtowrongcounternumbersand atoolate/toosoonrelease. AgreattalkisgivenonthissubjectatRealmacademyandanicetutorialtoseewhatisactuallyhappeningisprovided byRayWenderlichonthissubject. PleasenotethatwithSwift5youcanonlydeallocatefullblocks,whichmeanstheplaygroundhaschangedabit. Dynamic Analysis There are various tools provided which help to identify memory bugs within Xcode, such as the Debug Memory graph introducedinXcode8andtheAllocationsandLeaksinstrumentinXcode. Next,youcancheckwhethermemoryisfreedtoofastortooslowbyenablingNSAutoreleaseFreedObjectCheckEnabled, NSZombieEnabled,NSDebugEnabledinXcodewhiletestingtheapplication. Therearevariouswellwrittenexplanationswhichcanhelpwithtakingcareofmemorymanagement. Thesecanbefound inthereferencelistofthischapter. Testing Enforced Updating Platform: ios MASVSV1: MSTG-ARCH-9 MASVSV2: MASVS-CODE-2 Overview Static Analysis Firstseewhetherthereisanupdatemechanismatall: ifitisnotyetpresent,itmightmeanthatuserscannotbeforced toupdate. Ifthemechanismispresent,seewhetheritenforces“alwayslatest”andwhetherthatisindeedinlinewith thebusinessstrategy. Otherwisecheckifthemechanismissupportingtoupdatetoagivenversion. Makesurethatevery entryoftheapplicationgoesthroughtheupdatingmechanisminordertomakesurethattheupdate-mechanismcannot bebypassed. Dynamic analysis Inordertotestforproperupdating: trydownloadinganolderversionoftheapplicationwithasecurityvulnerability,either byareleasefromthedevelopersorbyusingathirdpartyapp-store. Next,verifywhetherornotyoucancontinuetouse 502\\ntheapplicationwithoutupdatingit. Ifanupdatepromptisgiven,verifyifyoucanstillusetheapplicationbycancelingthe prompt or otherwise circumventing it through normal application usage. This includes validating whether the backend willstopcallstovulnerablebackendsand/orwhetherthevulnerableapp-versionitselfisblockedbythebackend. Finally, seeifyoucanplaywiththeversionnumberofaman-in-the-middledappandseehowthebackendrespondstothis(and ifitisrecordedatallforinstance). Checking for Weaknesses in Third Party Libraries Platform: ios MASVSV1: MSTG-CODE-5 MASVSV2: MASVS-CODE-3 Overview Static Analysis Detecting vulnerabilities of third party libraries Inordertoensurethatthelibrariesusedbytheappsarenotcarryingvulnerabilities,onecanbestcheckthedependencies installedbyCocoaPodsorCarthage. Swift Package Manager IncaseSwiftPackageManagerisusedformanagingthirdpartydependencies,thefollowingstepscanbetakentoanalyze thethirdpartylibrariesforvulnerabilities: First,attherootoftheproject,wherethePackage.swiftfileislocated,type swiftbuild Next, checkthefilePackage.resolvedfortheactualversionsusedandinspectthegivenlibrariesforknownvulnerabili- ties. YoucanutilizetheOWASPDependency-Check’sexperimentalSwiftPackageManagerAnalyzertoidentifytheCommon PlatformEnumeration(CPE)namingschemeofalldependenciesandanycorrespondingCommonVulnerabilityandExpo- sure(CVE)entries. Scantheapplication’sPackage.swiftfileandgenerateareportofknownvulnerablelibrarieswiththe followingcommand: dependency-check --enableExperimental --out .--scan Package.swift CocoaPods IncaseCocoaPodsisusedformanagingthirdpartydependencies,thefollowingstepscanbetakentoanalyzethethird partylibrariesforvulnerabilities. First,attherootoftheproject,wherethePodfileislocated,executethefollowingcommands: sudo geminstallcocoapods podinstall Next,nowthatthedependencytreehasbeenbuilt,youcancreateanoverviewofthedependenciesandtheirversions byrunningthefollowingcommands: sudo geminstallcocoapods-dependencies poddependencies Theresultofthestepsabovecannowbeusedasinputforsearchingdifferentvulnerabilityfeedsforknownvulnerabili- ties. 503\\nNote: 1. If the developer packs all dependencies in terms of its own support library using a .podspec file, then this .podspecfilecanbecheckedwiththeexperimentalCocoaPodspodspecchecker. 2. IftheprojectusesCocoaPodsincombinationwithObjective-C,SourceClearcanbeused. 3. Using CocoaPods with HTTP-based links instead of HTTPS might allow for man-in-the-middle attacks during the download of the dependency, allowing an attacker to replace (parts of) the library with other content. Therefore,alwaysuseHTTPS. YoucanutilizetheOWASPDependency-Check’sexperimentalCocoaPodsAnalyzertoidentifytheCommonPlatformEnu- meration (CPE) naming scheme of all dependencies and any corresponding Common Vulnerability and Exposure (CVE) entries. Scantheapplication’s*.podspecand/orPodfile.lockfilesandgenerateareportofknownvulnerablelibrarieswith thefollowingcommand: dependency-check --enableExperimental --out .--scan Podfile.lock Carthage IncaseCarthageisusedforthirdpartydependencies, thenthefollowingstepscanbetakentoanalyzethethirdparty librariesforvulnerabilities. First,attherootoftheproject,wheretheCartfileislocated,type brewinstallcarthage carthageupdate --platform iOS Next,checktheCartfile.resolvedforactualversionsusedandinspectthegivenlibrariesforknownvulnerabilities. Note, atthetimeofwritingthischapter, thereisnoautomatedsupportforCarthagebaseddependencyanalysis knowntotheauthors. Atleast,thisfeaturewasalreadyrequestedfortheOWASPDependencyChecktoolbutnot yetimplemented(seetheGitHubissue). Discovered library vulnerabilities Whenalibraryisfoundtocontainvulnerabilities,thenthefollowingreasoningapplies: • Isthelibrarypackagedwiththeapplication? Thencheckwhetherthelibraryhasaversioninwhichthevulnerability ispatched. Ifnot,checkwhetherthevulnerabilityactuallyaffectstheapplication. Ifthatisthecaseormightbethe caseinthefuture,thenlookforanalternativewhichprovidessimilarfunctionality,butwithoutthevulnerabilities. • Isthelibrarynotpackagedwiththeapplication? Seeifthereisapatchedversioninwhichthevulnerabilityisfixed. If thisisnotthecase,checkiftheimplicationsofthevulnerabilityforthebuildprocess. Couldthevulnerabilityimpede abuildorweakenthesecurityofthebuild-pipeline? Thentrylookingforanalternativeinwhichthevulnerabilityis fixed. Incaseframeworksareaddedmanuallyaslinkedlibraries: 1. Openthexcodeprojfileandchecktheprojectproperties. 2. Go to the tab Build Phases and check the entries in Link Binary With Libraries for any of the libraries. See earliersectionsonhowtoobtainsimilarinformationusingMobSF. Inthecaseofcopy-pastedsources: searchtheheaderfiles(incaseofusingObjective-C)andotherwisetheSwiftfilesfor knownmethodnamesforknownlibraries. Next, note that for hybrid applications, you will have to check the JavaScript dependencies with RetireJS. Similarly for Xamarin,youwillhavetochecktheC#dependencies. Last,iftheapplicationisahigh-riskapplication,youwillendupvettingthelibrarymanually. Inthatcasetherearespecific requirements for native code, which are similar to the requirements established by the MASVS for the application as a whole. Nexttothat,itisgoodtovetwhetherallbestpracticesforsoftwareengineeringareapplied. 504\\nDynamic Analysis Thedynamicanalysisofthissectioncomprisesoftwoparts: theactuallicenseverificationandcheckingwhichlibraries areinvolvedincaseofmissingsources. Itneedtobevalidatedwhetherthecopyrightsofthelicenseshavebeenadheredto. Thisoftenmeansthattheapplication shouldhaveanaboutorEULAsectioninwhichthecopy-rightstatementsarenotedasrequiredbythelicenseofthethird partylibrary. Listing Application Libraries When performing app analysis, it is important to also analyze the app dependencies (usually in form of libraries or so- called iOS Frameworks) and ensure that they don’t contain any vulnerabilities. Even when you don’t", "metadata": {"doc_id": "OWASP_MASTG", "chunk_id": 162}}