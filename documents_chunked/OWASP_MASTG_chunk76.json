{"text": "Asanadditionallayerofsecurity,pushnotificationscanbeencryptedbyusingCapillary. Capillaryisalibrarytosimplify thesendingofend-to-end(E2E)encryptedpushmessagesfromJava-basedapplicationserverstoAndroidclients. Reviewing Disassembled Native Code Platform: android Followingtheexamplefrom“DisassemblingNativeCode”wewillusedifferentdisassemblerstoreviewthedisassembled nativecode. radare2 Onceyou’veopenedyourfileinradare2youshouldfirstgettheaddressofthefunctionyou’relookingfor. Youcandothis bylistingorgettinginformationiaboutthesymbolss(is)andgrepping(~radare2’sbuilt-ingrep)forsomekeyword,in ourcasewe’relookingforJNIrelatedsymbolssoweenter“Java”: $r2 -AHelloWord-JNI/lib/armeabi-v7a/libnative-lib.so ... [0x00000e3c]>is~Java 0030x00000e780x00000e78GLOBAL FUNC 16Java_sg_vantagepoint_helloworldjni_MainActivity_stringFromJNI Themethodcanbefoundataddress0x00000e78. Todisplayitsdisassemblysimplyrunthefollowingcommands: [0x00000e3c]>eemu.str=true; [0x00000e3c]>s0x00000e78 [0x00000e78]>af [0x00000e78]>pdf ╭(fcn)sym.Java_sg_vantagepoint_helloworldjni_MainActivity_stringFromJNI12 │ sym.Java_sg_vantagepoint_helloworldjni_MainActivity_stringFromJNI (int32_targ1); │ ;argint32_targ1@r0 │ 0x00000e78 ~ 0268 ldrr2, [r0] ;arg1 │ ;--aav.0x00000e79: │ ;UNKNOWNXREFfromaav.0x00000189 (+0x3) │ 0x00000e79 unaligned │ 0x00000e7a 0249 ldrr1,aav.0x00000f3c ;[0xe84:4]=0xf3caav.0x00000f3c │ 0x00000e7c d2f89c22 ldr.wr2,[r2,0x29c] │ 0x00000e80 7944 addr1,pc ;\"HellofromC++\" section..rodata ╰ 0x00000e82 1047 bxr2 Let’sexplainthepreviouscommands: 171\\n• eemu.str=true;enablesradare2’sstringemulation. Thankstothis,wecanseethestringwe’relookingfor(“Hello fromC++”). • s 0x00000e78isaseektotheaddresss 0x00000e78,whereourtargetfunctionislocated. Wedothissothatthe followingcommandsapplytothisaddress. • pdfmeansprintdisassemblyoffunction. Usingradare2youcanquicklyruncommandsandexitbyusingtheflags-qc '<commands>'. Fromthepreviousstepswe knowalreadywhattodosowewillsimplyputeverythingtogether: $r2 -qc'eemu.str=true;s0x00000e78;af;pdf' HelloWord-JNI/lib/armeabi-v7a/libnative-lib.so ╭(fcn)sym.Java_sg_vantagepoint_helloworldjni_MainActivity_stringFromJNI12 │ sym.Java_sg_vantagepoint_helloworldjni_MainActivity_stringFromJNI (int32_targ1); │ ;argint32_targ1@r0 │ 0x00000e78 0268 ldrr2, [r0] ;arg1 │ 0x00000e7a 0249 ldrr1, [0x00000e84] ;[0xe84:4]=0xf3c │ 0x00000e7c d2f89c22 ldr.wr2,[r2,0x29c] │ 0x00000e80 7944 addr1,pc ;\"HellofromC++\" section..rodata ╰ 0x00000e82 1047 bxr2 Noticethatinthiscasewe’renotstartingwiththe-Aflagnotrunningaaa. Instead,wejusttellradare2toanalyzethat onefunctionbyusingtheanalyzefunctionafcommand. Thisisoneofthosecaseswherewecanspeedupourworkflow becauseyou’refocusingonsomespecificpartofanapp. Theworkflowcanbefurtherimprovedbyusingr2ghidra,adeepintegrationofGhidradecompilerforradare2. r2ghidra generatesdecompiledCcode,whichcanaidinquicklyanalyzingthebinary. IDA Pro Weassumethatyou’vesuccessfullyopenedlib/armeabi-v7a/libnative-lib.soinIDApro. Oncethefileisloaded,click intothe“Functions”windowontheleftandpressAlt+ttoopenthesearchdialog. Enter“java”andhitenter. Thisshould highlight the Java_sg_vantagepoint_helloworld_ MainActivity_stringFromJNI function. Double-click the function tojumptoitsaddressinthedisassemblyWindow. “IdaView-A”shouldnowshowthedisassemblyofthefunction. Notalotofcodethere,butyoushouldanalyzeit. Thefirstthingyouneedtoknowisthatthefirstargumentpassedto everyJNIfunctionisaJNIinterfacepointer. Aninterfacepointerisapointertoapointer. Thispointerpointstoafunction table: anarrayofevenmorepointers,eachofwhichpointstoaJNIinterfacefunction(isyourheadspinningyet?). The functiontableisinitializedbytheJavaVMandallowsthenativefunctiontointeractwiththeJavaenvironment. Withthatinmind,let’shavealookateachlineofassemblycode. 172\\nLDR R2,[R0] Remember: thefirstargument(inR0)isapointertotheJNIfunctiontablepointer. TheLDRinstructionloadsthisfunction tablepointerintoR2. LDR R1,=aHelloFromC ThisinstructionloadsintoR1thePC-relativeoffsetofthestring“HellofromC++”. Notethatthisstringcomesdirectly after the end of the function block at offset 0xe84. Addressing relative to the program counter allows the code to run independentlyofitspositioninmemory. LDR.W R2,[R2,#0x29C] Thisinstructionloadsthefunctionpointerfromoffset0x29CintotheJNIfunctionpointertablepointedtobyR2. Thisis theNewStringUTFfunction. Youcanlookatthelistoffunctionpointersinjni.h,whichisincludedintheAndroidNDK.The functionprototypelookslikethis: jstring (*NewStringUTF)(JNIEnv*,const char*); Thefunctiontakestwoarguments: theJNIEnvpointer(alreadyinR0)andaStringpointer. Next,thecurrentvalueofPC isaddedtoR1,resultingintheabsoluteaddressofthestaticstring“HellofromC++”(PC+offset). ADD R1,PC Finally,theprogramexecutesabranchinstructiontotheNewStringUTFfunctionpointerloadedintoR2: BX R2 Whenthisfunctionreturns,R0containsapointertothenewlyconstructedUTFstring. Thisisthefinalreturnvalue,soR0 isleftunchangedandthefunctionreturns. Ghidra AfteropeningthelibraryinGhidrawecanseeallthefunctionsdefinedintheSymbolTreepanelunderFunctions. The nativelibraryforthecurrentapplicationisrelativelyverysmall. Therearethreeuserdefinedfunctions: FUN_001004d0, FUN_0010051c,andJava_sg_vantagepoint_helloworldjni_MainActivity_stringFromJNI.Theothersymbolsarenot userdefinedandaregeneratedforproperfunctioningofthesharedlibrary. TheinstructionsinthefunctionJava_sg_- vantagepoint_helloworldjni_MainActivity_stringFromJNI are already discussed in detail in previous sections. In thissectionwecanlookintothedecompilationofthefunction. Inside the current function there is a call to another function, whose address is obtained by accessing an offset in the JNIEnvpointer(foundasplParm1). Thislogichasbeendiagrammaticallydemonstratedaboveaswell. Thecorresponding CcodeforthedisassembledfunctionisshownintheDecompilerwindow. ThisdecompiledCcodemakesitmucheasier tounderstandthefunctioncallbeingmade. Sincethisfunctionissmallandextremelysimple,thedecompilationoutput isveryaccurate,thiscanchangedrasticallywhendealingwithcomplexfunctions. 173\\nDisassembling Native Code Platform: android Dalvik and ART both support the Java Native Interface (JNI), which defines a way for Java code to interact with native codewritteninC/C++. AsonotherLinux-basedoperatingsystems,nativecodeispackaged(compiled)intoELFdynamic libraries (*.so), which the Android app loads at runtime via the System.load method. However, instead of relying on widelyusedClibraries(suchasglibc),AndroidbinariesarebuiltagainstacustomlibcnamedBionic. Bionicaddssupport forimportantAndroid-specificservicessuchassystempropertiesandlogging,anditisnotfullyPOSIX-compatible. WhenreversinganAndroidapplicationcontainingnativecode,weneedtounderstandacoupleofdatastructuresrelated totheJNIbridgebetweenJavaandnativecode. Fromthereversingperspective, weneedtobeawareoftwokeydata structures: JavaVMandJNIEnv. Bothofthemarepointerstopointerstofunctiontables: • JavaVM provides an interface to invoke functions for creating and destroying a JavaVM. Android allows only one JavaVMperprocessandisnotreallyrelevantforourreversingpurposes. • JNIEnvprovidesaccesstomostoftheJNIfunctionswhichareaccessibleatafixedoffsetthroughtheJNIEnvpointer. ThisJNIEnvpointeristhefirstparameterpassedtoeveryJNIfunction. Wewilldiscussthisconceptagainwiththe helpofanexamplelaterinthischapter. ItisworthhighlightingthatanalyzingdisassemblednativecodeismuchmorechallengingthandisassembledJavacode. WhenreversingthenativecodeinanAndroidapplicationwewillneedadisassembler. Inthenextexamplewe’llreversetheHelloWorld-JNI.apkfromtheOWASPMASTGrepository. Installingandrunningitin anemulatororAndroiddeviceisoptional. wget https://github.com/OWASP/owasp-mastg/raw/master/Samples/Android/01_HelloWorld-JNI/HelloWord-JNI.apk Thisappisnotexactlyspectacular,allitdoesisshowalabelwiththetext“HellofromC++”. ThisistheappAndroid generatesbydefaultwhenyoucreateanewprojectwithC/C++support, whichisjustenoughtoshowthebasic principlesofJNIcalls. 174\\nDecompiletheAPKwithapkx. $apkxHelloWord-JNI.apk ExtractingHelloWord-JNI.apktoHelloWord-JNI Converting:classes.dex ->classes.jar (dex2jar) dex2jarHelloWord-JNI/classes.dex ->HelloWord-JNI/classes.jar DecompilingtoHelloWord-JNI/src (cfr) ThisextractsthesourcecodeintotheHelloWord-JNI/srcdirectory. ThemainactivityisfoundinthefileHelloWord-JNI/ src/sg/vantagepoint/helloworldjni/MainActivity.java. The“HelloWorld”textviewispopulatedintheonCreate method: public class MainActivity extends AppCompatActivity { static { System.loadLibrary(\"native-lib\"); } @Override protected void onCreate(Bundlebundle){ super.onCreate(bundle); this.setContentView(2130968603); ((TextView)this.findViewById(2131427422)).setText((CharSequence)this. \\ stringFromJNI()); } public native String stringFromJNI(); } NotethedeclarationofpublicnativeStringstringFromJNIatthebottom. Thekeyword“native”tellstheJavacompiler thatthismethodisimplementedinanativelanguage. Thecorrespondingfunctionisresolvedduringruntime,butonlyif anativelibrarythatexportsaglobalsymbolwiththeexpectedsignatureisloaded(signaturescompriseapackagename, classname,andmethodname). Inthisexample,thisrequirementissatisfiedbythefollowingCorC++function: JNIEXPORTjstringJNICALLJava_sg_vantagepoint_helloworld_MainActivity_stringFromJNI(JNIEnv *env,jobject) Sowhereisthenativeimplementationofthisfunction? Ifyoulookintothe“lib”directoryoftheunzippedAPKarchive, you’ll see several subdirectories (one per supported processor architecture), each of them containing a version of the nativelibrary,inthiscaselibnative-lib.so. WhenSystem.loadLibraryiscalled,theloaderselectsthecorrectversion basedonthedevicethattheappisrunningon. Beforemovingahead,payattentiontothefirstparameterpassedtothe currentJNIfunction. ItisthesameJNIEnvdatastructurewhichwasdiscussedearlierinthissection. 175\\nFollowing the naming convention mentioned above, you can expect the library to export a symbol called Java_sg_- vantagepoint_helloworld_MainActivity_stringFromJNI.OnLinuxsystems,youcanretrievethelistofsymbolswith readelf(includedinGNUbinutils)ornm. DothisonmacOSwiththegreadelftool,whichyoucaninstallviaMacportsor Homebrew. Thefollowingexampleusesgreadelf: $greadelf -W-slibnative-lib.so |grep Java 3:00004e49 112FUNC GLOBALDEFAULT 11Java_sg_vantagepoint_helloworld_MainActivity_stringFromJNI Youcanalsoseethisusingradare2’srabin2: $rabin2 -sHelloWord-JNI/lib/armeabi-v7a/libnative-lib.so |grep -iJava 0030x00000e780x00000e78GLOBAL FUNC 16Java_sg_vantagepoint_helloworldjni_MainActivity_stringFromJNI ThisisthenativefunctionthateventuallygetsexecutedwhenthestringFromJNInativemethodiscalled. Todisassemblethecode,youcanloadlibnative-lib.sointoanydisassemblerthatunderstandsELFbinaries(i.e.,any disassembler). Iftheappshipswithbinariesfordifferentarchitectures,youcantheoreticallypickthearchitectureyou’re mostfamiliarwith,aslongasitiscompatiblewiththedisassembler. Eachversioniscompiledfromthesamesourceand implements the same functionality. However, if you’re planning to debug the library on a live device later, it’s usually wisetopickanARMbuild. To support both older and newer ARM processors, Android apps ship", "metadata": {"doc_id": "OWASP_MASTG", "chunk_id": 76}}