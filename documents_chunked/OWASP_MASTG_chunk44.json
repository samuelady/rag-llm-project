{"text": "user’s subsequent HTTP requests with that user. Otherwise, the user’s log in credentials wouldhavetobesentwitheveryrequest. Also,boththeserverandclientneedtokeeptrackofuserdata(e.g.,theuser’s privilegesorrole). Thiscanbedoneintwodifferentways: • Withstatefulauthentication,auniquesessionidisgeneratedwhentheuserlogsin. Insubsequentrequests,this sessionIDservesasareferencetotheuserdetailsstoredontheserver. ThesessionIDisopaque;itdoesn’tcontain anyuserdata. • With stateless authentication, all user-identifying information is stored in a client-side token. The token can be passed to any server or micro service, eliminating the need to maintain session state on the server. Stateless authenticationisoftenfactoredouttoanauthorizationserver,whichproduces,signs,andoptionallyencryptsthe tokenuponuserlogin. WebapplicationscommonlyusestatefulauthenticationwitharandomsessionIDthatisstoredinaclient-sidecookie. Al- thoughmobileappssometimesusestatefulsessionsinasimilarfashion,statelesstoken-basedapproachesarebecoming popularforavarietyofreasons: • Theyimprovescalabilityandperformancebyeliminatingtheneedtostoresessionstateontheserver. • Tokensenabledeveloperstodecoupleauthenticationfromtheapp. Tokenscanbegeneratedbyanauthentication server,andtheauthenticationschemecanbechangedseamlessly. Asamobilesecuritytester,youshouldbefamiliarwithbothtypesofauthentication. 51\\nStateful Authentication Stateful(or“session-based”)authenticationischaracterizedbyauthenticationrecordsonboththeclientandserver. The authenticationflowisasfollows: 1. Theappsendsarequestwiththeuser’scredentialstothebackendserver. 2. Theserververifiesthecredentials. Ifthecredentialsarevalid,theservercreatesanewsessionalongwitharandom sessionID. 3. TheserversendstotheclientaresponsethatincludesthesessionID. 4. TheclientsendsthesessionIDwithallsubsequentrequests. TheservervalidatesthesessionIDandretrievesthe associatedsessionrecord. 5. Aftertheuserlogsout,theserver-sidesessionrecordisdestroyedandtheclientdiscardsthesessionID. Whensessionsareimproperlymanaged,theyarevulnerabletoavarietyofattacksthatmaycompromisethesessionofa legitimateuser,allowingtheattackertoimpersonatetheuser. Thismayresultinlostdata,compromisedconfidentiality, andillegitimateactions. BestPractices: Locateanyserver-sideendpointsthatprovidesensitiveinformationorfunctionsandverifytheconsistentenforcementof authorization. Thebackendservicemustverifytheuser’ssessionIDortokenandmakesurethattheuserhassufficient privilegestoaccesstheresource. IfthesessionIDortokenismissingorinvalid,therequestmustberejected. Makesurethat: • SessionIDsarerandomlygeneratedontheserverside. • TheIDscan’tbeguessedeasily(useproperlengthandentropy). • SessionIDsarealwaysexchangedoversecureconnections(e.g.HTTPS). • Themobileappdoesn’tsavesessionIDsinpermanentstorage. • Theserververifiesthesessionwheneverausertriestoaccessprivilegedapplicationelements(asessionIDmust bevalidandmustcorrespondtotheproperauthorizationlevel). • Thesessionisterminatedontheserversideandsessioninformationdeletedwithinthemobileappafterittimes outortheuserlogsout. Authenticationshouldn’tbeimplementedfromscratchbutbuiltontopofprovenframeworks. Manypopularframeworks provide ready-made authentication and session management functionality. If the app uses framework APIs for authen- tication, check the framework security documentation for best practices. Security guides for common frameworks are availableatthefollowinglinks: • Spring(Java) • Struts(Java) • Laravel(PHP) • RubyonRails • ASP.Net Agreatresourcefortestingserver-sideauthenticationistheOWASPWebTestingGuide,specificallytheTestingAuthenti- cationandTestingSessionManagementchapters. Stateless Authentication Token-basedauthenticationisimplementedbysendingasignedtoken(verifiedbytheserver)witheachHTTPrequest. The mostcommonlyusedtokenformatistheJSONWebToken,definedinRFC7519. AJWTmayencodethecompletesession stateasaJSONobject. Therefore,theserverdoesn’thavetostoreanysessiondataorauthenticationinformation. JWTtokensconsistofthreeBase64Url-encodedpartsseparatedbydots. TheTokenstructureisasfollows: base64UrlEncode(header).base64UrlEncode(payload).base64UrlEncode(signature) ThefollowingexampleshowsaBase64Url-encodedJSONWebToken: 52\\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6Ikpva G4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ Theheadertypicallyconsistsoftwoparts: thetokentype,whichisJWT,andthehashingalgorithmbeingusedtocompute thesignature. Intheexampleabove,theheaderdecodesasfollows: {\"alg\":\"HS256\",\"typ\":\"JWT\"} The second part of the token is the payload, which contains so-called claims. Claims are statements about an entity (typically,theuser)andadditionalmetadata. Forexample: {\"sub\":\"1234567890\",\"name\":\"JohnDoe\",\"admin\":true} ThesignatureiscreatedbyapplyingthealgorithmspecifiedintheJWTheadertotheencodedheader,encodedpayload, andasecretvalue. Forexample,whenusingtheHMACSHA256algorithmthesignatureiscreatedinthefollowingway: HMACSHA256(base64UrlEncode(header)+\".\"+base64UrlEncode(payload),secret) Note that the secret is shared between the authentication server and the backend service - the client does not know it. This proves that the token was obtained from a legitimate authentication service. It also prevents the client from tamperingwiththeclaimscontainedinthetoken. BestPractices: VerifythattheimplementationadherestoJWTbestpractices: • VerifythattheHMACischeckedforallincomingrequestscontainingatoken. • VerifythattheprivatesigningkeyorHMACsecretkeyisneversharedwiththeclient. Itshouldbeavailableforthe issuerandverifieronly. • Verify that no sensitive data, such as personal identifiable information, is embedded in the JWT. For example, by decodingthebase64-encodedJWTandfindoutwhatkindofdataittransmitsandwhetherthatdataisencrypted. If,forsomereason,thearchitecturerequirestransmissionofsuchinformationinthetoken,makesurethatpayload encryptionisbeingapplied. SeethesampleJavaimplementationontheOWASPJWTCheatSheet. • Makesurethatreplayattacksareaddressedwiththejti(JWTID)claim,whichgivestheJWTauniqueidentifier. • Make sure that cross service relay attacks are addressed with the aud (audience) claim, which defines for which applicationthetokenisentitled. • Verifythattokensarestoredsecurelyonthemobilephone,with,forexample,KeyChain(iOS)orKeyStore(Android). • Verifythatthehashingalgorithmisenforced. Acommonattackincludesalteringthetokentouseanemptysignature (e.g.,signature=““)andsetthesigningalgorithmtonone,indicatingthat”theintegrityofthetokenhasalready beenverified”. Somelibrariesmighttreattokenssignedwiththenonealgorithmasiftheywerevalidtokenswith verifiedsignatures,sotheapplicationwilltrustalteredtokenclaims. • Verifythattokensincludean“exp”expirationclaimandthebackenddoesn’tprocessexpiredtokens. Acommon methodofgrantingtokenscombinesaccesstokensandrefreshtokens. Whentheuserlogsin,thebackendservice issuesashort-livedaccesstokenandalong-livedrefreshtoken. Theapplicationcanthenusetherefreshtokento obtainanewaccesstoken,iftheaccesstokenexpires. TherearetwodifferentBurpPluginsthatcanhelpyoufortestingthevulnerabilitieslistedabove: • JSONWebTokenAttacker • JSONWebTokens Also,makesuretocheckouttheOWASPJWTCheatSheetforadditionalinformation. OAuth 2.0 OAuth2.0isanauthorizationframeworkthatenablesthird-partyapplicationstoobtainlimitedaccesstouseraccounts onremoteHTTPservicessuchasAPIsandweb-enabledapplications. CommonusesforOAuth2include: 53\\n• Gettingpermissionfromtheusertoaccessanonlineserviceusingtheiraccount. • Authenticatingtoanonlineserviceonbehalfoftheuser. • Handlingauthenticationerrors. AccordingtoOAuth2.0,amobileclientseekingaccesstoauser’sresourcesmustfirstasktheusertoauthenticateagainst anauthenticationserver. Withtheusers’approval,theauthorizationserverthenissuesatokenthatallowstheapptoact onbehalfoftheuser. NotethattheOAuth2specificationdoesn’tdefineanyparticularkindofauthenticationoraccess tokenformat. Protocol Overview OAuth2.0definesfourroles: • ResourceOwner: theaccountowner • Client: theapplicationthatwantstoaccesstheuser’saccountwiththeaccesstokens • ResourceServer: hoststheuseraccounts • AuthorizationServer: verifiesuseridentityandissuesaccesstokenstotheapplication Note: The API fulfills both the Resource Owner and Authorization Server roles. Therefore, we will refer to both as the API. Hereisamoredetailedexplanationofthestepsinthediagram: 1. Theapplicationrequestsuserauthorizationtoaccessserviceresources. 2. If the user authorizes the request, the application receives an authorization grant. The authorization grant may takeseveralforms(explicit,implicit,etc.). 3. The application requests an access token from the authorization server (API) by presenting authentication of its ownidentityalongwiththeauthorizationgrant. 4. Iftheapplicationidentityisauthenticatedandtheauthorizationgrantisvalid,theauthorizationserver(API)issues anaccesstokentotheapplication,completingtheauthorizationprocess. Theaccesstokenmayhaveacompanion refreshtoken. 5. Theapplicationrequeststheresourcefromtheresourceserver(API)andpresentstheaccesstokenforauthentica- tion. Theaccesstokenmaybeusedinseveralways(e.g.,asabearertoken). 6. Iftheaccesstokenisvalid,theresourceserver(API)servestheresourcetotheapplication. InOAuth2,theuseragentistheentitythatperformstheauthentication. OAuth2authenticationcanbeperformedeither throughanexternaluseragent(e.g.ChromeorSafari)orintheappitself(e.g.throughaWebViewembeddedintothe apporanauthenticationlibrary). Noneofthetwomodesisintrinsically“better”thantheother. Thechoicedependson theapp’sspecificusecaseandthreatmodel. External User Agent: Usinganexternaluseragent isthemethodofchoiceforappsthatneedtointeractwithsocial mediaaccounts(Facebook,Twitter,etc.). Advantagesofthismethodinclude: 54\\n• The user’s credentials are never directly exposed to the app. This guarantees that the app cannot obtain the credentialsduringtheloginprocess(“credentialphishing”). • Almostnoauthenticationlogicmustbeaddedtotheappitself,preventingcodingerrors. Onthenegativeside,thereisnowaytocontrolthebehaviorofthebrowser(e.g.toactivatecertificatepinning). Embedded User Agent: Usinganembeddeduseragent isthemethodofchoiceforappsthatneedtooperatewithin a closed ecosystem, for example to interact with corporate accounts. For example, consider a banking app that uses OAuth2toretrieveanaccesstokenfromthebank’sauthenticationserver,whichisthenusedtoaccessanumberofmicro services. Inthatcase,credentialphishingisnotaviablescenario. Itislikelypreferabletokeeptheauthenticationprocess inthe(hopefully)carefullysecuredbankingapp,insteadofplacingtrustonexternalcomponents. Best Practices Foradditionalbestpracticesanddetailedinformationpleaserefertothefollowingsourcedocuments: • RFC6749-TheOAuth2.0AuthorizationFramework(October2012) • RFC8252-OAuth2.0forNativeApps(October2017) • RFC6819-OAuth2.0ThreatModelandSecurityConsiderations(January2013) Someofthebestpracticesincludebutarenotlimitedto: •", "metadata": {"doc_id": "OWASP_MASTG", "chunk_id": 44}}