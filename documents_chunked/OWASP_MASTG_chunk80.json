{"text": "taint analysis. Another notable tool supporting taintanalysisforAndroidappsisGDA. Forourdemonstration,we’lluseFlowDroid’scommandlinetooltoperformtaintanalysisontheInsecureShopv1.0appli- cation. TheInsecureShopappacceptsausernameandpasswordasinputandstoresthemintheapp’ssharedpreferences. In ourtaintanalysis, we’reinterestedinhowthisstoredusernameandpasswordareused. Inthiscontext, theusername andpasswordarethesensitiveinformation,andreadingfromsharedpreferencesisthesource. Thesinkinthisanalysis couldbevariousoperations,suchassendinginfooverthenetwork,transmittinginfoviaanIntent,orstoringinfoinan externalfile. TouseFlowDroid,firstly,weneedtoprovideaninputlistofpotentialsourcesandsinkstoevaluatefor. Inourcase,reading fromsharedpreferenceswillbethesource,whileaddingparameterstoanIntentwillbethesink. Theconfigurationfile willlookasfollows(we’llnameit“source_sink.txt”): <android.content.SharedPreferences:java.lang.StringgetString(java.lang.String,java.lang.String)>->_SOURCE_ <android.content.Intent:android.content.IntentputExtra(java.lang.String,java.lang.CharSequence)>->_SINK_ <android.content.Intent:android.content.IntentputExtra(java.lang.String,char)>->_SINK_ <android.content.Intent:android.content.IntentputExtra(java.lang.String,java.lang.String)>->_SINK_ ToinvokeFlowDroidviathecommandline,usethefollowingcommand: 185\\njava-jarsoot-infoflow-cmd/target/soot-infoflow-cmd-jar-with-dependencies.jar\\ -aInsecureShop.apk\\ -pAndroid/Sdk/platforms\\ -ssource_sink.txt [main]INFOsoot.jimple.infoflow.android.SetupApplication$InPlaceInfoflow-Thesinkvirtualinvoker2.<android.content.Intent:android.content.Intent ↪ putExtra(java.lang.String,java.lang.String)>(\"password\",$r5)inmethod<com.insecureshop.AboutUsActivity:voidonSendData(android.view.View)>wascalled ↪ withvaluesfromthefollowingsources: [main]INFOsoot.jimple.infoflow.android.SetupApplication$InPlaceInfoflow--$r1=interfaceinvoke$r2.<android.content.SharedPreferences:java.lang.String ↪ getString(java.lang.String,java.lang.String)>(\"password\",\"\")inmethod<com.insecureshop.util.Prefs:java.lang.StringgetPassword()> ... [main]INFOsoot.jimple.infoflow.android.SetupApplication$InPlaceInfoflow-Thesinkvirtualinvoker2.<android.content.Intent:android.content.Intent ↪ putExtra(java.lang.String,java.lang.String)>(\"username\",$r4)inmethod<com.insecureshop.AboutUsActivity:voidonSendData(android.view.View)>wascalled ↪ withvaluesfromthefollowingsources: [main]INFOsoot.jimple.infoflow.android.SetupApplication$InPlaceInfoflow--$r1=interfaceinvoke$r2.<android.content.SharedPreferences:java.lang.String ↪ getString(java.lang.String,java.lang.String)>(\"username\",\"\")inmethod<com.insecureshop.util.Prefs:java.lang.StringgetUsername()> ... [main]INFOsoot.jimple.infoflow.android.SetupApplication-Found2leaks Theoutputalsousesthejimpleintermediaterepresentationandrevealstwoleaksintheapplication,eachcorresponding to the username and password. Given that the InsecureShop app is open-source, we can refer to its source code to validatethefindings,asshownbelow: //file:AboutActivity.kt funonSendData(view:View){ valuserName =Prefs.username!! valpassword =Prefs.password!! valintent =Intent(\"com.insecureshop.action.BROADCAST\") intent.putExtra(\"username\",userName) intent.putExtra(\"password\",password) sendBroadcast(intent) textView.text =\"InsecureShopisanintentionallydesignedvulnerableandroidappbuiltinKotlin.\" } Taint analysis is especially beneficial for automating data flow analysis in intricate applications. However, given the complexityofsomeapps,theaccuracyofsuchtoolscanvary. Thus,it’sessentialforreviewerstofindabalancebetween theaccuracyoftoolsandthetimespentonmanualanalysis. Waiting for the Debugger Platform: android TheUnCrackableAppforAndroidLevel1isnotstupid: itnoticesthatithasbeenrunindebuggablemodeandreactsby shuttingdown. Amodaldialogisshownimmediately,andthecrackmeterminatesonceyoutap“OK”. Fortunately,Android’s“Developeroptions”containtheuseful“WaitforDebugger”feature,whichallowsyoutoautomat- icallysuspendanappduringstartupuntilaJDWPdebuggerconnects. Withthisfeature,youcanconnectthedebugger beforethedetectionmechanismruns,andtrace,debug,anddeactivatethatmechanism. It’sreallyanunfairadvantage, but,ontheotherhand,reverseengineersneverplayfair! 186\\nIntheDeveloperoptions,pickUncrackable1asthedebuggingapplicationandactivatethe“WaitforDebugger”switch. 187\\nNote: Even with ro.debuggable set to “1” in default.prop, an app won’t show up in the “debug app” list unless the android:debuggableflagissetto\"true\"intheAndroidManifest. Emulation-based Analysis Platform: android The Android emulator is based on QEMU, a generic and open source machine emulator. QEMU emulates a guest CPU bytranslatingtheguestinstructionson-the-flyintoinstructionsthehostprocessorcanunderstand. Eachbasicblockof guestinstructionsisdisassembledandtranslatedintoanintermediaterepresentationcalledTinyCodeGenerator(TCG). TheTCGblockiscompiledintoablockofhostinstructions,storedinacodecache,andexecuted. Afterexecutionofthe basicblock,QEMUrepeatstheprocessforthenextblockofguestinstructions(orloadsthealreadytranslatedblockfrom thecache). Thewholeprocessiscalleddynamicbinarytranslation. BecausetheAndroidemulatorisaforkofQEMU,itcomeswithallQEMUfeatures,includingmonitoring,debugging,and tracingfacilities. QEMU-specificparameterscanbepassedtotheemulatorwiththe-qemucommandlineflag. Youcan useQEMU’sbuilt-intracingfacilitiestologexecutedinstructionsandvirtualregistervalues. StartingQEMUwiththe-d commandlineflagwillcauseittodumptheblocksofguestcode,microoperations,orhostinstructionsbeingexecuted. Withthe-d_asmflag,QEMUlogsallbasicblocksofguestcodeastheyenterQEMU’stranslationfunction. Thefollowing commandlogsalltranslatedblockstoafile: emulator -show-kernel -avd Nexus_4_API_19 -snapshot default-boot -no-snapshot-save -qemu -din_asm,cpu 2>/tmp/qemu.log Unfortunately,generatingacompleteguestinstructiontracewithQEMUisimpossiblebecausecodeblocksarewrittento thelogonlyatthetimetheyaretranslated,notwhenthey’retakenfromthecache. Forexample,ifablockisrepeatedly executed in a loop, only the first iteration will be printed to the log. There’s no way to disable TB caching in QEMU (besideshackingthesourcecode). Nevertheless,thefunctionalityissufficientforbasictasks,suchasreconstructingthe disassemblyofanativelyexecutedcryptographicalgorithm. 188\\nReverse Engineering Android Apps Platform: android Android’sopennessmakesitafavorableenvironmentforreverseengineers,offeringbigadvantagesthatarenotavailable withiOS.BecauseAndroidisopen-source,youcanstudyitssourcecodeattheAndroidOpenSourceProject(AOSP)and modifytheOSanditsstandardtoolsanywayyouwant. Evenonstandardretaildevices,itispossibletodothingslike activatingdevelopermodeandsideloadingappswithoutjumpingthroughmanyhoops. Fromthepowerfultoolsshipping withtheSDKtothewiderangeofavailablereverseengineeringtools,there’salotofnicetiestomakeyourlifeeasier. However,therearealsoafewAndroid-specificchallenges. Forexample,you’llneedtodealwithbothJavabytecodeand nativecode. JavaNativeInterface(JNI)issometimesdeliberatelyusedtoconfusereverseengineers(tobefair,thereare legitimatereasonsforusingJNI,suchasimprovingperformanceorsupportinglegacycode). Developerssometimesuse thenativelayerto“hide”dataandfunctionality,andtheymaystructuretheirappssuchthatexecutionfrequentlyjumps betweenthetwolayers. You’llneedatleastaworkingknowledgeofboththeJava-basedAndroidenvironmentandtheLinuxOSandKernel, on which Android is based. You’ll also need the right toolset to deal with both the bytecode running on the Java virtual machineandthenativecode. Repackaging Apps Platform: android Ifyouneedtotestonanon-jailbrokendeviceyoushouldlearnhowtorepackageanapptoenabledynamictestingon it. Useacomputertoperformallthestepsindicatedinthearticle“PatchingAndroidApplications”fromtheobjectionWiki. Onceyou’redoneyou’llbeabletopatchanAPKbycallingtheobjectioncommand: objectionpatchapk --source app-release.apk Thepatchedapplicationthenneedstobeinstalledusingadb,asexplainedin“InstallingApps”. Thisrepackagingmethodisenoughformostusecases. Formoreadvancedrepackaging,referto“AndroidTampering andReverseEngineering-Patching,RepackagingandRe-Signing”. 189\\nAndroid Data Storage Overview Thischapterdiscussestheimportanceofsecuringsensitivedata,likeauthenticationtokensandprivateinformation,vital formobilesecurity. We’lllookatAndroid’sAPIsforlocaldatastorageandsharebestpractices. While it’s preferable to limit sensitive data on local storage, or avoid it at all whenever possible, practical use cases oftennecessitateuserdatastorage. Forexample,toimproveuserexperience,appscacheauthenticationtokenslocally, circumventingtheneedforcomplexpasswordentryateachappstart. Appsmayalsoneedtostorepersonallyidentifiable information(PII)andothersensitivedata. Sensitivedatacanbecomevulnerableifimproperlyprotected,potentiallystoredinvariouslocations,includingthedevice oranexternalSDcard. It’simportanttoidentifytheinformationprocessedbythemobileappandclassifywhatcounts as sensitive data. Check out the “Identifying Sensitive Data” section in the “Mobile App Security Testing” chapter for data classification details. Refer to Security Tips for Storing Data in the Android developer’s guide for comprehensive insights. Sensitive information disclosure risks include potential information decryption, social engineering attacks (if PII is dis- closed), account hijacking (if session information or an authentication token is disclosed), and app exploitation with a paymentoption. In addition to data protection, validate and sanitize data from any storage source. This includes checking correct data typesandimplementingcryptographiccontrols,suchasHMACs,fordataintegrity. Androidoffersvariousdatastoragemethods,tailoredtousers,developers,andapplications. Commonpersistentstorage techniquesinclude: • SharedPreferences • SQLiteDatabases • FirebaseDatabases • RealmDatabases • InternalStorage • ExternalStorage • Keystore Additionally,otherAndroidfunctionsthatcanresultindatastorageandshouldbetestedinclude: • LoggingFunctions • AndroidBackups • ProcessesMemory • KeyboardCaches • Screenshots Understanding each relevant data storage function is crucial for performing the appropriate test cases. This overview providesabriefoutlineofthesedatastoragemethodsandpointstesterstofurtherrelevantdocumentation. Shared Preferences The SharedPreferences API is commonly used to permanently save small collections of key-value pairs. Data stored in a SharedPreferences object is written to a plain-text XML file. The SharedPreferences object can be declared world- readable(accessibletoallapps)orprivate. MisuseoftheSharedPreferencesAPIcanoftenleadtoexposureofsensitive data. Considerthefollowingexample: ExampleforJava: SharedPreferencessharedPref =getSharedPreferences(\"key\",MODE_WORLD_READABLE); SharedPreferences.Editor editor =sharedPref.edit();", "metadata": {"doc_id": "OWASP_MASTG", "chunk_id": 80}}